

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="java">
  <meta name="author" content="吴天野">
  <meta name="keywords" content="">
  <title>mysql - 吴天野的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>吴天野的博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      吴天野
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-01 20:30" pubdate>
        2020年11月1日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      37
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">mysql</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="MySQL那些事儿"><a href="#MySQL那些事儿" class="headerlink" title="MySQL那些事儿"></a>MySQL那些事儿</h1><h2 id="一、MySQL数据类型"><a href="#一、MySQL数据类型" class="headerlink" title="一、MySQL数据类型"></a>一、MySQL数据类型</h2><h3 id="INT类型"><a href="#INT类型" class="headerlink" title="INT类型"></a>INT类型</h3><table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th></th>
<th><strong>字节</strong></th>
<th><strong>最小值</strong></th>
<th><strong>最大值</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td><strong>（带符号的/无符号的）</strong></td>
<td><strong>(带符号的/无符号的)</strong></td>
</tr>
<tr>
<td>TINYINT</td>
<td></td>
<td>1</td>
<td>-128    2^7</td>
<td>127</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td></td>
<td>2</td>
<td>-32768    2^15</td>
<td>32767</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td></td>
<td>3</td>
<td>-8388608   2^23</td>
<td>8388607</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>16777215</td>
</tr>
<tr>
<td>INT</td>
<td></td>
<td>4</td>
<td>-2147483648    2^31</td>
<td>2147483647</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td></td>
<td>8</td>
<td>-9223372036854775808</td>
<td>9223372036854775807</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>18446744073709551615</td>
</tr>
</tbody></table>
<div class="note note-warning">
            <p>unsigned 无符号最小值是0.  在用select a-b类似语句时，若目标字段为无符号，计算值为负则会报错</p>
          </div>

<div class="note note-warning">
            <p>int(N)不代表长度上限。而是代表显示宽度。使用zerofill 代表&lt;N时用0填充左边，超过N则原样显示</p>
          </div>

<ul>
<li><strong>int的常用场景：自增长</strong></li>
</ul>
<p>MySQL 每张表只能有1个自增长字段，其可以作为主键，也可以不作为主键。<span class="label label-primary">非主键情况下必须显示添加唯一索引</span></p>
<span class="label label-success">自增字段：插入null或0结果是自己自增，负数也是可以插进去的。</span>

<div class="note note-danger">
            <p><strong>面试题——自增长：</strong> </p><p>17之后删除15 16 17。再次插入数据，id是几？</p>
          </div>

<div class="note note-success">
            <p>回答：</p><p>mysql8.0之前  myisam：18    innodb(重启)：15     innodb(未重启)：18</p><p>mysql8.0之后   myisam：18   innodb：18</p>
          </div>



<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>N的含义</th>
<th>是否有字符集</th>
<th>最大长度</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(N)</td>
<td>定长字符</td>
<td><strong>字符</strong></td>
<td>是</td>
<td>255</td>
</tr>
<tr>
<td>VARCHAR(N)</td>
<td>变长字符</td>
<td><strong>字符</strong></td>
<td>是</td>
<td>16384</td>
</tr>
<tr>
<td>BINARY(N)</td>
<td>定长二进制字节</td>
<td>字节</td>
<td>否</td>
<td>255</td>
</tr>
<tr>
<td>VARBINARY(N)</td>
<td>变长二进制字节</td>
<td>字节</td>
<td>否</td>
<td>16384</td>
</tr>
<tr>
<td>TINYBLOB(N)</td>
<td>二进制大对象</td>
<td>字节</td>
<td>否</td>
<td>256</td>
</tr>
<tr>
<td>BLOB(N)</td>
<td>二进制大对象</td>
<td>字节</td>
<td>否</td>
<td>16K</td>
</tr>
<tr>
<td>MEDIUMBLOB(N)</td>
<td>二进制大对象</td>
<td>字节</td>
<td>否</td>
<td>16M</td>
</tr>
<tr>
<td>LONGBLOB(N)</td>
<td>二进制大对象</td>
<td>字节</td>
<td>否</td>
<td>4G</td>
</tr>
<tr>
<td>TINYTEXT(N)</td>
<td>大对象</td>
<td>字节</td>
<td>是</td>
<td>256</td>
</tr>
<tr>
<td>TEXT(N)</td>
<td>大对象</td>
<td>字节</td>
<td>是</td>
<td>16K</td>
</tr>
<tr>
<td>MEDIUMTEXT(N)</td>
<td>大对象</td>
<td>字节</td>
<td>是</td>
<td>16M</td>
</tr>
<tr>
<td>LONGTEXT(N)</td>
<td>大对象</td>
<td>字节</td>
<td>是</td>
<td>4G</td>
</tr>
</tbody></table>
<ul>
<li><strong>字符类型小tip：排序规则</strong></li>
</ul>
<p>我们会看到在创建表的时候，字符集有这样两种：<span class="label label-primary">bin</span>、<span class="label label-default">ci</span></p>
<span class="label label-primary">bin</span>指使用二进制形式，会区分大小写。

<div class="note note-danger">
            <p>面试题——字符集：select ‘a’ = ‘A’ 的执行结果</p>
          </div>

<div class="note note-success">
            <p>回答：</p><p>使用bin时，执行结果为0</p><p>使用ci时，执行结果为1</p>
          </div>



<h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h3><table>
<thead>
<tr>
<th>日期类型</th>
<th>占用空间</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01  00:00:00 ~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01  ~ 9999-12-31</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01  00:00:00UTC ~ 2038-01-19 03:14:07UTC</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>YEAR(2):1970-2070,  YEAR(4):1901-2155</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59  ~ 838:59:59</td>
</tr>
</tbody></table>
<p>需要注意的是<span class="label label-primary">DATETIME</span>、<span class="label label-default">TIMESTAMP</span>这两者存在时区上的区分。TIMESTAMP 能通过以下命令查看和设置时区：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> @@<span class="hljs-keyword">time_zone</span>;
<span class="hljs-keyword">set</span> <span class="hljs-keyword">time_zone</span>=<span class="hljs-string">&#x27;+00:00&#x27;</span>;</code></pre>



<h3 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h3><p>json_extract  抽取</p>
<pre><code class="hljs stylus">select
<span class="hljs-function"><span class="hljs-title">json_extract</span><span class="hljs-params">(data, <span class="hljs-string">&#x27;$.name&#x27;</span>)</span></span>,
<span class="hljs-function"><span class="hljs-title">json_extract</span><span class="hljs-params">(data, <span class="hljs-string">&#x27;$.address&#x27;</span>)</span></span></code></pre>

<p> JSON_OBJECT  将对象转为 json</p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> json_user <span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>,
json_object(&quot;name&quot;, &quot;enjoy&quot;, &quot;email&quot;, &quot;enjoy.com&quot;, &quot;age&quot;,<span class="hljs-number">35</span>) )</code></pre>

<p> json_insert 增加json结构 </p>
<pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-keyword">json</span> = <span class="hljs-string">&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3]&#125;&#x27;</span>;
<span class="hljs-keyword">select</span> json_insert(@<span class="hljs-keyword">json</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;$.c&#x27;</span>, <span class="hljs-string">&#x27;[true, false]&#x27;</span>);
<span class="hljs-keyword">update</span> json_user <span class="hljs-keyword">set</span> <span class="hljs-keyword">data</span> = json_insert(<span class="hljs-keyword">data</span>, <span class="hljs-string">&quot;$.address_2&quot;</span>, <span class="hljs-string">&quot;xiangxue&quot;</span>) <span class="hljs-keyword">where</span> uid = <span class="hljs-number">1</span>;</code></pre>

<p>json_merge 合并json结构</p>
<p>JSON_UNQUOTE  取消引用JSON值，并将结果作为<code>utf8mb4</code>字符串返回</p>
<pre><code class="hljs less"><span class="hljs-selector-tag">select</span> <span class="hljs-selector-tag">JSON_UNQUOTE</span>(json_extract(<span class="hljs-variable">@json</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>));</code></pre>



<h2 id="二、MySQL架构"><a href="#二、MySQL架构" class="headerlink" title="二、MySQL架构"></a>二、MySQL架构</h2><p>MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<span class="label label-primary">插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</span>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p><img src="/img/mysqljiagoutu.png" srcset="/img/loading.gif"></p>
<h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、身份认证、权限验证的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。</p>
<ul>
<li><strong>cache&amp;buffer</strong></li>
</ul>
<pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%query_cache_type%&#x27;</span> <span class="hljs-comment">-- 默认不开启</span>
<span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%query_cache_size%&#x27;</span> <span class="hljs-comment">--默认值 1M</span></code></pre>

<p>业务中并不推荐用cache，所以他也是默认关闭的。原因如下：</p>
<p>①浪费内存</p>
<p>②innodb有buffer提供类似功能</p>
<p>③太严格了！需要查询语句完全一致，包括字符集，那为啥不用redis呢？</p>
<ul>
<li><strong>Parser解析器</strong></li>
</ul>
<p><img src="/img/mysqljiexiqi.png" srcset="/img/loading.gif"></p>
<ul>
<li><strong>Optimizer优化器</strong></li>
</ul>
<pre><code class="hljs csharp"><span class="hljs-keyword">where</span> <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  &gt;&gt;&gt;  不使用<span class="hljs-keyword">where</span>

<span class="hljs-keyword">where</span> 主键 <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>   &gt;&gt;&gt;  impossible key

<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> account t <span class="hljs-keyword">where</span> t.<span class="hljs-function">id <span class="hljs-title">in</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> t2.id <span class="hljs-keyword">from</span> account t2</span>)   子查询   &gt;&gt;&gt;  关联查询</span></code></pre>



<h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</p>
<h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。</p>
<h2 id="三、MySQL存储引擎"><a href="#三、MySQL存储引擎" class="headerlink" title="三、MySQL存储引擎"></a>三、MySQL存储引擎</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 物理文件结构为：</p>
<span class="label label-primary">.frm</span> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等

<span class="label label-danger">.MYD</span> (MYData) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据

<span class="label label-danger">.MYI</span>  (MYIndex)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息

<div class="note note-warning">
            <p>myisam压缩后insert操作失效</p>
          </div>

<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 物理文件结构为：</p>
<span class="label label-primary">.frm</span> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等

<span class="label label-danger">.ibd</span> 文件或 <span class="label label-danger">.ibdata</span> 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。

<p>独享表空间存储方式使用.ibd文件，并且每个表一个.ibd文件</p>
<p>共享表空间存储方式使用.ibdata文件，所有表共同使用一个.ibdata文件（或多个，可自己配置）</p>
<h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><strong>索引文件和数据文件是否分开</strong>。（关于两者在索引上的具体实现方式的解析在下面索引知识点详细解读）</p>
<p>①InnoDB 支持事务，MyISAM 不支持事务</p>
<p>②InnoDB 支持外键，而 MyISAM 不支持。</p>
<p>③InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p>
<p>④InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p>
<p>⑤InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。MyISAM并发性不好。</p>
<h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><ol>
<li>以 csv 格式进行数据存储</li>
<li>所有列都不能为 null 的</li>
<li>不支持索引（不适合大表，不适合在线处理）</li>
<li>可以对数据文件直接编辑（保存文本文件内容</li>
</ol>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>文件系统存储特点，也称 HEAP 存储引擎，所以数据保存在内存中</p>
<ol>
<li>支持 HASH 索引(默认)和 BTree 索引</li>
<li>所有字段都是固定长度 varchar(10) = char(10)</li>
<li>不支持 Blog 和 Text 等大字段</li>
<li>Memory 存储引擎只能使用<strong>表级锁</strong></li>
<li>最大大小由 max_heap_table_size 参数决定</li>
</ol>
<ul>
<li><strong>Memory使用场景</strong></li>
</ul>
<ol>
<li>hash 索引用于查找或者是映射表（邮编和地区的对应表）</li>
<li>用于保存数据分析中产生的中间表</li>
<li>用于缓存周期性聚合数据的结果表</li>
</ol>
<h3 id="Ferderated"><a href="#Ferderated" class="headerlink" title="Ferderated"></a>Ferderated</h3><p>提供了访问远程 MySQL 服务器上表的方法</p>
<ol>
<li>本地不存储数据，数据全部放到远程服务器上</li>
<li>本地需要保存表结构和远程服务器的连接信息</li>
</ol>
<ul>
<li><strong>Ferderated使用场景</strong></li>
</ul>
<p>偶尔的统计分析及手工查询（某些游戏行业）</p>
<h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><span class="label label-primary">索引是帮助MySQL高效获取数据的数据结构。</span>

<p>在关系型数据库中，索引存储在硬盘中。</p>
<p><strong>基本语法：</strong></p>
<p>创建：</p>
<ul>
<li><p>创建索引：<code>CREATE [UNIQUE] INDEX indexName ON mytable(username(length));</code></p>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
</li>
<li><p>修改表结构(添加索引)：<code>ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)</code></p>
</li>
<li><p>删除：<code>DROP INDEX [indexName] ON mytable;</code></p>
</li>
<li><p>查看：<code>SHOW INDEX FROM table_name\G</code>             –可以通过添加 \G 来格式化输出信息。</p>
</li>
</ul>
<p>使用ALERT命令</p>
<ul>
<li><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</code> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list</code> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code> 添加普通索引，索引值可出现多次。</li>
<li><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code>该语句指定了索引为 FULLTEXT ，用于全文索引。</li>
</ul>
<p><strong>优劣势分析</strong></p>
<span class="label label-success">优势</span>

<ul>
<li>提高数据检索效率，降低数据库IO成本</li>
<li>降低数据排序的成本，降低CPU的消耗</li>
</ul>
<span class="label label-danger">劣势</span>

<ul>
<li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</li>
</ul>
<h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><p><strong>索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），<strong>将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置</strong>；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p>
<p>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</p>
<p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p>
<div class="note note-danger">
            <p><strong>面试题——索引：</strong> Innodb为啥不用hash索引</p>
          </div>

<div class="note note-success">
            <p>①hash索引存储在内存中，数据量较多的情况下很明显不合适</p><p>②范围查找不支持。因为hash索引是一种键值查找方式。而b+tree作为多路查找平衡树，是天然有序的，很适合做范围查询。</p><p>③哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>
          </div>

<h4 id="Btree"><a href="#Btree" class="headerlink" title="Btree"></a>Btree</h4><p>在了解btree前，让我们来复习这样一连串的概念，来证明为什么b树是最适合的数据结构。（一些复杂的图解我将开设一个树相关的博客）</p>
<span class="label label-info">**二叉查找树**</span>

<p>随着id递增，会逐渐变成一个单边树，很明显不是一个合适的作为索引的数据结构</p>
<span class="label label-info">**平衡二叉查找树 AVL**</span>

<p>AVL树，本质上是带了平衡功能的二叉查找树。</p>
<p>在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为<strong>高度平衡树</strong>。增加和删除可能需要通过一次或多次<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%91%E6%97%8B%E8%BD%AC">树旋转</a>来重新平衡这个树。</p>
<p>问题是AVL的大量的自平衡导致IO次数过多，形成IO浪费，很明显也不是一个合适的方案</p>
<span class="label label-info">**B树**</span> 

<p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树</p>
<ul>
<li><strong>规则</strong></li>
</ul>
<span class="label label-info">关键字的个数n满足：ceil(m/2)-1 <= n <= m-1</span>

<span class="label label-info">非叶节点的子节点数>1，且<=M</span>

<span class="label label-info">节点位于同一水平线</span>

<p><img src="/img/btree1.png" srcset="/img/loading.gif"></p>
<ul>
<li><strong>特点</strong></li>
</ul>
<p>B树的优势在于每个节点包含的关键字增多了，充分利用了磁盘块的原理，减少数据查找的次数。</p>
<span class="label label-primary">磁盘块原理：系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来</span>

<p>InnoDB 存储引擎使用页（Page）作为存储单位，页是磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></p>
<p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。</p>
<h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B+tree"></a>B+tree</h4><p>B树每个节点中不仅包含数据的key值，还有data值。data变大 -&gt; 每页能存储的key的数量变小 -&gt; B-Tree的深度较大，增大查询时的磁盘I/O次数</p>
<span class="label label-danger">最最消耗时间的操作就是磁盘IO：从磁盘读到内存</span>

<p>因此B+树舍弃了非叶子结点的data数据，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定。</p>
<ul>
<li><strong>规则</strong></li>
</ul>
<p>（1）B+跟B树不同的是，B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p>
<p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p>
<p>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p>
<p>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p>
<p><img src="/img/b+tree1.png" srcset="/img/loading.gif"></p>
<div class="note note-danger">
            <p><strong>面试题——Btree：</strong>B+tree和Btree的不同点</p>
          </div>

<div class="note note-success">
            <p>①B+tree数据只存储在叶子节点上，非叶子节点只保存索引信息</p><p>②叶子节点本身按照数据的升序排序进行链接</p>
          </div>

<ul>
<li><strong>特点</strong></li>
</ul>
<p>1、B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p>
<p>2、B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;符合日常业务场景</p>
<p>3、B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p>
<p>4、B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p>
<p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p>
<h4 id="B-Tree落地mysql"><a href="#B-Tree落地mysql" class="headerlink" title="B+Tree落地mysql"></a>B+Tree落地mysql</h4><p><strong>Myisam</strong></p>
<ul>
<li><strong>物理存储</strong></li>
</ul>
<p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”<strong>非聚簇索引</strong>“。</p>
<ul>
<li><strong>索引流程</strong></li>
</ul>
<p>先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p>
<p><img src="/img/myasim_suoyin.png" srcset="/img/loading.gif"></p>
<p><strong>InnoDB</strong></p>
<ul>
<li><strong>物理存储</strong></li>
</ul>
<p>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录。<span class="label label-primary">主键索引存放表中所有的数据记录</span><span class="label label-info">辅助索引存放主键，检索的时候通过主键到主键索引中找到对应数据行</span></p>
<p>InnoDB的数据文件本身就是主键索引文件，这样的索引被称为”“聚簇索引”，一个表只能有一个聚簇索引。</p>
<ul>
<li><strong>索引流程</strong></li>
</ul>
<p><strong>主键索引</strong></p>
<p>数据的物理顺序与主键顺序一致； 叶子结点存放所有数据；  非叶子结点存放主键值</p>
<p>命中主键即取到数据</p>
<p><img src="/img/innodb_suoyin.jpg" srcset="/img/loading.gif"></p>
<p><strong>二级索引</strong></p>
<p>叶子结点存放主键值；非叶子结点存放二级索引值</p>
<p>命中二级索引值 –&gt; 取得主键 –&gt; 命中主键索引对应项 –&gt; 取得数据</p>
<p>这也就是所谓的“<strong>回表查询</strong>”</p>
<p><img src="/img/innodb_suoyin2.png" srcset="/img/loading.gif"></p>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a><strong>从物理存储角度</strong></h4><ul>
<li>聚集索引（clustered index）</li>
<li>非聚集索引（non-clustered index），也叫辅助索引（secondary index</li>
</ul>
<p><strong>聚簇索引</strong></p>
<p>聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。</p>
<p>一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。</p>
<p>在InnoDB引擎中，<strong>只有主键是聚集索引</strong>，其他的索引都是非聚集索引。</p>
<div class="note note-danger">
            <p><strong>面试题——InnoDB聚簇索引：</strong></p><p>InnoDB 没有主键咋办？</p>
          </div>

<div class="note note-success">
            <p><strong>回答：</strong>如果表中没有主键或者一个合适的的唯一索引，InnoDB内部会以一个包含行ID值的合成列生成一个隐藏的聚簇索引。表中的行是按照InnoDB分配的ID排序的。行ID是一个6字节的字段，随着一个新行的插入单调增加。因此，行ID顺序物理上是插入顺序。</p><p>所有用ROW_ID列的表，共享同一个被保存在数据字典中的全局序列数。这就会导致竞争从而引起性能问题。</p>
          </div>

<div class="note note-danger">
            <p><strong>面试题——InnoDB聚簇索引</strong>：</p><p>InnoDB为什么推荐使用自增ID而不是UUID作为主键？</p>
          </div>

<div class="note note-success">
            <p><strong>回答：</strong></p><p>①UUID是字符串，比整型消耗更多的存储空间</p><p>②整型数据的比较运算比字符串更快速</p><p>③自增的整型索引在磁盘中会连续存储，查找关联性数据时更方便</p><p>④在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p><p>如何去理解这句话呢：</p><p>  InnoDB引擎使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放。因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>​    1、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</p><p>​    这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>​    2、 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
          </div>



<h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h4><ul>
<li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li>
<li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li>
<li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li>
<li>唯一索引或者非唯一索引</li>
<li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。 MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</li>
</ul>
<h3 id="索引的使用及三星索引"><a href="#索引的使用及三星索引" class="headerlink" title="索引的使用及三星索引"></a>索引的使用及三星索引</h3><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。</p>
<p>• 在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p>
<p>• 在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p>
<p>• 索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p>
<p>主要目的就是<span class="label label-primary">减少IO次数</span></p>
<p>适用条件</p>
<p>​     ①需要整表扫描的情况。比如：range, ref, eq_ref, ref_or_null 。适用于InnoDB 引擎和 MyISAM 引擎的查询。（5.6版本不适用分区表查询，5.7版本后可以用于分区表查询）。</p>
<p>​     ②对于InnDB引擎只适用于二级索引，因为InnDB的聚簇索引会将整行数据读到InnDB的缓冲区，这样一来索引条件下推的主要目的减少IO次数就失去了意义。因为数据已经在内存中了，不再需要去读取了。</p>
<p>​     ③引用子查询的条件不能下推。</p>
<p>调用存储过程的条件不能下推，存储引擎无法调用位于MySQL服务器中的存储过程。</p>
<h3 id="MRR-顺序磁盘读"><a href="#MRR-顺序磁盘读" class="headerlink" title="MRR (顺序磁盘读)"></a>MRR (顺序磁盘读)</h3><p>MRR，全称「Multi-Range Read Optimization」。</p>
<p>简单说：MRR 通过把「随机磁盘读」，转化为「顺序磁盘读」，从而提高了索引查询的性能。</p>
<p>对于 Myisam，在去磁盘获取完整数据之前，会先按照rowId排好序，再去顺序的读取磁盘。</p>
<p>对于 Innodb，则会按照聚簇索引键值排好序，再顺序的读取聚簇索引。</p>
<p>顺序读带来了几个好处：</p>
<p>1、磁盘和磁头不再需要来回做机械运动；</p>
<p>2、可以充分利用磁盘预读（局部性原理）</p>
<p>3、在一次查询中，每一页的数据只会从磁盘读取一次</p>
<p>索引本身就是为了减少磁盘 IO，加快查询，而MRR，则是把索引减少磁盘 IO 的作用，进一步放大。</p>
<p>MRR在本质上是一种用空间换时间的算法。MySQL 不可能给你无限的内存来进行排序</p>
<h2 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul>
<li>原子性</li>
</ul>
<p>一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败</p>
<ul>
<li>一致性</li>
</ul>
<p>将数据库从一种一致性转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏</p>
<ul>
<li>隔离性</li>
</ul>
<p>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<ul>
<li>持久性</li>
</ul>
<p>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失</p>
<h3 id="三类事务问题"><a href="#三类事务问题" class="headerlink" title="三类事务问题"></a>三类事务问题</h3><ul>
<li><strong>脏读</strong></li>
</ul>
<p>A事务中的读操作可能读到另一个事务中未提交修改的数据，如果事务发生回滚就可能造成错误。</p>
<p><em>dirty read</em></p>
<p><em>An operation that retrieves unreliable data, data that was updated by another transaction but not yet committed. It is only possible with the isolation level known as read uncommitted.</em></p>
<p><em>This kind of operation does not adhere to the ACID principle of database design. It is considered very risky, because the data could be rolled back, or updated further before being committed; then, the transaction doing the dirty read would be using data that was never confirmed as accurate.</em></p>
<p><em>Its opposite is consistent read, where InnoDB ensures that a transaction does not read information updated by another transaction, even if the other transaction commits in the meantime.</em></p>
<ul>
<li><strong>不可重复读</strong></li>
</ul>
<p>事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。</p>
<p><em>non-repeatable read</em></p>
<p><em>The situation when a query retrieves data, and a later query within the same transaction retrieves what should be the same data, but the queries return different results (changed by another transaction committing in the meantime).</em></p>
<p><em>This kind of operation goes against the ACID principle of database design. Within a transaction, data should be consistent, with predictable and stable relationships.</em></p>
<p><em>Among different isolation levels, non-repeatable reads are prevented by the serializable read and repeatable read levels, and allowed by the consistent read, and read uncommitted levels.</em></p>
<ul>
<li><strong>幻读</strong></li>
</ul>
<p>如果一个查询在一个事务中运行两次，与此同时，另一个事务将在插入新行后提交 或更新一行，使其与查询的WHERE子句匹配。这种情况被称为幻像读取，比不可重复读取更难防范，因为锁定第一个查询结果集中的所有行并不能阻止导致幻像出现的更改。</p>
<p><em>phantom</em></p>
<p><em>A row that appears in the result set of a query, but not in the result set of an earlier query. For example, if a query is run twice within a transaction, and in the meantime, another transaction commits after inserting a new row or updating a row so that it matches the WHERE clause of the query.</em></p>
<p><em>This occurrence is known as a phantom read. It is harder to guard against than a non-repeatable read, because locking all the rows from the first query result set does not prevent the changes that cause the phantom to appear.</em></p>
<p><em>Among different isolation levels, phantom reads are prevented by the serializable read level, and allowed by the repeatable read, consistent read, and read uncommitted levels.</em></p>
<div class="note note-primary">
            <p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。</p><p>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
          </div>

<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><img src="/img/mysqlgelijibie.png" srcset="/img/loading.gif"></p>
<div class="note note-primary">
            <p>但是mysql在RR上通过间隙锁解决了幻读问题</p>
          </div>

<div class="note note-danger">
            <p><strong>面试题——事务隔离级别</strong>：那么Mysql通过什么完成了RR事务隔离级别，解决了脏读、不可重复读、幻读这些问题的呢？</p>
          </div>

<div class="note note-success">
            <p><strong>回答</strong>：MVCC + LBCC</p>
          </div>



<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。</p>
<p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p>
<p>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p>
<ul>
<li>快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)</li>
<li>当前读：特殊的读操作(加读锁)，插入/更新/删除操作，属于当前读，需要加锁。<br>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</li>
<li></li>
</ul>
<h2 id="六、锁"><a href="#六、锁" class="headerlink" title="六、锁"></a>六、锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p>根据粒度分： 行锁 表锁 页锁</p>
<h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h3><ul>
<li><strong>共享读锁</strong> </li>
</ul>
<pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">read</span></code></pre>

<p>同一会话：写操作报错，<span class="label label-warning">其他表的读写操作也都会报错</span>，使用<span class="label label-primary">别名</span>的读操作也会报错</p>
<p>新开会话：不堵塞读操作，堵塞写操作，其他表的读写操作都能正常进行</p>
<ul>
<li><strong>独占写锁</strong></li>
</ul>
<pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">read</span></code></pre>

<p>同一会话：读写均OK，<span class="label label-warning">其他表的读写操作也都会报错</span></p>
<p>新开会话：堵塞读写</p>
<h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><p>InnoDB支持行锁，行锁不是字面意义上的锁住一行数据，<span class="label label-primary">行锁是通过给索引上的索引项加锁来实现的。</span>只有通过索引条件检索数据，InnoDB才使用行级锁。</p>
<p>同时<span class="label label-warning">两个事务不能锁同一个索引。</span></p>
<p>而当<span class="label label-danger">索引失效</span>时，行锁就变为了表锁。这里的表锁也不是字面意义的表锁，而是锁住了所有索引项，其效果等同于表锁罢了。</p>
<div class="note note-secondary">
            <p>曾经有一次实验就出现了这样的问题：</p><p>因为where条件里对int的索引项强制类型转换成了string，导致了索引失效，因此行锁升级成了表锁，导致其他数据也无法进行更新。找了好久问题所在。</p>
          </div>

<ul>
<li><strong>共享锁（S）</strong></li>
</ul>
<pre><code class="hljs sql">语法：<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表 <span class="hljs-keyword">where</span> 条件 <span class="hljs-keyword">lock</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">share</span> <span class="hljs-keyword">mode</span></code></pre>

<p>又名读锁，对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后才能进行。</p>
<ul>
<li><strong>排他锁（X）</strong></li>
</ul>
<pre><code class="hljs n1ql">语法：for <span class="hljs-keyword">update</span></code></pre>

<p>insert ，delete ， update在事务中都会<span class="label label-primary">自动默认加上排它锁</span></p>
<ul>
<li><strong>意向锁</strong></li>
</ul>
<p>InnoDB 支持<strong>多粒度锁</strong>（multiple granularity locking），它允许行级锁与表级锁共存</p>
<p>为实现表锁和行锁共存，引入了<strong>意向锁</strong></p>
<p>意向锁是由数据引擎自己维护的。对于同一张表，不同行的IX可以共存。意向锁之间是互相兼容的。</p>
<p>注意：这里的排他 / 共享锁指的都是表锁！！！意向锁不会与行级的共享 / 排他锁互斥！！</p>
<p><img src="https://img-blog.csdnimg.cn/20200930151134503.png" srcset="/img/loading.gif" alt="img"></p>
<h4 id="InnoDB-的三种锁算法"><a href="#InnoDB-的三种锁算法" class="headerlink" title="InnoDB 的三种锁算法"></a>InnoDB 的三种锁算法</h4><ul>
<li><p><strong>记录锁</strong></p>
<p>用于等值查询，锁住单个索引项。其他事务不能修改和删除加锁项。</p>
</li>
</ul>
<ul>
<li><strong>间隙锁</strong></li>
</ul>
<p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p>
<p>对索引项之间的“间隙”加锁，锁定记录的范围（前一个间隙 +后一个间隙），不包含索引项本身。其他事务不能在锁范围内插入数据。因此，<strong>间隙锁解决了幻读问题</strong></p>
<span class="label label-warning">需要强调的是，间隙锁锁的不是索引项，而是索引项之间的间隙</span>

<span class="label label-warning">需要注意的是，间隙锁锁住的**区间**视数据而定，而非语句筛选条件而定。</span>



<ul>
<li><strong>临键锁</strong></li>
</ul>
<p><strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。</p>
<p>每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，<code>InnoDB</code> 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p>
<p>接下来将详细描述<strong>各种情况</strong>的<strong>加锁流程</strong>。以便更好的理解以上的锁知识。</p>
<h3 id="加锁详细分析"><a href="#加锁详细分析" class="headerlink" title="加锁详细分析"></a>加锁详细分析</h3><p>了解加锁规则</p>
<ol>
<li>加锁的基本单位是（next-key lock）,他是前开后闭原则</li>
<li>查询过程中所有访问的对象会加锁</li>
<li>索引上的等值查询–给唯一索引加锁的时候，next-key lock升级为行锁</li>
<li>索引上的等值查询–向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁</li>
<li>唯一索引上的范围查询会访问到不满足条件的第一个值为止</li>
</ol>
<p>以下分析均基于<strong>RR隔离级别</strong></p>
<ul>
<li><strong>情况一：id为主键  + select</strong></li>
</ul>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">10</span>;</code></pre>

<p>快照读，不加锁</p>
<ul>
<li><strong>情况二：id为主键  + delete/update + 等值查询</strong> </li>
</ul>
<pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">10</span>;</code></pre>

<p><img src="/img/jiasuo1.jpg" srcset="/img/loading.gif"></p>
<p>对索引项10加上排它锁</p>
<ul>
<li><strong>情况三：id为唯一索引  + delete/update + 等值查询</strong></li>
</ul>
<p><img src="/img/jiasuo2.jpg" srcset="/img/loading.gif"></p>
<p>此组合中，id是unique索引，而主键是name列。在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。</p>
<ul>
<li><strong>情况四：id为非唯一索引  + delete/update + 等值查询</strong></li>
</ul>
<p>准备以下数据：</p>
<p><img src="/img/jiasuo4.png" srcset="/img/loading.gif"></p>
<p>其对应的索引结构展示如下</p>
<p><img src="/img/jiasuo5.png" srcset="/img/loading.gif"></p>
<p>执行以下事务</p>
<pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>；
<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> z <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">6</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;</code></pre>

<span class="label label-warning">思考：由于是非唯一索引，那么如果在中途加入很多b=6的数据，不就出现幻读了吗？</span>

<p>所以，非唯一索引往往需要用到临键锁/间隙锁来解决幻读问题。</p>
<p>在索引 b 上的等值查询，给索引 b 加上了 next-key lock (4, 6]；一直向右遍历直至遇到第一个不满足条件的值，加入间隙锁(6,8)。自此，锁范围确定。</p>
<p>同时一个X锁会被加到所有满足b=6的索引项以及其对应的主键索引上，同情况3所示。<span class="label label-warning">而索引项4和8是没有被加X锁的。</span></p>
<div class="note note-info">
            <p>为什么4和8明明进行了判断却没有被加X锁？</p><p>对等值匹配的条件有特殊处理，他们规定在InnoDB存储引擎层查找到当前记录的下一条记录时，在对其加锁前就直接判断该记录是否满足等值匹配的条件，如果不满足直接返回（也就是不加锁了），否则的话需要将其加锁后再返回给server层。所以这里也就不需要对下一条二级索引记录进行加锁了。</p>
          </div>

<p><img src="/img/jiasuo6.png" srcset="/img/loading.gif"></p>
<p>执行事务</p>
<pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_lock <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>);</code></pre>

<p>新增(b=7,id=7)的索引，新增部分根据索引有序的规则，将会落在锁住的部分区间，所以会被阻塞。</p>
<p><img src="/img/jiasuo7.png" srcset="/img/loading.gif"></p>
<p>执行事务</p>
<pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> test_lock <span class="hljs-keyword">SET</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">6</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">8</span>;</code></pre>

<p>会将b索引上（b=8,id=8）叶子节点删掉，并增加(b=8,id=6)的叶子节点。可以看到(b=8,id=6)的叶子节点也落入锁住的部分区间，所以会被阻塞住。</p>
<p><img src="/img/jiasuo8.png" srcset="/img/loading.gif"></p>
<p>同理。</p>
<span class="label label-danger">insert into test_lock values (4, 4); 阻塞</span>

<span class="label label-success">insert into test_lock values (2, 4); 成功</span>

<span class="label label-danger">UPDATE test_lock SET b = 6 WHERE id = 1; 阻塞</span>



<ul>
<li><strong>情况五：id为主键  + delete/update + 范围查询</strong></li>
</ul>
<p>id数据：10 11 13 20 40</p>
<p><strong>①执行以下事务。</strong></p>
<pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &lt;= <span class="hljs-number">13</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre>

<span class="label label-danger">insert into test_lock2 values(12); 阻塞</span>

<span class="label label-danger">insert into test_lock2 values(13); 阻塞</span>

<span class="label label-success">insert into test_lock2 values(19); 成功</span>

<span class="label label-success">insert into test_lock2 values(21); 成功</span>

<p>关于第三条id为19的记录，<span class="label label-warning">在mysql5.6版本上似乎是阻塞。</span></p>
<p>网上的给的解释是在判断20是否满足&lt;=13这个条件时为加上锁，如果不满足，则会解锁。因此事务2进行时(13，20)实际上没有锁的。</p>
<div class="note note-info">
            <p>聚簇索引不需要到server层再进行条件过滤。</p><p>每从聚簇索引中取出一条记录时都要判断一下该记录是否符合范围查询的边界条件，也就是number &lt;= 8这个条件。如果符合的话将其返回给server层继续处理，否则的话需要<strong>释放掉在该记录上加的锁</strong></p>
          </div>

<p><strong>②执行以下事务</strong></p>
<pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&lt;<span class="hljs-number">13</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre>

<p>锁住(-,13)的区间</p>
<p><strong>③执行以下事务</strong></p>
<pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;
<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre>

<p>锁住(40，+)的区间</p>
<span class="label label-primary">**聚簇索引的锁区间和范围保持一致**</span>



<ul>
<li><strong>情况六：a为唯一索引  + delete/update + 范围查询</strong></li>
</ul>
<p>id数据：             10 11 13 20 40</p>
<p>唯一索引a数据：1   3   5   7   9</p>
<p><strong>①执行以下事务</strong></p>
<pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre>

<p>锁住（-，5]区间。</p>
<p><strong>②执行以下事务</strong></p>
<pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;=<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre>

<p>锁住（-，7]区间。</p>
<div class="note note-info">
            <p>这里就发现和主键索引不同的地方了。二级索引可以利用索引下推直接在引擎层判断，如果一条记录不符合索引条件下推中的条件的话，直接跳到下一条记录（这个过程根本不将其返回到server层），如果这已经是最后一条记录，那么直接向server层报告查询完毕。但是这里头有个问题：先对一条记录加了锁，然后再判断该记录是不是符合索引条件下推的条件，如果不符合直接跳到下一条记录或者直接向server层报告查询完毕，这个过程中并没有把那条被加锁的记录上的锁释放掉呀！！！</p>
          </div>



<ul>
<li><strong>情况七：a为非唯一索引  + delete/update + 范围查询</strong></li>
</ul>
<p><strong>①执行以下事务</strong></p>
<pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre>

<p>锁住（-，5]区间。</p>
<p><strong>②执行以下事务</strong></p>
<pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;=<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre>

<p>锁住（-，7)区间。</p>
<h3 id="锁的等待问题"><a href="#锁的等待问题" class="headerlink" title="锁的等待问题"></a>锁的等待问题</h3><p>通过以下命令查看表的锁情况</p>
<pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> information_schema.INNODB_LOCKS;</code></pre>

<p>通过以下命令查看处于堵塞状态的线程，并通过kill_blocking字段kill掉阻塞源</p>
<pre><code class="hljs csharp"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> sys.innodb_lock_waits</code></pre>



<p>以下代码在5.6版本运行</p>
<pre><code class="hljs mipsasm">SELECT
r.trx_id <span class="hljs-keyword">waiting_trx_id,</span>
<span class="hljs-keyword">r.trx_mysql_thread_id </span><span class="hljs-keyword">waiting_thread,</span>
<span class="hljs-keyword">r.trx_query </span><span class="hljs-keyword">waiting_query,</span>
<span class="hljs-keyword">b.trx_id </span><span class="hljs-keyword">blocking_trx_id,</span>
<span class="hljs-keyword">b.trx_mysql_thread_id </span><span class="hljs-keyword">blocking_thread</span>
<span class="hljs-keyword">FROM</span>
<span class="hljs-keyword">information_schema.innodb_lock_waits </span>w
INNER <span class="hljs-keyword">JOIN</span>
<span class="hljs-keyword">information_schema.innodb_trx </span><span class="hljs-keyword">b </span>ON <span class="hljs-keyword">b.trx_id </span>= w.<span class="hljs-keyword">blocking_trx_id</span>
<span class="hljs-keyword">INNER </span><span class="hljs-keyword">JOIN</span>
<span class="hljs-keyword">information_schema.innodb_trx </span>r ON r.trx_id = w.requesting_trx_id;</code></pre>



<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="七、业务设计"><a href="#七、业务设计" class="headerlink" title="七、业务设计"></a>七、业务设计</h2><h2 id="八、记录一些其他知识点"><a href="#八、记录一些其他知识点" class="headerlink" title="八、记录一些其他知识点"></a>八、记录一些其他知识点</h2><h3 id="简单讲讲oracle和mysql"><a href="#简单讲讲oracle和mysql" class="headerlink" title="简单讲讲oracle和mysql"></a>简单讲讲oracle和mysql</h3><p><strong>①并发性</strong></p>
<p>Mysql以表级锁为主。InnoDB引擎的表可以用行级锁，其依赖于表的索引。oracle使用行级锁，对资源锁定的粒度要小很多</p>
<p><strong>②一致性</strong></p>
<p>oracle支持serializable的隔离级别，可以实现最高级别的读一致性。mysql支持到RC隔离级别</p>
<p><strong>③事务</strong></p>
<p>Oracle支持事务，mysql的innodb支持事务</p>
<p><strong>④持久性</strong></p>
<p>oracle：保证提交的数据均可恢复，因为oracle把提交的sql操作线写入了在线联机日志文件中，保持到了磁盘上，如果出现数据库或主机异常重启，重启后oracle可以考联机在线日志恢复客户提交的数据。</p>
<p>mysql：默认提交sql语句，但如果更新过程中出现db或主机重启的问题，也许会丢失数据。</p>
<p><strong>⑤逻辑备份</strong></p>
<p> oracle逻辑备份时不锁定数据，且备份的数据是一致的。</p>
<p>  mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的</p>
<p><strong>⑥热备份</strong></p>
<p>oracle有成熟的热备工具rman，热备时，不影响用户使用数据库。即使备份的数据库不一致，也可以在恢复时通过归档日志和联机重做日志进行一致的回复。</p>
<p>mysql：myisam的引擎，用mysql自带的mysqlhostcopy热备时，需要给表加读锁，影响dml操作。innodb的引擎，它会备份innodb的表和索引，但是不会备份.frm文件。用ibbackup备份时，会有一个日志文件记录备份期间的数据变化，因此可以不用锁表，不影响其他用户使用数据库。但此工具是收费的。innobackup是结合ibbackup使用的一个脚本，他会协助对.frm文件的备份。</p>
<p><strong>⑦sql语句的扩展和灵活性</strong></p>
<p>mysql对sql语句有很多非常实用而方便的扩展，比如limit功能，insert可以一次插入多行数据，select某些管理数据可以不加from。</p>
<p>  oracle在这方面感觉更加稳重传统一些。</p>
<p><strong>⑧复制</strong></p>
<p>oracle：既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。</p>
<p> mysql：复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。</p>
<p><strong>⑨性能诊断</strong></p>
<p>  oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等</p>
<p>  mysql的诊断调优方法较少，主要有慢查询日志。</p>
<p><strong>⑩权限与安全</strong></p>
<p>  mysql的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。</p>
<p>  oracle的权限与安全概念比较传统，中规中矩。</p>
<p><strong>⑪分区表和分区索引</strong></p>
<p>  oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。</p>
<p>  mysql的分区表还不太成熟稳定。</p>
<h3 id="MySQL各版本更新记录"><a href="#MySQL各版本更新记录" class="headerlink" title="MySQL各版本更新记录"></a>MySQL各版本更新记录</h3><p>5.5   默认存储引擎更改为innodb</p>
<p>5.6   加入索引下推</p>
<p>5.7   加入json数据类型</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>关系型数据库与非关系型数据库 <a target="_blank" rel="noopener" href="https://blog.csdn.net/oChangWen/article/details/53423301">https://blog.csdn.net/oChangWen/article/details/53423301</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>InnoDB 和MyISAM的区别 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35642036/article/details/82820178">https://blog.csdn.net/qq_35642036/article/details/82820178</a>
<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>意向锁 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903666332368909">https://juejin.im/post/6844903666332368909</a>
<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>索引下推 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Chenjiabing/p/12600926.html">https://www.cnblogs.com/Chenjiabing/p/12600926.html</a>
<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>MRR <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110154066">https://zhuanlan.zhihu.com/p/110154066</a>
<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>不错的整理贴 <a target="_blank" rel="noopener" href="https://juejin.im/post/6850037271233331208#heading-50">https://juejin.im/post/6850037271233331208#heading-50</a>
<a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>加锁流程分析 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144471126">https://zhuanlan.zhihu.com/p/144471126</a>
<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>间隙锁 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/42e60848b3a6">https://www.jianshu.com/p/42e60848b3a6</a>
<a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span>比较全面的加锁流程分析 <a target="_blank" rel="noopener" href="https://blog.csdn.net/bjweimengshu/article/details/90056126">https://blog.csdn.net/bjweimengshu/article/details/90056126</a>
<style>
  /* 只设置  note字体 */
  .note {
    font-family: "Microsoft YaHei",Georgia, sans, serif, KaiTi,;
    font-size: 14px;
  }
</style><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/01/MyBatis/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">mybatis</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/02/hello-world/">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "mysql&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>



<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="java">
  <meta name="author" content="吴天野">
  <meta name="keywords" content="">
  <title>mysql - 吴天野的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>吴天野的博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      吴天野
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-06 20:30" pubdate>
        2020年10月6日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      88
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">mysql</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="MySQL那些事儿"><a href="#MySQL那些事儿" class="headerlink" title="MySQL那些事儿"></a>MySQL那些事儿</h1><h2 id="前言：关系型数据库与非关系型数据库"><a href="#前言：关系型数据库与非关系型数据库" class="headerlink" title="前言：关系型数据库与非关系型数据库"></a>前言：关系型数据库与非关系型数据库</h2><p>关系型： mysql oracle</p>
<p>非关系型： Redis mongodb</p>
<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>是指采用了关系模型来组织数据的数据库。</p>
<h4 id="关系型数据库的优点："><a href="#关系型数据库的优点：" class="headerlink" title="关系型数据库的优点："></a>关系型数据库的优点：</h4><p>  容易理解：二维表结构是非常贴近逻辑世界的一个概念</p>
<p>  使用方便：通用的SQL语言使得操作关系型数据库非常方便</p>
<p>  易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率</p>
<h4 id="关系型数据库特性"><a href="#关系型数据库特性" class="headerlink" title="关系型数据库特性"></a>关系型数据库特性</h4><p>(1). 事务一致性: 关系型数据库在对事物一致性的维护中有很大的开销，而现在很多web2.0系统对事物的读写一致性都不高<br>(2). 读写实时性: 对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比如发一条消息之后，过几秒乃至十几秒之后才看到这条动态是完全可以接受的<br>(3). 复杂SQL，特别是多表关联查询: 任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询，特别是SNS类型的网站（SNS，专指社交网络服务，包括了社交软件和社交网站。），从需求以及产品阶级角度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能极大的弱化了 </p>
<p>   在关系型数据库中，导致性能欠佳的最主要原因是多表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询。为了保证数据库的ACID特性，我们必须尽量按照其要求的范式进行设计，关系型数据库中的表都是存储一个格式化的数据结构。每个元组字段的组成都是一样，即使不是每个元组都需要所有的字段，但数据库会为每个元组分配所有的字段，这样的结构可以便于标语表之间进行链接等操作，但从另一个角度来说它也是关系型数据库性能瓶颈的一个因素。</p>
<h4 id="关系型数据库瓶颈"><a href="#关系型数据库瓶颈" class="headerlink" title="关系型数据库瓶颈"></a>关系型数据库瓶颈</h4><p> (1). 高并发读写需求<br>  网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘I/O是一个很大的瓶颈<br> (2). 海量数据的高效率读写<br>  网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的<br> (3). 缺少高扩展性和可用性</p>
<h3 id="非关系型数据库（NoSQL）"><a href="#非关系型数据库（NoSQL）" class="headerlink" title="非关系型数据库（NoSQL）"></a>非关系型数据库（NoSQL）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>非关系型数据库提出另一种理念，例如，以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，用户可以根据需要去添加自己需要的字段，这样，为了获取用户的不同信息，不需要像关系型数据库中，要对多表进行关联查询。仅需要根据id取出相应的value就可以完成查询。但非关系型数据库由于很少的约束，他也不能够提供像SQL所提供的where这种对于字段属性值情况的查询。并且难以体现设计的完整性。他只适合存储一些较为简单的数据，对于需要进行较复杂查询的数据，SQL数据库显的更为合适。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>①面向高性能并发读写的key-value数据库：key-value数据库的主要特点即使具有极高的并发读写性能，Redis,Tokyo Cabinet,Flare就是这类的代表</p>
<p>②面向文档数据库：这类数据库的特点是，可以在海量的数据中快速的查询数据，典型代表为MongoDB以及CouchDB</p>
<p>③展性的分布式数据库：这类数据库想解决的问题就是传统数据库存在可扩展性上的缺陷，这类数据库可以适应数据量的增加以及数据结构的变化</p>
<h3 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h3><table>
<thead>
<tr>
<th></th>
<th><strong>关系型</strong></th>
<th><strong>非关系型</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储方式</strong></td>
<td>表格</td>
<td>动态结构（key-value 、文档）</td>
</tr>
<tr>
<td><strong>存储规范</strong></td>
<td>关系模型 无重复 清晰</td>
<td>数据集 有重复 读写方便</td>
</tr>
<tr>
<td><strong>扩展方式</strong></td>
<td>很难</td>
<td>增加服务器</td>
</tr>
<tr>
<td><strong>查询方式</strong></td>
<td>SQL</td>
<td>UNQL</td>
</tr>
<tr>
<td><strong>事务性</strong></td>
<td>ACID</td>
<td>BASE</td>
</tr>
<tr>
<td><strong>读写性能</strong></td>
<td>强调数据一致性，读写差</td>
<td>读写快</td>
</tr>
</tbody></table>
<p>  关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点，这个特性使得关系型数据库可以用于几乎所有对一致性有要求的系统中，如典型的银行系统。但是，在网页应用中，尤其是SNS应用中，一致性却不是显得那么重要，像微博、facebook这类SNS的应用，对并发读写能力要求极高，关系型数据库已经无法应付。因此，必须用新的一种数据结构存储来代替关系数据库。</p>
<p>  关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性极差，而在SNS中，系统的升级，功能的增加，往往意味着数据结构巨大变动，这一点关系型数据库也难以应付，需要新的结构化数据存储。</p>
<p>  于是，非关系型数据库应运而生，由于不可能用一种数据结构化存储应付所有的新的需求，因此，非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。</p>
<p>  必须强调的是，数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库这员老将。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>关系型数据库特点在于其存储方式清晰严谨，无冗余，具有数据一致性。但不易拓展，并发性差</p>
<p>非关系型数据库更适合处理高并发和海量数据读写，并且更易拓展。</p>
<h2 id="正式进入MySQL"><a href="#正式进入MySQL" class="headerlink" title="正式进入MySQL"></a>正式进入MySQL</h2><h3 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h3><h4 id="INT类型"><a href="#INT类型" class="headerlink" title="INT类型"></a>INT类型</h4><table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th></th>
<th><strong>字节</strong></th>
<th><strong>最小值</strong></th>
<th><strong>最大值</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td><strong>（带符号的/无符号的）</strong></td>
<td><strong>(带符号的/无符号的)</strong></td>
</tr>
<tr>
<td>TINYINT</td>
<td></td>
<td>1</td>
<td>-128    2^7</td>
<td>127</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td></td>
<td>2</td>
<td>-32768    2^15</td>
<td>32767</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td></td>
<td>3</td>
<td>-8388608   2^23</td>
<td>8388607</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>16777215</td>
</tr>
<tr>
<td>INT</td>
<td></td>
<td>4</td>
<td>-2147483648    2^31</td>
<td>2147483647</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td></td>
<td>8</td>
<td>-9223372036854775808</td>
<td>9223372036854775807</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>18446744073709551615</td>
</tr>
</tbody></table>
<div class="note note-warning">
            <p>unsigned 无符号最小值是0.  在用select a-b类似语句时，若目标字段为无符号，计算值为负则会报错</p>
          </div>

<div class="note note-warning">
            <p>int(N)不代表长度上限。而是代表显示宽度。使用zerofill 代表小于N时用0填充左边，超过N则原样显示</p>
          </div>

<h5 id="int的常用场景：自增长"><a href="#int的常用场景：自增长" class="headerlink" title="int的常用场景：自增长"></a>int的常用场景：自增长</h5><p>MySQL 每张表只能有1个自增长字段，其可以作为主键，也可以不作为主键。<span class="label label-primary">非主键情况下必须显示添加唯一索引</span></p>
<span class="label label-success">自增字段：插入null或0结果是自己自增，负数也是可以插进去的。</span>

<div class="note note-danger">
            <p><strong>面试题——自增长：</strong> </p><p>17之后删除15 16 17。再次插入数据，id是几？</p>
          </div>

<div class="note note-success">
            <p>回答：</p><p>mysql8.0之前  myisam：18    innodb(重启)：15     innodb(未重启)：18</p><p>mysql8.0之后   myisam：18   innodb：18</p>
          </div>



<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>N的含义</th>
<th>是否有字符集</th>
<th>最大长度</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(N)</td>
<td>定长字符</td>
<td><strong>字符</strong></td>
<td>是</td>
<td>255</td>
</tr>
<tr>
<td>VARCHAR(N)</td>
<td>变长字符</td>
<td><strong>字符</strong></td>
<td>是</td>
<td>16384</td>
</tr>
<tr>
<td>BINARY(N)</td>
<td>定长二进制字节</td>
<td>字节</td>
<td>否</td>
<td>255</td>
</tr>
<tr>
<td>VARBINARY(N)</td>
<td>变长二进制字节</td>
<td>字节</td>
<td>否</td>
<td>16384</td>
</tr>
<tr>
<td>TINYBLOB(N)</td>
<td>二进制大对象</td>
<td>字节</td>
<td>否</td>
<td>256</td>
</tr>
<tr>
<td>BLOB(N)</td>
<td>二进制大对象</td>
<td>字节</td>
<td>否</td>
<td>16K</td>
</tr>
<tr>
<td>MEDIUMBLOB(N)</td>
<td>二进制大对象</td>
<td>字节</td>
<td>否</td>
<td>16M</td>
</tr>
<tr>
<td>LONGBLOB(N)</td>
<td>二进制大对象</td>
<td>字节</td>
<td>否</td>
<td>4G</td>
</tr>
<tr>
<td>TINYTEXT(N)</td>
<td>大对象</td>
<td>字节</td>
<td>是</td>
<td>256</td>
</tr>
<tr>
<td>TEXT(N)</td>
<td>大对象</td>
<td>字节</td>
<td>是</td>
<td>16K</td>
</tr>
<tr>
<td>MEDIUMTEXT(N)</td>
<td>大对象</td>
<td>字节</td>
<td>是</td>
<td>16M</td>
</tr>
<tr>
<td>LONGTEXT(N)</td>
<td>大对象</td>
<td>字节</td>
<td>是</td>
<td>4G</td>
</tr>
</tbody></table>
<h5 id="字符类型小tip：排序规则"><a href="#字符类型小tip：排序规则" class="headerlink" title="字符类型小tip：排序规则"></a>字符类型小tip：排序规则</h5><p>我们会看到在创建表的时候，字符集有这样两种：<span class="label label-primary">bin</span>、<span class="label label-default">ci</span></p>
<span class="label label-primary">bin</span>指使用二进制形式，会区分大小写。

<div class="note note-danger">
            <p>面试题——字符集：select ‘a’ = ‘A’ 的执行结果</p>
          </div>

<div class="note note-success">
            <p>回答：</p><p>使用bin时，执行结果为0</p><p>使用ci时，执行结果为1</p>
          </div>



<h4 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h4><table>
<thead>
<tr>
<th>日期类型</th>
<th>占用空间</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01  00:00:00 ~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01  ~ 9999-12-31</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01  00:00:00UTC ~ 2038-01-19 03:14:07UTC</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>YEAR(2):1970-2070,  YEAR(4):1901-2155</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59  ~ 838:59:59</td>
</tr>
</tbody></table>
<p>需要注意的是<span class="label label-primary">DATETIME</span>、<span class="label label-default">TIMESTAMP</span>这两者存在时区上的区分。TIMESTAMP 能通过以下命令查看和设置时区：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">select</span> @@<span class="hljs-keyword">time_zone</span>;
<span class="hljs-keyword">set</span> <span class="hljs-keyword">time_zone</span>=<span class="hljs-string">&#x27;+00:00&#x27;</span>;</code></pre>



<h4 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h4><p>json_extract  抽取</p>
<pre><code class="hljs stylus">select
<span class="hljs-function"><span class="hljs-title">json_extract</span><span class="hljs-params">(data, <span class="hljs-string">&#x27;$.name&#x27;</span>)</span></span>,
<span class="hljs-function"><span class="hljs-title">json_extract</span><span class="hljs-params">(data, <span class="hljs-string">&#x27;$.address&#x27;</span>)</span></span></code></pre>

<p> JSON_OBJECT  将对象转为 json</p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> json_user <span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>,
json_object(&quot;name&quot;, &quot;enjoy&quot;, &quot;email&quot;, &quot;enjoy.com&quot;, &quot;age&quot;,<span class="hljs-number">35</span>) )</code></pre>

<p> json_insert 增加json结构 </p>
<pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-keyword">json</span> = <span class="hljs-string">&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3]&#125;&#x27;</span>;
<span class="hljs-keyword">select</span> json_insert(@<span class="hljs-keyword">json</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;$.c&#x27;</span>, <span class="hljs-string">&#x27;[true, false]&#x27;</span>);
<span class="hljs-keyword">update</span> json_user <span class="hljs-keyword">set</span> <span class="hljs-keyword">data</span> = json_insert(<span class="hljs-keyword">data</span>, <span class="hljs-string">&quot;$.address_2&quot;</span>, <span class="hljs-string">&quot;xiangxue&quot;</span>) <span class="hljs-keyword">where</span> uid = <span class="hljs-number">1</span>;</code></pre>

<p>json_merge 合并json结构</p>
<p>JSON_UNQUOTE  取消引用JSON值，并将结果作为<code>utf8mb4</code>字符串返回</p>
<pre><code class="hljs less"><span class="hljs-selector-tag">select</span> <span class="hljs-selector-tag">JSON_UNQUOTE</span>(json_extract(<span class="hljs-variable">@json</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>));</code></pre>



<h3 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h3><p>MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<span class="label label-primary">插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</span>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<p><img src="/img/mysqljiagoutu.png" srcset="/img/loading.gif"></p>
<h4 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h4><p>最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、身份认证、权限验证的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<h4 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h4><p>第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。</p>
<h5 id="cache-amp-buffer"><a href="#cache-amp-buffer" class="headerlink" title="cache&amp;buffer"></a>cache&amp;buffer</h5><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%query_cache_type%&#x27;</span> <span class="hljs-comment">-- 默认不开启</span>
<span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%query_cache_size%&#x27;</span> <span class="hljs-comment">--默认值 1M</span></code></pre>

<p>业务中并不推荐用cache，所以他也是默认关闭的。原因如下：</p>
<p>①浪费内存</p>
<p>②innodb有buffer提供类似功能</p>
<p>③太严格了！需要查询语句完全一致，包括字符集，那为啥不用redis呢？</p>
<h5 id="Parser解析器"><a href="#Parser解析器" class="headerlink" title="Parser解析器"></a>Parser解析器</h5><p><img src="/img/mysqljiexiqi.png" srcset="/img/loading.gif"></p>
<h5 id="Optimizer优化器"><a href="#Optimizer优化器" class="headerlink" title="Optimizer优化器"></a>Optimizer优化器</h5><pre><code class="hljs csharp"><span class="hljs-keyword">where</span> <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  &gt;&gt;&gt;  不使用<span class="hljs-keyword">where</span>

<span class="hljs-keyword">where</span> 主键 <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>   &gt;&gt;&gt;  impossible key

<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> account t <span class="hljs-keyword">where</span> t.<span class="hljs-function">id <span class="hljs-title">in</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> t2.id <span class="hljs-keyword">from</span> account t2</span>)   子查询   &gt;&gt;&gt;  关联查询</span></code></pre>



<h4 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h4><p>第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</p>
<h4 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h4><p>第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。</p>
<h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>MyISAM 物理文件结构为：</p>
<span class="label label-primary">.frm</span> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等

<span class="label label-danger">.MYD</span> (MYData) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据

<span class="label label-danger">.MYI</span>  (MYIndex)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息

<div class="note note-warning">
            <p>myisam压缩后insert操作失效</p>
          </div>



<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB 物理文件结构为：</p>
<span class="label label-primary">.frm</span> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等

<span class="label label-danger">.ibd</span> 文件或 <span class="label label-danger">.ibdata</span> 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。

<p>独享表空间存储方式使用.ibd文件，并且每个表一个.ibd文件</p>
<p>共享表空间存储方式使用.ibdata文件，所有表共同使用一个.ibdata文件（或多个，可自己配置）</p>
<h4 id="InnoDB-和MyISAM的区别"><a href="#InnoDB-和MyISAM的区别" class="headerlink" title="InnoDB 和MyISAM的区别"></a>InnoDB 和MyISAM的区别</h4><p><strong>索引文件和数据文件是否分开</strong>。（关于两者在索引上的具体实现方式的解析在下面索引知识点详细解读）</p>
<p>①InnoDB 支持事务，MyISAM 不支持事务</p>
<p>②InnoDB 支持外键，而 MyISAM 不支持。</p>
<p>③InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p>
<p>④InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p>
<p>⑤InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。MyISAM并发性不好。</p>
<h4 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h4><ol>
<li>以 csv 格式进行数据存储</li>
<li>所有列都不能为 null 的</li>
<li>不支持索引（不适合大表，不适合在线处理）</li>
<li>可以对数据文件直接编辑（保存文本文件内容</li>
</ol>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>文件系统存储特点，也称 HEAP 存储引擎，所以数据保存在内存中</p>
<ol>
<li>支持 HASH 索引(默认)和 BTree 索引</li>
<li>所有字段都是固定长度 varchar(10) = char(10)</li>
<li>不支持 Blog 和 Text 等大字段</li>
<li>Memory 存储引擎只能使用<strong>表级锁</strong></li>
<li>最大大小由 max_heap_table_size 参数决定</li>
</ol>
<h5 id="Memory使用场景"><a href="#Memory使用场景" class="headerlink" title="Memory使用场景"></a>Memory使用场景</h5><ol>
<li>hash 索引用于查找或者是映射表（邮编和地区的对应表）</li>
<li>用于保存数据分析中产生的中间表</li>
<li>用于缓存周期性聚合数据的结果表</li>
</ol>
<h4 id="Ferderated"><a href="#Ferderated" class="headerlink" title="Ferderated"></a>Ferderated</h4><p>提供了访问远程 MySQL 服务器上表的方法</p>
<ol>
<li>本地不存储数据，数据全部放到远程服务器上</li>
<li>本地需要保存表结构和远程服务器的连接信息</li>
</ol>
<h5 id="Ferderated使用场景"><a href="#Ferderated使用场景" class="headerlink" title="Ferderated使用场景"></a>Ferderated使用场景</h5><p>偶尔的统计分析及手工查询（某些游戏行业）</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h4><h5 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h5><h5 id="Btree"><a href="#Btree" class="headerlink" title="Btree"></a>Btree</h5><h5 id="B-tree"><a href="#B-tree" class="headerlink" title="B+tree"></a>B+tree</h5><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><div class="note note-danger">
            <p><strong>面试题——InnoDB聚簇索引：</strong></p><p>InnoDB 没有主键咋办？</p>
          </div>

<div class="note note-success">
            <p><strong>回答：</strong>如果表中没有主键或者一个合适的的唯一索引，InnoDB内部会以一个包含行ID值的合成列生成一个隐藏的聚簇索引。表中的行是按照InnoDB分配的ID排序的。行ID是一个6字节的字段，随着一个新行的插入单调增加。因此，行ID顺序物理上是插入顺序。</p><p>所有用ROW_ID列的表，共享同一个被保存在数据字典中的全局序列数。这就会导致竞争从而引起性能问题。</p>
          </div>

<div class="note note-danger">
            <p><strong>面试题——InnoDB聚簇索引</strong>：</p><p>InnoDB为什么推荐使用自增ID作为主键？</p>
          </div>

<div class="note note-success">
            <p><strong>回答：</strong>自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p><p>如何去理解这句话呢：</p><p>  InnoDB引擎使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放。因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>​    1、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</p><p>​    这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>​    2、 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
          </div>

<h4 id="索引的使用及三星索引"><a href="#索引的使用及三星索引" class="headerlink" title="索引的使用及三星索引"></a>索引的使用及三星索引</h4><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。</p>
<p>• 在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p>
<p>• 在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p>
<p>• 索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p>
<p>主要目的就是<span class="label label-primary">减少IO次数</span></p>
<p>适用条件</p>
<p>​     ①需要整表扫描的情况。比如：range, ref, eq_ref, ref_or_null 。适用于InnoDB 引擎和 MyISAM 引擎的查询。（5.6版本不适用分区表查询，5.7版本后可以用于分区表查询）。</p>
<p>​     ②对于InnDB引擎只适用于二级索引，因为InnDB的聚簇索引会将整行数据读到InnDB的缓冲区，这样一来索引条件下推的主要目的减少IO次数就失去了意义。因为数据已经在内存中了，不再需要去读取了。</p>
<p>​     ③引用子查询的条件不能下推。</p>
<p>调用存储过程的条件不能下推，存储引擎无法调用位于MySQL服务器中的存储过程。</p>
<h4 id="MRR-顺序磁盘读"><a href="#MRR-顺序磁盘读" class="headerlink" title="MRR (顺序磁盘读)"></a>MRR (顺序磁盘读)</h4><p>MRR，全称「Multi-Range Read Optimization」。</p>
<p>简单说：MRR 通过把「随机磁盘读」，转化为「顺序磁盘读」，从而提高了索引查询的性能。</p>
<p>对于 Myisam，在去磁盘获取完整数据之前，会先按照rowId排好序，再去顺序的读取磁盘。</p>
<p>对于 Innodb，则会按照聚簇索引键值排好序，再顺序的读取聚簇索引。</p>
<p>顺序读带来了几个好处：</p>
<p>1、磁盘和磁头不再需要来回做机械运动；</p>
<p>2、可以充分利用磁盘预读（局部性原理）</p>
<p>3、在一次查询中，每一页的数据只会从磁盘读取一次</p>
<p>索引本身就是为了减少磁盘 IO，加快查询，而MRR，则是把索引减少磁盘 IO 的作用，进一步放大。</p>
<p>MRR在本质上是一种用空间换时间的算法。MySQL 不可能给你无限的内存来进行排序</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul>
<li>原子性</li>
</ul>
<p>一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败</p>
<ul>
<li>一致性</li>
</ul>
<p>将数据库从一种一致性转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏</p>
<ul>
<li>隔离性</li>
</ul>
<p>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<ul>
<li>持久性</li>
</ul>
<p>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失</p>
<h4 id="三类事务问题"><a href="#三类事务问题" class="headerlink" title="三类事务问题"></a>三类事务问题</h4><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p>A事务中的读操作可能读到另一个事务中未提交修改的数据，如果事务发生回滚就可能造成错误。</p>
<p><em>dirty read</em></p>
<p><em>An operation that retrieves unreliable data, data that was updated by another transaction but not yet committed. It is only possible with the isolation level known as read uncommitted.</em></p>
<p><em>This kind of operation does not adhere to the ACID principle of database design. It is considered very risky, because the data could be rolled back, or updated further before being committed; then, the transaction doing the dirty read would be using data that was never confirmed as accurate.</em></p>
<p><em>Its opposite is consistent read, where InnoDB ensures that a transaction does not read information updated by another transaction, even if the other transaction commits in the meantime.</em></p>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。</p>
<p><em>non-repeatable read</em></p>
<p><em>The situation when a query retrieves data, and a later query within the same transaction retrieves what should be the same data, but the queries return different results (changed by another transaction committing in the meantime).</em></p>
<p><em>This kind of operation goes against the ACID principle of database design. Within a transaction, data should be consistent, with predictable and stable relationships.</em></p>
<p><em>Among different isolation levels, non-repeatable reads are prevented by the serializable read and repeatable read levels, and allowed by the consistent read, and read uncommitted levels.</em></p>
<h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><p>如果一个查询在一个事务中运行两次，与此同时，另一个事务将在插入新行后提交 或更新一行，使其与查询的WHERE子句匹配。这种情况被称为幻像读取，比不可重复读取更难防范，因为锁定第一个查询结果集中的所有行并不能阻止导致幻像出现的更改。</p>
<p><em>phantom</em></p>
<p><em>A row that appears in the result set of a query, but not in the result set of an earlier query. For example, if a query is run twice within a transaction, and in the meantime, another transaction commits after inserting a new row or updating a row so that it matches the WHERE clause of the query.</em></p>
<p><em>This occurrence is known as a phantom read. It is harder to guard against than a non-repeatable read, because locking all the rows from the first query result set does not prevent the changes that cause the phantom to appear.</em></p>
<p><em>Among different isolation levels, phantom reads are prevented by the serializable read level, and allowed by the repeatable read, consistent read, and read uncommitted levels.</em></p>
<div class="note note-primary">
            <p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。</p><p>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
          </div>

<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src="/img/mysqlgelijibie.png" srcset="/img/loading.gif"></p>
<div class="note note-primary">
            <p>但是mysql在RR上通过间隙锁解决了幻读问题</p>
          </div>

<div class="note note-danger">
            <p><strong>面试题——事务隔离级别</strong>：那么Mysql通过什么完成了RR事务隔离级别，解决了脏读、不可重复读、幻读这些问题的呢？</p>
          </div>

<div class="note note-success">
            <p><strong>回答</strong>：MVCC + LBCC</p>
          </div>

<p>那么下面就开始讲mysql的锁操作以及MVCC实现原理</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p>
<p>根据粒度分： 行锁 表锁 页锁</p>
<p>根据功能分： 共享锁(读锁)  排它锁(写锁) </p>
<h4 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h4><h5 id="共享读锁"><a href="#共享读锁" class="headerlink" title="共享读锁"></a>共享读锁</h5><pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">read</span></code></pre>

<p>同一会话：写操作报错，<span class="label label-warning">其他表的读写操作也都会报错</span>，使用<span class="label label-primary">别名</span>的读操作也会报错</p>
<p>新开会话：不堵塞读操作，堵塞写操作，其他表的读写操作都能正常进行</p>
<h5 id="独占写锁"><a href="#独占写锁" class="headerlink" title="独占写锁"></a>独占写锁</h5><pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">read</span></code></pre>

<p>同一会话：读写均OK，<span class="label label-warning">其他表的读写操作也都会报错</span></p>
<p>新开会话：堵塞读写</p>
<h4 id="InnoDB-1"><a href="#InnoDB-1" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB支持行锁，行锁不是字面意义上的锁住一行数据，<span class="label label-primary">行锁是通过给索引上的索引项加锁来实现的。</span>只有通过索引条件检索数据，InnoDB才使用行级锁。</p>
<p>同时<span class="label label-warning">两个事务不能锁同一个索引。</span></p>
<p>而当<span class="label label-danger">索引失效</span>时，行锁就变为了表锁。这里的表锁也不是字面意义的表锁，而是锁住了所有索引项，其效果等同于表锁罢了。</p>
<div class="note note-secondary">
            <p>曾经有一次实验就出现了这样的问题：</p><p>因为where条件里对int的索引项强制类型转换成了string，导致了索引失效，因此行锁升级成了表锁，导致其他数据也无法进行更新。找了好久问题所在。</p>
          </div>

<h5 id="共享锁（S）"><a href="#共享锁（S）" class="headerlink" title="共享锁（S）"></a>共享锁（S）</h5><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表 <span class="hljs-keyword">where</span> 条件 <span class="hljs-keyword">lock</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">share</span> <span class="hljs-keyword">mode</span></code></pre>

<p>又名读锁，对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后才能进行。</p>
<h5 id="排他锁（X）"><a href="#排他锁（X）" class="headerlink" title="排他锁（X）"></a>排他锁（X）</h5><div class="note note-info">
            <p>insert ，delete ， update在事务中都会自动默认加上排它锁</p>
          </div>

<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存</p>
<p>意向锁 –-&gt; 让表锁和行锁共存</p>
<p>意向锁是由数据引擎自己维护的</p>
<p>意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。对于同一张表，不同行的IX可以共存。</p>
<p>意向锁之间是互相兼容的</p>
<p>注意：这里的排他 / 共享锁指的都是表锁！！！意向锁不会与行级的共享 / 排他锁互斥！！</p>
<p><img src="https://img-blog.csdnimg.cn/20200930151134503.png" srcset="/img/loading.gif"></p>
<h4 id="锁的等待问题"><a href="#锁的等待问题" class="headerlink" title="锁的等待问题"></a>锁的等待问题</h4><p>通过以下命令查看表的锁情况</p>
<pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> information_schema.INNODB_LOCKS;</code></pre>

<p>通过以下命令查看处于堵塞状态的线程，并通过kill_blocking字段kill掉阻塞源</p>
<pre><code class="hljs csharp"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> sys.innodb_lock_waits</code></pre>



<p>以下代码在5.6版本运行</p>
<pre><code class="hljs mipsasm">SELECT
r.trx_id <span class="hljs-keyword">waiting_trx_id,</span>
<span class="hljs-keyword">r.trx_mysql_thread_id </span><span class="hljs-keyword">waiting_thread,</span>
<span class="hljs-keyword">r.trx_query </span><span class="hljs-keyword">waiting_query,</span>
<span class="hljs-keyword">b.trx_id </span><span class="hljs-keyword">blocking_trx_id,</span>
<span class="hljs-keyword">b.trx_mysql_thread_id </span><span class="hljs-keyword">blocking_thread</span>
<span class="hljs-keyword">FROM</span>
<span class="hljs-keyword">information_schema.innodb_lock_waits </span>w
INNER <span class="hljs-keyword">JOIN</span>
<span class="hljs-keyword">information_schema.innodb_trx </span><span class="hljs-keyword">b </span>ON <span class="hljs-keyword">b.trx_id </span>= w.<span class="hljs-keyword">blocking_trx_id</span>
<span class="hljs-keyword">INNER </span><span class="hljs-keyword">JOIN</span>
<span class="hljs-keyword">information_schema.innodb_trx </span>r ON r.trx_id = w.requesting_trx_id;</code></pre>



<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h4 id="加锁详细分析"><a href="#加锁详细分析" class="headerlink" title="加锁详细分析"></a>加锁详细分析</h4><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h2 id="记录一些其他知识点"><a href="#记录一些其他知识点" class="headerlink" title="记录一些其他知识点"></a>记录一些其他知识点</h2><h3 id="简单讲讲oracle和mysql"><a href="#简单讲讲oracle和mysql" class="headerlink" title="简单讲讲oracle和mysql"></a>简单讲讲oracle和mysql</h3><p><strong>①并发性</strong></p>
<p>Mysql以表级锁为主。InnoDB引擎的表可以用行级锁，其依赖于表的索引。oracle使用行级锁，对资源锁定的粒度要小很多</p>
<p><strong>②一致性</strong></p>
<p>oracle支持serializable的隔离级别，可以实现最高级别的读一致性。mysql支持到RC隔离级别</p>
<p><strong>③事务</strong></p>
<p>Oracle支持事务，mysql的innodb支持事务</p>
<p><strong>④持久性</strong></p>
<p>oracle：保证提交的数据均可恢复，因为oracle把提交的sql操作线写入了在线联机日志文件中，保持到了磁盘上，如果出现数据库或主机异常重启，重启后oracle可以考联机在线日志恢复客户提交的数据。</p>
<p>mysql：默认提交sql语句，但如果更新过程中出现db或主机重启的问题，也许会丢失数据。</p>
<p><strong>⑤逻辑备份</strong></p>
<p> oracle逻辑备份时不锁定数据，且备份的数据是一致的。</p>
<p>  mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的</p>
<p><strong>⑥热备份</strong></p>
<p>oracle有成熟的热备工具rman，热备时，不影响用户使用数据库。即使备份的数据库不一致，也可以在恢复时通过归档日志和联机重做日志进行一致的回复。</p>
<p>mysql：myisam的引擎，用mysql自带的mysqlhostcopy热备时，需要给表加读锁，影响dml操作。innodb的引擎，它会备份innodb的表和索引，但是不会备份.frm文件。用ibbackup备份时，会有一个日志文件记录备份期间的数据变化，因此可以不用锁表，不影响其他用户使用数据库。但此工具是收费的。innobackup是结合ibbackup使用的一个脚本，他会协助对.frm文件的备份。</p>
<p><strong>⑦sql语句的扩展和灵活性</strong></p>
<p>mysql对sql语句有很多非常实用而方便的扩展，比如limit功能，insert可以一次插入多行数据，select某些管理数据可以不加from。</p>
<p>  oracle在这方面感觉更加稳重传统一些。</p>
<p><strong>⑧复制</strong></p>
<p>oracle：既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。</p>
<p> mysql：复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。</p>
<p><strong>⑨性能诊断</strong></p>
<p>  oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等</p>
<p>  mysql的诊断调优方法较少，主要有慢查询日志。</p>
<p><strong>⑩权限与安全</strong></p>
<p>  mysql的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。</p>
<p>  oracle的权限与安全概念比较传统，中规中矩。</p>
<p><strong>⑪分区表和分区索引</strong></p>
<p>  oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。</p>
<p>  mysql的分区表还不太成熟稳定。</p>
<h3 id="MySQL各版本更新记录"><a href="#MySQL各版本更新记录" class="headerlink" title="MySQL各版本更新记录"></a>MySQL各版本更新记录</h3><p>5.5   默认存储引擎更改为innodb</p>
<p>5.6   加入索引下推</p>
<p>5.7   加入json数据类型</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[^1]关系型数据库与非关系型数据库 <a target="_blank" rel="noopener" href="https://blog.csdn.net/oChangWen/article/details/53423301">https://blog.csdn.net/oChangWen/article/details/53423301</a> </p>
<p>[^2]InnoDB 和MyISAM的区别 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35642036/article/details/82820178">https://blog.csdn.net/qq_35642036/article/details/82820178</a> </p>
<p>[^3]意向锁 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903666332368909">https://juejin.im/post/6844903666332368909</a></p>
<p>[^4]索引下推 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Chenjiabing/p/12600926.html">https://www.cnblogs.com/Chenjiabing/p/12600926.html</a></p>
<p>[^5]MRR <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110154066">https://zhuanlan.zhihu.com/p/110154066</a></p>
<style>
  /* 只设置  note字体 */
  .note {
    font-family: "Microsoft YaHei",Georgia, sans, serif, KaiTi,;
    font-size: 15px;
  }
</style>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/02/hello-world/">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "mysql&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>

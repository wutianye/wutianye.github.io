<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mybatis</title>
    <link href="/2021/01/01/MyBatis/"/>
    <url>/2021/01/01/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis知识点总结"><a href="#Mybatis知识点总结" class="headerlink" title="Mybatis知识点总结"></a>Mybatis知识点总结</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>MyBatis 的缓存分为一级缓存和二级缓存。<img src="/img/mybatis1.png"></p><p>一级缓存放在 session 里面,默认就有。失效场景：①两次查询间使用插入    ②不同session    ③where条件不同的查询语句。源码在BaseExecutor中。Map存储。</p><p>二级缓存存放在它的命名空间里，默认是不打开的。开启二级缓存后，会使用 CachingExecutor 装饰 Executor，进入一级缓存的查询流程前，先在CachingExecutor 进行二级缓存的查询。当二级缓存开启后，同一个命名空间(namespace) 所有的操作语句，都影响着一个<strong>共同的 cache</strong>，也就是二级缓存被多个 SqlSession 共享，是一个<strong>全局的变量</strong>。当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。使用二级缓存属性类需要实现 Serializable 序列化 接口(可用来保存对象的状态)，可在它的映射文件中配置cache标签。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--开启二级缓存--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><span class="hljs-comment">&lt;!--使用二级缓存   Mapper接口--&gt;</span> @CacheNamespace<span class="hljs-comment">&lt;!--使用二级缓存   Mapper.xml--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">cache</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span><span class="hljs-comment">&lt;!--单个语句配置二级缓存   Mapper.xml--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;false&quot;</span></span><span class="hljs-tag"></span>&lt;!--单个语句配置二级缓存   Mapper接口--&gt; @Options(useCache = false)<span class="hljs-comment">&lt;!--单个语句配置刷新缓存   Mapper.xml--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag"></span>&lt;!--配置redis分布式缓存   Mapper.xml--&gt; <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.caches.redis.RedisCache&quot;</span> /&gt;</span></code></pre><div class="note note-danger">            <p>多表操作会影响二级缓存，可能会得到脏数据。 用cache-ref标签 指向另一个命名空间能解决</p>          </div><p>二级缓存是表级缓存，开销大，没有一级缓存直接使用 HashMap 来存储的效率更高，所以<strong>二级缓存并不推荐使用</strong>。</p><h3 id="mybatis插件"><a href="#mybatis插件" class="headerlink" title="mybatis插件"></a>mybatis插件</h3><ul><li><strong>运行原理</strong></li></ul><p>Mybatis 通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能</p><p>MyBatis允许在已映射语句执行过程中的某一点进行拦截调用，默认情况下MyBatis允许使用插件来拦截的四大对象：</p><ol><li>Executor: 执行增删改查操作</li><li>StatementHandler: 处理SQL预编译，设置参数等相关工作</li><li>ParameterHandler: 设置预编译参数用的</li><li>ResultSetHandler: 处理结果集</li></ol><p>每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法</p><ul><li><strong>自己编写</strong></li></ul><p>实现 Mybatis 的 Interceptor 接口并复写 intercept()方法</p><pre><code class="hljs java"><span class="hljs-comment">// ExamplePlugin.java</span><span class="hljs-meta">@Intercepts(&#123;@Signature(</span><span class="hljs-meta">  type= Executor.class,</span><span class="hljs-meta">  method = &quot;update&quot;,</span><span class="hljs-meta">  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExamplePlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;  <span class="hljs-keyword">private</span> Properties properties = <span class="hljs-keyword">new</span> Properties();  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <span class="hljs-comment">// implement pre processing if need</span>    Object returnObject = invocation.proceed();    <span class="hljs-comment">// implement post processing if need</span>    <span class="hljs-keyword">return</span> returnObject;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;    <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span> </span>&#123;    <span class="hljs-keyword">this</span>.properties = properties;  &#125;&#125;</code></pre><h3 id="Mybatis-Excutor"><a href="#Mybatis-Excutor" class="headerlink" title="Mybatis  Excutor"></a>Mybatis  Excutor</h3><p>Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。1）SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。2）ReuseExecutor：执行 update 或 select，以 sql 作为key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map3）BatchExecutor：完成批处理。</p><h3 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{}和${}的区别是什么"></a>#{}和${}的区别是什么</h3><p>1）#{}是预编译处理，${}是字符串替换。 </p><p>2）Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法 来赋值； </p><p>3）Mybatis 在处理${}时，就是把${}替换成变量的值。</p><p> 4）使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p><h3 id="Mybais和Hibernate"><a href="#Mybais和Hibernate" class="headerlink" title="Mybais和Hibernate"></a>Mybais和Hibernate</h3><table><thead><tr><th>Mybais</th><th>Hibernate</th></tr></thead><tbody><tr><td>半自动 ORM 映射工具， 动态sql</td><td>全自动 ORM 映射工具，据对象关系模型直接获取</td></tr><tr><td>简单易学</td><td>学习门槛高，要设计 O/R 映射，在性能和对象模型之间如何权衡</td></tr><tr><td>灵活度高，非常适合对关系数据模型要求不高的软件开发</td><td>Hibernate 对象/关系映射能力强，数据库无关性好，适合关系模型要求高的软件</td></tr></tbody></table><h3 id="接口绑定"><a href="#接口绑定" class="headerlink" title="接口绑定"></a>接口绑定</h3><ol><li>注解绑定</li><li>xml绑定</li></ol><h3 id="Dao工作原理"><a href="#Dao工作原理" class="headerlink" title="Dao工作原理"></a>Dao工作原理</h3><p> jdk 动态代理原理，运行时会为 dao 生成 proxy，代理对象会拦截接口方法，去执行对应的 sql 返回数据。</p><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>1）Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。<br>2）它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;cn.ideal.mapper.UserMapper.findById&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span></code></pre><h2 id="有趣的用法"><a href="#有趣的用法" class="headerlink" title="有趣的用法"></a>有趣的用法</h2><h3 id="批量插入，返回主键列表"><a href="#批量插入，返回主键列表" class="headerlink" title="批量插入，返回主键列表"></a>批量插入，返回主键列表</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;batchInsert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.util.List&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> &gt;</span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><style>  /* 只设置  note字体 */  .note {    font-family: "Microsoft YaHei",Georgia, sans, serif, KaiTi,;    font-size: 14px;  }</style><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Mybatis缓存 <a href="https://www.cnblogs.com/cxuanBlog/p/11333021.html">MyBatis 二级缓存全详解 - 程序员cxuan - 博客园 (cnblogs.com)</a><p><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Mybatis缓存 <a href="https://www.cnblogs.com/isdxh/p/13963636.html">Mybatis的二级缓存、使用Redis做二级缓存 - 邓晓晖 - 博客园 (cnblogs.com)</a><br><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Mybatis延迟加载 <a href="https://cloud.tencent.com/developer/article/1587223">https://cloud.tencent.com/developer/article/1587223</a><br><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>Mybatis手写插件 <a href="https://zhuanlan.zhihu.com/p/259908377#:~:text=MyBatis%E4%BD%BF,%E5%AE%89%E5%85%A8%E9%AB%98%E6%95%88%E7%9A%84%E6%8F%92%E4%BB%B6%E3%80%82">https://zhuanlan.zhihu.com/p/259908377#:~:text=MyBatis%E4%BD%BF,%E5%AE%89%E5%85%A8%E9%AB%98%E6%95%88%E7%9A%84%E6%8F%92%E4%BB%B6%E3%80%82</a><br><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>springboot</title>
    <link href="/2020/11/01/SpringBoot/"/>
    <url>/2020/11/01/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-学习笔记"><a href="#SpringBoot-学习笔记" class="headerlink" title="SpringBoot 学习笔记"></a>SpringBoot 学习笔记</h1><h2 id="一、Spring"><a href="#一、Spring" class="headerlink" title="一、Spring"></a>一、Spring</h2><h3 id="1-1-Spring概述"><a href="#1-1-Spring概述" class="headerlink" title="1.1 Spring概述"></a>1.1 Spring概述</h3><p>Spring框架是一个轻量级的企业级开发的一站式解决方案。是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。spring框架指spring framework，它集合了20多个模块协助程序员进行高效率的开发。</p><p>Spring使用简单的POJO来进行企业级开发。每一个被spring管理的java对象都称之为Bean，Spring使用IOC容器来初始化对象，解决对象间的依赖管理和对象的使用。</p><p><strong>Spring四大原则</strong></p><p>①使用POJO进行轻量级和最小侵入式开发</p><p>②通过依赖注入和基于接口编程实现松耦合</p><p>③通过AOP和默认习惯进行声明式编程</p><p>④使用AOP和模板减少模式化代码</p><h3 id="1-2-Spring模块结构"><a href="#1-2-Spring模块结构" class="headerlink" title="1.2 Spring模块结构"></a>1.2 Spring模块结构</h3><p><strong>Spring模块结构</strong></p><p>Spring 总共大约有 20 个模块，这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中</p><p><img src="/img/spring_kuangjia.png"></p><p>常用核心模块介绍：</p><p><strong>1、核心容器(Core)</strong></p><p>这是Spring框架最基础的部分，它提供了依赖注入（Dependency Injection）特征来实现容器对Bean的管理。这里最基本的概念是BeanFactory，它是任何Spring应用的核心。BeanFactory是工厂模式的一个实现，它使用IoC将应用配置和依赖说明从实际的应用代码中分离出来。</p><p><strong>2、AOP模块</strong></p><p>AOP即面向切面编程技术，Spring在它的AOP模块中提供了对面向切面编程的丰富支持。确保了Spring和其他AOP框架的共通性。这个模块将元数据编程引入Spring</p><p>AOP允许通过分离应用的业务逻辑与系统级服务（例如安全和事务管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或   支持。</p><p><strong>3、对象/关系映射集成模块ORM</strong></p><p>Spring通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring支持集成主流的ORM框架，如Hiberate,JDO和iBATISSQLMaps。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p><p><strong>4、JDBC抽象和DAO模块</strong></p><p>提供了一个JDBC的抽象层，简化了JDBC，保证了数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP模块给Spring应用中的对象提供事务管理服务</p><p><strong>5、Spring的Web模块</strong></p><p>Web上下文模块建立于applicaiton context之上，提供了一个适合于Web应用的上下文。另外，这个模块还提供了一些面向服务支持。例如：实现文件上传的multipart请求，它也提供了Spring和其它Web框架的集成，比如Struts、WebWork。</p><p><strong>6、应用上下文（Context）模块</strong></p><p>核心模块的BeanFactory使Spring成为一个容器，而上下文模块使它成为一个框架。Web上下文模块建立于应用上下文模块之上，提供了一个适合于Web应用的上下文。该模块还提供了一些面向服务支持这个模块扩展了BeanFactory的概念，增加了对国际化（I18N）消息、事件传播以及验证的支持。</p><p>另外，这个模块还提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括对模版框架例如Velocity和FreeMarker集成的支持。</p><p><strong>7、Spring的MVC框架</strong></p><p>Spring为构建Web应用提供了一个功能全面的MVC框架。虽然Spring可以很容易地与其它MVC框架集成，例如Struts2，但Spring的MVC框架使用IoC对控制逻辑和业务对象提供了完全的分离。</p><p><strong>8、Spring Aspects</strong> ：</p><p>该模块为与AspectJ的集成提供支持。</p><p><strong>9、Spring Test</strong> : </p><p>提供了对 JUnit 和 TestNG 测试的支持。</p><h3 id="1-3-IOC"><a href="#1-3-IOC" class="headerlink" title="1.3 IOC"></a>1.3 IOC</h3><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，用来减低代码耦合度。其思想是反转资源获取的方向。Spring IOC通过依赖注入来实现，所谓依赖注入指的是容器负责创建对象和维护对象间的依赖关系。</p><p>SpringIOC通过依赖注入，来创建对象和维护对象间的依赖关系并管理这些对象的整个生命周期。</p><span class="label label-success">IOC的优点是</span><p>①实现了松耦合</p><p>②使应用易于测试</p><p>③实现资源的可配置和易管理</p><h4 id="Spring-IOC容器"><a href="#Spring-IOC容器" class="headerlink" title="Spring IOC容器"></a>Spring IOC容器</h4><p>Spring 提供了以下两种不同类型的容器。</p><table><thead><tr><th>序号</th><th>容器 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td>BeanFactory 容器它是最简单的容器，给 DI 提供了基本的支持，它用 org.springframework.beans.factory.BeanFactory 接口来定义。</td></tr><tr><td>2</td><td>Spring ApplicationContext 容器是对BeanFactory的拓展，该容器添加了更多的企业特定的功能，例如从一个属性文件中解析文本信息的能力，发布应用程序事件给感兴趣的事件监听器的能力。该容器是由 org.springframework.context.ApplicationContext 接口定义。其主要有四种实现：<span class="label label-info">ClassPathXmlApplicationContext</span>、  <span class="label label-info">FileSystemXmlApplicationContext</span>、<span class="label label-info">XmlWebApplicationContext</span>、<span class="label label-info">AnnotationConfigApplicationContext（基于Java配置） | **面试题——FileSystemResource和ClassPathResource有何区别？：** 回答： 在FileSystemResource中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource文件放在ClassPath下。如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件（xml文件）中读取配置文件。 #### Bean的概述 bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。 Spring提供使用xml、注解、java配置实现bean的创建和注入，这些配置被称为配置元数据，所谓元数据即描述数据的数据。元数据本身不具备任何可执行能力，只能通过外界代码来对这些元数据进行解析后进行有意义的操作。 {% label success </span></td></tr></tbody></table><h4 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h4><p>@Scope：</p><ol><li>singleton   全容器共享一个实例 </li><li>prototype  每次调用新建</li><li>request      每一个http请求新建一个</li><li>session      每一个httpsession新建一个 </li><li>globalsession   每一个globalhttpsession新建一个 </li></ol><h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h4><p>beanfactory 负责管理bean的生命周期</p><p>Bean的生命周期可以表达为：Bean的定义——Bean的初始化——Bean的使用——Bean的销毁</p><ul><li>①通过构造器或工厂方法创建Bean实例</li><li>②为Bean的属性设置值和对其他Bean的引用</li><li>③BeanNameAware的setBeanName方法。</li><li>④BeanFactoryAware的setBeanFactory方法</li><li>⑤将Bean实例传递给Bean前置处理器的postProcessBeforeInitialization方法</li><li>⑥如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>⑦调用Bean的初始化方法(init-method)</li><li>⑧将Bean实例传递给Bean后置处理器的postProcessAfterInitialization方法</li><li>⑨Bean可以使用了</li><li>⑩当容器关闭时,调用Bean的销毁方法(destroy-method)</li></ul><p><img src="/img/bean_life.jpg"></p><p>java配置方式：initMethod和destroyMethod</p><p>xml配置：init-method和destroy-method</p><p> JSR-250 ：@PostConstruct 和 @PreDestroy 注解</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><table><thead><tr><th>序号</th><th>依赖注入类型 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td>Constructor-based dependency injection当容器调用带有多个参数的构造函数类时，实现基于构造函数的 DI，每个代表在其他类中的一个依赖关系。</td></tr><tr><td>2</td><td>Setter-based dependency injection基于 setter 方法的 DI 是通过在调用无参数的构造函数或无参数的静态工厂方法实例化 bean 之后容器调用 beans 的 setter 方法来实现的。</td></tr></tbody></table><p><strong>构造器注入总结：</strong></p><pre><code class="hljs java"><span class="hljs-comment">// Spring4.3+之后，constructor注入支持非显示注入方式。</span><span class="hljs-comment">// @Autowired</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DI</span><span class="hljs-params">(DependencyA dependencyA, DependencyB dependencyB, DependencyC dependencyC)</span> </span>&#123;    <span class="hljs-keyword">this</span>.dependencyA = dependencyA;    <span class="hljs-keyword">this</span>.dependencyB = dependencyB;    <span class="hljs-keyword">this</span>.dependencyC = dependencyC;&#125;</code></pre><span class="label label-success">优点</span><p>①能够保证注入的组件不可变，并且确保需要的依赖不为空</p><p>②构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态</p><p>③依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则</p><span class="label label-warning">缺点</span><p>①对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿。根据单一职责原则，此时应该考虑重构。</p><p>②可能会出现循环依赖问题</p><p><strong>setter注入总结：</strong></p><pre><code class="hljs java"><span class="hljs-comment">// setter注入</span><span class="hljs-meta">@Autowired</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDependencyA</span><span class="hljs-params">(DependencyA dependencyA)</span> </span>&#123;    <span class="hljs-keyword">this</span>.dependencyA = dependencyA;&#125;<span class="hljs-meta">@Autowired</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDependencyB</span><span class="hljs-params">(DependencyB dependencyB)</span> </span>&#123;    <span class="hljs-keyword">this</span>.dependencyB = dependencyB;&#125;</code></pre><span class="label label-success">优点</span><p>①setter的方式能让类在之后重新配置或者重新注入。</p><p>②允许为空，可以解决循环依赖问题</p><span class="label label-warning">缺点</span><p>①对于仅使用setter注入的依赖对象需要进行非空检查</p><span class="label label-primary">**最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖**</span><p><strong>字段注入总结：</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 字段注入</span><span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> DependencyA dependencyA; <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> DependencyB dependencyB;</code></pre><span class="label label-success">优点</span><p>①简洁、快捷</p><span class="label label-warning">缺点</span><p>①不易察觉违反单一职责原则</p><p>②有可能出现循环依赖问题，而且启动不会报错，只有在使用时才会报错。<br>③无法注入final<br>字段注入方式无法注入final字段，只有构造器注入才能注入final字段<br>④隐藏了依赖关系<br>外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖。使用依赖注入容器意味着类不再对依赖对象负责，获取依赖对象的职责从类中抽离出来，IoC容器会帮你装配。当类不再为依赖对象负责，它应该更明确的使用公有的接口方法或构造器，使用这种方式能很清晰的了解类需要什么，也能明确它是可选的(setter注入)还是强制的(构造器注入)。<br>⑤依赖注入容器紧耦合<br>依赖注入框架的核心思想之一就是受容器管理的类不应该去依赖容器所使用的依赖对象。换句话说，这个类应该是一个简单的POJO(Plain Ordinary Java Object)能够被单独实例化并且你也能为它提供它所需的依赖。只有这样，你才能在单元测试中实例化这个类而不必去启动依赖注入容器，实现测试分离(启动容器更多是集成测试)。然而，当使用变量直接注入时，没有一种方式能直接地实例化这个类并且满足其所有的依赖。这意味着需要手动new出来依赖对象或者只能在IoC Container范围使用。</p><h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p>自动装配是为了将依赖注入“自动化”的一个简化配置的操作</p><p>自动装配就是不使用<constructor-arg><code>和</code><property>注解进行依赖注入</p> <span class="label label-info">bean的自动装配模式：</span><ol><li>no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。</li><li>byName：根据bean名称设置依赖关系。<span class="label label-info">Resource注解使用byName</span></li><li>byType：根据bean类型设置依赖关系。<span class="label label-info">Autowired注解使用bytype</span></li><li>constructor：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。</li><li>autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。</li></ol><h3 id="1-4-Spring配置"><a href="#1-4-Spring配置" class="headerlink" title="1.4 Spring配置"></a>1.4 Spring配置</h3><p>将Spring配置到应用开发中有以下三种方式：1.基于XML的配置      2.基于注解的配置      3.基于Java的配置</p><p><strong>注解配置</strong></p><span class="label label-primary">声明Bean的注解：</span><p>@Component</p><p>@Service   service层</p><p>@Repository   dao层</p><p>@Controller    controller层</p><div class="note note-danger">            <p><strong>面试题——@Component和@Bean的区别：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><ol><li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ol>          </div><span class="label label-info">使用Bean的注解：</span><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@Required</td><td>注解应用于 bean 属性的 setter 方法。</td></tr><tr><td>@Autowired</td><td>@Autowired是spring自带的注解。可以应用到变量、setter方法、构造函数上。默认采用byType装配模式，可以配合@Qualifier按名称匹配。</td></tr><tr><td>@Resource</td><td>@Resource是JSR250规范的实现。可以写在字段上,或setter方法上。默认采用byName装配模式</td></tr><tr><td>@Inject</td><td>@Inject是JSR330中的规范。可以应用到变量、setter方法、构造函数上。默认采用byType装配模式。可以配合@Named按名称匹配。可以通过配置type属性使用byType装配模式</td></tr></tbody></table><p>@Autowired写在构造方法和写在变量上有何不同： </p><p>构造方法上即使用Constructor-based依赖注入</p><p>但是由于java变量的初始化顺序为静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法–&gt;@Autowired。因此在构造方法中调用@Autowired声明的变量会报错，因为执行构造方法时尚未执行@Autowired。</p><pre><code class="hljs java"><span class="hljs-number">1</span> <span class="hljs-meta">@Autowired</span><span class="hljs-number">2</span> <span class="hljs-keyword">private</span> User user;<span class="hljs-number">3</span> <span class="hljs-keyword">private</span> String school;<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserAccountServiceImpl</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-number">6</span>     <span class="hljs-keyword">this</span>.school = user.getSchool();  <span class="hljs-comment">//报错，尚未执行@Autowired</span><span class="hljs-number">7</span> &#125;</code></pre><pre><code class="hljs java"><span class="hljs-number">1</span> <span class="hljs-keyword">private</span> User user;<span class="hljs-number">2</span> <span class="hljs-keyword">private</span> String school;<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-meta">@Autowired</span><span class="hljs-number">5</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserAccountServiceImpl</span><span class="hljs-params">(User user)</span></span>&#123;<span class="hljs-number">6</span>     <span class="hljs-keyword">this</span>.user = user;<span class="hljs-number">7</span>     <span class="hljs-keyword">this</span>.school = user.getSchool();  <span class="hljs-comment">//正确</span><span class="hljs-number">8</span> &#125;</code></pre><p><strong>JAVA 配置</strong></p><p>@Configuration 声明为配置类</p><p>@Bean  注解在方法上，声明当前方法的返回值是一个Bean</p><span class="label label-info">在spring容器中，只要容器存在某个bean，就能在另一个bean的声明方法的参数中写入</span><div class="note note-danger">            <p><strong>面试题——什么是JAVA Config：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><p>SpringJavaConfig是Spring社区的产品，提供了配置SpringIoC容器的纯Java方法。优点是可以充分利用面向对象功能，减少xml配置，同时保证了类型安全和重构友好。</p>          </div><h3 id="1-5-AOP"><a href="#1-5-AOP" class="headerlink" title="1.5 AOP"></a>1.5 AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p>OOP只有继承和实现，不仅使耦合度增强，继承也只能为单继承，AOP弥补了OOP的不足，使得一组类共享相同的行为</p><p>Spring支持AspectJ的注解式切面编程</p><pre><code class="hljs java"><span class="hljs-comment">// 编写拦截规则的注解——自定义注解</span><span class="hljs-meta">@Target(ElementType.METHOD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Action &#123;  <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>  <span class="hljs-comment">//定义切面</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">logAspect</span> </span>&#123;    <span class="hljs-meta">@Pointcut(&quot;&quot;)</span>   <span class="hljs-comment">// 定义切点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">annotationPointCut</span><span class="hljs-params">()</span></span>&#123;&#125;        <span class="hljs-meta">@After(&quot;annotationPointCut()&quot;)</span>   <span class="hljs-comment">// 定义建言</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">(JoinPoint point)</span></span>&#123;            &#125;    &#125;</code></pre><h3 id="1-6-Spring高级话题"><a href="#1-6-Spring高级话题" class="headerlink" title="1.6 Spring高级话题"></a>1.6 Spring高级话题</h3><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件（ApplicationEvent）为bean之间的消息通信提供了支持</p><p>Spring的事件遵循如下流程：</p><ol><li>定义事件</li><li>定义事件监听器</li><li>使用容器发布事件</li></ol><p>Spring提供了以下5种标准的事件：</p><ol><li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext接口中的refresh()方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 自定义event</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span></span>&#123;&#125;<span class="hljs-comment">//事件监听器。当此事件被发布后，会自动触发</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationEventListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ApplicationEvent</span>&gt; </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent applicationEvent)</span></span>&#123;  &#125;&#125;<span class="hljs-comment">//事件发布器</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoPublisher</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(String msg)</span></span>&#123;        applicationContext.publishEvent(<span class="hljs-keyword">new</span> DemoEvent(<span class="hljs-keyword">this</span>, msg));    &#125;&#125;</code></pre><h4 id="异步-Async"><a href="#异步-Async" class="headerlink" title="异步 @Async"></a>异步 @Async</h4><h4 id="计划任务-Scheduled"><a href="#计划任务-Scheduled" class="headerlink" title="计划任务 @Scheduled"></a>计划任务 @Scheduled</h4><h4 id="条件注解-Conditional"><a href="#条件注解-Conditional" class="headerlink" title="条件注解 @Conditional"></a>条件注解 @Conditional</h4><h4 id="Spring涉及的那些设计模式"><a href="#Spring涉及的那些设计模式" class="headerlink" title="Spring涉及的那些设计模式"></a>Spring涉及的那些设计模式</h4><ul><li>代理模式—在AOP和remoting中被用的比较多。</li><li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li><li>模板方法—用来解决代码重复的问题。比如.RestTemplate,JmsTemplate,JpaTemplate。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li><li>工厂模式—BeanFactory用来创建对象的实例</li></ul><h2 id="二、SpringMVC"><a href="#二、SpringMVC" class="headerlink" title="二、SpringMVC"></a>二、SpringMVC</h2><h3 id="2-1-SpringMVC概述"><a href="#2-1-SpringMVC概述" class="headerlink" title="2.1 SpringMVC概述"></a>2.1 SpringMVC概述</h3><p>model + view + controller</p><div class="note note-danger">            <p><strong>面试题——SpringMVC和三层架构的关系：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><p>三层架构指 展现层 应用层  数据访问层</p><p>MVC只存在展现层</p>          </div><div class="note note-danger">            <p><strong>面试题——Spring  SpringMVC Springboot的关系：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><p>SpringMVC是Spring的一个模块</p><p>SpringBoot建立在Spring框架之上，设计目的是为了简化spring的搭建和开发过程。</p>          </div><h3 id="2-2基本配置"><a href="#2-2基本配置" class="headerlink" title="2.2基本配置"></a>2.2基本配置</h3><p><strong>WebMvcConfigurerAdapter</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 静态资源配置</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 拦截器配置</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;    &#125;</code></pre><p><strong>ControllerAdvice</strong></p><p>将对于控制器的全局配置放在同一个位置</p><p>@ExceptionHandler  全局异常配置</p><p>@ModelAttribute   绑定键值对到model</p><p>@InitBinder  自动绑定前台参数到model</p><p><strong>Spring过滤器和拦截器的区别</strong></p><p>规范不同：过滤器是servlet规范中定义的；拦截器是spring容器内的 </p><p>使用范围不同：过滤器只能用于web程序；拦截器既可以用于web程序，也可以用于application程序中</p><p>使用的资源不同：拦截器是spring的组件，能使用spring容器中的所有资源，service对象等都能通过ioc注入其中。过滤器则不能</p><p>起效范围不同：过滤器只在servlet前后起效。拦截器能深入到方法、异常前后，具有更大的弹性</p><h2 id="三、SpringBoot"><a href="#三、SpringBoot" class="headerlink" title="三、SpringBoot"></a>三、SpringBoot</h2><h3 id="3-1-SpringBoot基础"><a href="#3-1-SpringBoot基础" class="headerlink" title="3.1 SpringBoot基础"></a>3.1 SpringBoot基础</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>springboot建立在spring框架之上，简化了搭建和开发过程。使用“习惯优于配置”的理念让项目快速运行，使用springboot很容易创建一个独立运行、准生产级别的基于spring框架的项目。</p><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p>独立运行的Spring项目</p><p>内嵌的servlet容器</p><p>starter简化maven配置</p><p>java配置和注解配置组合</p><p>应用监控</p><p>自动配置bean </p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>快速构建项目</p><p>更少、更简易的配置</p><p>对主流开发框架的无配置集成</p><p>内嵌servlet容器，项目可独立运行</p><p>提供运行时的应用监控</p><h4 id="Spring-Boot-Stater"><a href="#Spring-Boot-Stater" class="headerlink" title="Spring Boot Stater"></a>Spring Boot Stater</h4><p>启动器是一套方便的依赖描述符，它可以放在自己的程序中。你可以一站式的获取你所需要的 Spring 和相关技术，而不需要依赖描述符的通过示例代码搜索和复制黏贴的负载。</p><h4 id="springboot自动装配原理"><a href="#springboot自动装配原理" class="headerlink" title="springboot自动装配原理"></a>springboot自动装配原理</h4><p>也可以理解为<strong>springboot运行原理</strong></p><p><strong>@SpringBootApplication注解是最核心注解</strong></p><p><code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li><li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。</li></ul><p><strong><code>@EnableAutoConfiguration</code> 是实现自动装配的重要注解</strong></p><p>自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类</p><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DeferredImportSelector</span>, <span class="hljs-title">BeanClassLoaderAware</span>, <span class="hljs-title">ResourceLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">EnvironmentAware</span>, <span class="hljs-title">Ordered</span> </span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DeferredImportSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImportSelector</span> </span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImportSelector</span> </span>&#123;       String[] selectImports(AnnotationMetadata var1);&#125;</code></pre><p>AutoConfigurationImportSelector 类实现了 ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] NO_IMPORTS = <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]; <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;         <span class="hljs-comment">// &lt;1&gt;.判断自动装配开关是否打开*        </span>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;                <span class="hljs-keyword">return</span> NO_IMPORTS;          &#125;   <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//&lt;2&gt;.获取所有需要装配的bean*            </span>    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-keyword">this</span>.beanClassLoader);       AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry        = <span class="hljs-keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);                <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());          &#125;    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="hljs-keyword">new</span> AutoConfigurationEntry();<span class="hljs-function">AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;    <span class="hljs-comment">//&lt;1&gt;.  是否开启自动装配</span>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;        <span class="hljs-keyword">return</span> EMPTY_ENTRY;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//&lt;2&gt;.用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName。</span>        AnnotationAttributes attributes = <span class="hljs-keyword">this</span>.getAttributes(annotationMetadata);        <span class="hljs-comment">//&lt;3&gt;.获取需要自动装配的所有配置类，读取META-INF/spring.factories</span>        List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);        <span class="hljs-comment">//&lt;4&gt;.这一步经历了一遍筛选，@ConditionalOnXXX 中的所有条件都满足，该类才会生效</span>        configurations = <span class="hljs-keyword">this</span>.removeDuplicates(configurations);        Set&lt;String&gt; exclusions = <span class="hljs-keyword">this</span>.getExclusions(annotationMetadata, attributes);        <span class="hljs-keyword">this</span>.checkExcludedClasses(configurations, exclusions);        configurations.removeAll(exclusions);        configurations = <span class="hljs-keyword">this</span>.filter(configurations, autoConfigurationMetadata);        <span class="hljs-keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);    &#125;&#125;</code></pre><div class="note note-success">            <p>@EnableAutoConfiguration注解是实现自动装配的重要注解。<code>AutoConfigurationImportSelector</code>类实现了自动装配的核心功能。其实现了 ImportSelector接口，获取了所有符合条件的类并将其加载到 IoC 容器中。其读取META-INF/spring.factories中的自动配置类，并筛除不满足各自@Conditional元注解的配置类</p>          </div><h3 id="3-2-SpringBoot配置"><a href="#3-2-SpringBoot配置" class="headerlink" title="3.2 SpringBoot配置"></a>3.2 SpringBoot配置</h3><h4 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h4><p>在yml可以使用**@project.groupId@** 这样的格式来获取pom文件中的信息</p><p>yml配置同样存在缺陷，官网上指明其不能支持@PropertySource，只能使用properties格式，即以下代码。此代码完成了从配置文件到entity的映射</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@PropertySource(&quot;classpath:xxx.properties&quot;)</span><span class="hljs-meta">@ConfigurationProperties(&quot;Student&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;&#125;</code></pre><h4 id="类型安全的配置"><a href="#类型安全的配置" class="headerlink" title="类型安全的配置"></a>类型安全的配置</h4><p>@ConfigurationProperties 将properties属性和一个bean相关联</p><h4 id="多环境配置Profile"><a href="#多环境配置Profile" class="headerlink" title="多环境配置Profile"></a>多环境配置Profile</h4><p>profile为在不同环境下使用不同的配置提供了支持</p><p>@profile(“dev”) 手动控制配置文件。</p><p>当你用两个不同profile配置实现类实现同一个接口时，容器也会根据当前环境调用不同impl</p><p>同时也可以在java -jar中指定spring.profiles.active参数控制当前服务使用哪一种环境</p><div class="note note-danger">            <p><strong>面试题——如何重新加载程序，而无需重启服务器：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><p>通过DEV工具实现。DEVTools模块将文件更改自动部署到服务器并自动重启，免去了手动重启的必要。在生产环境中被禁用。</p>          </div><h3 id="3-3-SpringBoot应用"><a href="#3-3-SpringBoot应用" class="headerlink" title="3.3 SpringBoot应用"></a>3.3 SpringBoot应用</h3><h4 id="自定义异常页面"><a href="#自定义异常页面" class="headerlink" title="自定义异常页面"></a>自定义异常页面</h4><p>resource目录新建<span class="label label-danger">public/error</span>，创建404.html 500.html</p><div class="note note-danger">            <p><strong>面试题——如何使用SpringBoot实现异常处理？</strong> </p>          </div><div class="note note-success">            <p>Spring提供了一种使用ControllerAdvice处理异常的非常有用的方法。我们通过实现一个ControllerAdvice类，来处理控制器类抛出的所有异常</p>          </div><h4 id="监视器-actuator"><a href="#监视器-actuator" class="headerlink" title="监视器 actuator"></a>监视器 actuator</h4><p>actuator可帮助您访问生产环境中正在运行的应用程序的当前状态。</p><p>actuator模块公开了一组可直接访问的接口来监视状态。可在yml中进行如下简单配置</p><pre><code class="hljs yaml"><span class="hljs-string">management：</span>  <span class="hljs-string">server：</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">9999</span>    <span class="hljs-attr">servlet:</span>      <span class="hljs-attr">context-path:</span> <span class="hljs-string">/www</span>  <span class="hljs-attr">endpoints:</span>    <span class="hljs-attr">web:</span>      <span class="hljs-attr">base-path:</span> <span class="hljs-string">/base</span>      <span class="hljs-attr">exposure:</span>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span>   <span class="hljs-comment">#开启所有监控终端</span>        <span class="hljs-attr">exclude:</span> [<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-string">&quot;health&quot;</span>]  <span class="hljs-comment">#指定要关闭的端口</span></code></pre><div class="note note-danger">            <p><strong>面试题——如何关闭监视器：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><p>默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们。安全性是使用标准的HttpServletRequest.isUserInRole方法实施的。我们可以使用management.security.enabled=false来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性</p>          </div><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>使用spring-boot-starter-security依赖项。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。</p><h4 id="使用Redis"><a href="#使用Redis" class="headerlink" title="使用Redis"></a>使用Redis</h4><p>高并发情况下的问题</p><span class="label label-primary">**缓存雪崩**</span><ul><li>现象：某些缓存在同一时间集体到期失效，便会有可能引发缓存雪崩。</li><li>解决：提前规划好所有缓存的到期时间避免集体失效、 定时刷新缓存、 设置缓存刷新标记</li></ul><span class="label label-primary">**缓存穿透**</span><ul><li>现象：越过redis直接访问数据库。从DB查询结果为null时有可能会发生。</li><li>解决：为null的结果赋予一个默认值、布隆过滤器</li></ul><span class="label label-primary">**缓存击倒**</span><ul><li>现象：海量请求短时间内查询一个热点Key，直接服务器宕机</li><li>解决：请求端的负载均衡，数据端的分表算法</li></ul><span class="label label-primary">**热点缓存**</span><ul><li>现象：大量请求查询一个热点Key，此key过期的瞬间来不及更新，导致大量请求直接访问数据库</li><li>解决：双重检测锁</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 双重检测锁伪代码</span>BoundValueOperations&lt;Object,Object&gt; ops = redisTemplate.boundValueOps(<span class="hljs-string">&quot;count&quot;</span>);Object count = ops.get();<span class="hljs-keyword">if</span>(count == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// 让2,3,4卡在这，等待一号存入redis，然后就不用再查数据库，直接命中redis了</span>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;        <span class="hljs-keyword">if</span>(count == <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-comment">//查询DB</span>          count = dao.getValue();          <span class="hljs-comment">//存入redis</span>          ops.set(count, <span class="hljs-number">10</span>, TimeUnit.SECONDS);        &#125;    &#125;&#125; <span class="hljs-keyword">return</span> count;</code></pre><p>一看到双重检测锁，还是要想到线程安全性的。建议回看java专题多线程知识。</p><p>但是这里不会出现线程安全，首先count是一个成员变量</p><h3 id="3-4-springboot-WEB开发"><a href="#3-4-springboot-WEB开发" class="headerlink" title="3.4 springboot WEB开发"></a>3.4 springboot WEB开发</h3><h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4><h3 id="3-5-springboot-数据访问"><a href="#3-5-springboot-数据访问" class="headerlink" title="3.5 springboot 数据访问"></a>3.5 springboot 数据访问</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul><li>编程式事务管理</li><li>声明式事务管理</li></ul><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p><ul><li>**<code>PlatformTransactionManager</code>**： （平台）事务管理器，Spring 事务策略的核心。</li></ul><p>Spring 并不直接管理事务，而是提供了多种事务管理器。通过这个接口，Spring 为各个平台如 JDBC(<code>DataSourceTransactionManager</code>)、Hibernate(<code>HibernateTransactionManager</code>)、JPA(<code>JpaTransactionManager</code>)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><ul><li>**<code>TransactionDefinition</code>**： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li></ul><p><img src="/img/transactionDefinition.png"></p><ul><li>**<code>TransactionStatus</code>**： 事务运行状态。</li></ul><p><code>TransactionStatus</code>接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。</p><p><code>PlatformTransactionManager.getTransaction(…)</code>方法返回一个 <code>TransactionStatus</code> 对象。</p><p><strong>事务属性详解</strong></p><p>传播行为</p><p>隔离级别</p><p>超时属性</p><p>只读属性</p><p>回滚规则</p><p><strong><code>@Transactional</code> 事务注解原理</strong></p><p><code>@Transactional</code> 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。</p><p>如果一个类或者一个类中的 public 方法上被标注<code>@Transactional</code> 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被<code>@Transactional</code> 注解的 public 方法的时候，实际调用的是，<code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p><p><strong>@Transactional失效场景</strong></p><p>①非public方法</p><p>② rollbackFor 设置错误</p><p>③同一个类中方法调用，导致@Transactional失效</p><p>其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</p><p>④异常被你的 catch“吃了”导致@Transactional失效</p><p>⑤@Transactional 注解属性 propagation 设置错误</p><h2 id="四、SpringBatch"><a href="#四、SpringBatch" class="headerlink" title="四、SpringBatch"></a>四、SpringBatch</h2><p>SpringBatch是处理大量数据的批处理框架</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><style>  /* 只设置  note字体 */  .note {    font-family: "Microsoft YaHei",Georgia, sans, serif, KaiTi,;    font-size: 14px;  }</style><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Spring结构 <a href="https://blog.csdn.net/ThinkWon/article/details/102810819">https://blog.csdn.net/ThinkWon/article/details/102810819</a><p><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Spring基础教程 <a href="https://www.w3cschool.cn/wkspring/1h9m1h9m.html">https://www.w3cschool.cn/wkspring/1h9m1h9m.html</a><br><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>@Resource @Inject @Autowired <a href="https://www.cnblogs.com/pjfmeng/p/7551340.html">https://www.cnblogs.com/pjfmeng/p/7551340.html</a><br><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>依赖注入 <a href="https://blog.csdn.net/programmer_at/article/details/82389221">https://blog.csdn.net/programmer_at/article/details/82389221</a><br><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>很简洁的依赖注入 <a href="https://www.rainng.com/field-injection-is-not-recommend/">https://www.rainng.com/field-injection-is-not-recommend/</a><br><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>Redis <a href="https://blog.csdn.net/hanchao5272/article/details/99706189">https://blog.csdn.net/hanchao5272/article/details/99706189</a><br><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>javaguide spring综合 <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93</a><br><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>过滤器和拦截器 <a href="https://blog.csdn.net/heweimingming/article/details/79993591">https://blog.csdn.net/heweimingming/article/details/79993591</a><br><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2020/11/01/mysql/"/>
    <url>/2020/11/01/mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL——基础篇"><a href="#MySQL——基础篇" class="headerlink" title="MySQL——基础篇"></a>MySQL——基础篇</h1><h2 id="一、MySQL数据类型"><a href="#一、MySQL数据类型" class="headerlink" title="一、MySQL数据类型"></a>一、MySQL数据类型</h2><h3 id="INT类型"><a href="#INT类型" class="headerlink" title="INT类型"></a>INT类型</h3><table><thead><tr><th><strong>类型</strong></th><th></th><th><strong>字节</strong></th><th><strong>最小值</strong></th><th><strong>最大值</strong></th></tr></thead><tbody><tr><td></td><td></td><td></td><td><strong>（带符号的/无符号的）</strong></td><td><strong>(带符号的/无符号的)</strong></td></tr><tr><td>TINYINT</td><td></td><td>1</td><td>-128    2^7</td><td>127</td></tr><tr><td></td><td></td><td></td><td>0</td><td>255</td></tr><tr><td>SMALLINT</td><td></td><td>2</td><td>-32768    2^15</td><td>32767</td></tr><tr><td></td><td></td><td></td><td>0</td><td>65535</td></tr><tr><td>MEDIUMINT</td><td></td><td>3</td><td>-8388608   2^23</td><td>8388607</td></tr><tr><td></td><td></td><td></td><td>0</td><td>16777215</td></tr><tr><td>INT</td><td></td><td>4</td><td>-2147483648    2^31</td><td>2147483647</td></tr><tr><td></td><td></td><td></td><td>0</td><td>4294967295</td></tr><tr><td>BIGINT</td><td></td><td>8</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td></td><td></td><td></td><td>0</td><td>18446744073709551615</td></tr></tbody></table><div class="note note-warning">            <p>unsigned 无符号最小值是0.  在用select a-b类似语句时，若目标字段为无符号，计算值为负则会报错</p>          </div><div class="note note-warning">            <p>int(N)不代表长度上限。而是代表显示宽度。使用zerofill 代表&lt;N时用0填充左边，超过N则原样显示</p>          </div><ul><li><strong>int的常用场景：自增长</strong></li></ul><p>MySQL 每张表只能有1个自增长字段，其可以作为主键，也可以不作为主键。<span class="label label-primary">非主键情况下必须显示添加唯一索引</span></p><span class="label label-success">自增字段：插入null或0结果是自己自增，负数也是可以插进去的。</span><div class="note note-danger">            <p><strong>面试题——自增长：</strong> </p><p>17之后删除15 16 17。再次插入数据，id是几？</p>          </div><div class="note note-success">            <p>回答：</p><p>mysql8.0之前  myisam：18    innodb(重启)：15     innodb(未重启)：18</p><p>mysql8.0之后   myisam：18   innodb：18</p>          </div><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><table><thead><tr><th>类型</th><th>说明</th><th>N的含义</th><th>是否有字符集</th><th>最大长度</th></tr></thead><tbody><tr><td>CHAR(N)</td><td>定长字符</td><td><strong>字符</strong></td><td>是</td><td>255</td></tr><tr><td>VARCHAR(N)</td><td>变长字符</td><td><strong>字符</strong></td><td>是</td><td>16384</td></tr><tr><td>BINARY(N)</td><td>定长二进制字节</td><td>字节</td><td>否</td><td>255</td></tr><tr><td>VARBINARY(N)</td><td>变长二进制字节</td><td>字节</td><td>否</td><td>16384</td></tr><tr><td>TINYBLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>256</td></tr><tr><td>BLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>16K</td></tr><tr><td>MEDIUMBLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>16M</td></tr><tr><td>LONGBLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>4G</td></tr><tr><td>TINYTEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>256</td></tr><tr><td>TEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>16K</td></tr><tr><td>MEDIUMTEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>16M</td></tr><tr><td>LONGTEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>4G</td></tr></tbody></table><ul><li><strong>字符类型小tip：排序规则</strong></li></ul><p>我们会看到在创建表的时候，字符集有这样两种：<span class="label label-primary">bin</span>、<span class="label label-default">ci</span></p><span class="label label-primary">bin</span>指使用二进制形式，会区分大小写。<div class="note note-danger">            <p>面试题——字符集：select ‘a’ = ‘A’ 的执行结果</p>          </div><div class="note note-success">            <p>回答：</p><p>使用bin时，执行结果为0</p><p>使用ci时，执行结果为1</p>          </div><h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h3><table><thead><tr><th>日期类型</th><th>占用空间</th><th>表示范围</th></tr></thead><tbody><tr><td>DATETIME</td><td>8</td><td>1000-01-01  00:00:00 ~ 9999-12-31 23:59:59</td></tr><tr><td>DATE</td><td>3</td><td>1000-01-01  ~ 9999-12-31</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01  00:00:00UTC ~ 2038-01-19 03:14:07UTC</td></tr><tr><td>YEAR</td><td>1</td><td>YEAR(2):1970-2070,  YEAR(4):1901-2155</td></tr><tr><td>TIME</td><td>3</td><td>-838:59:59  ~ 838:59:59</td></tr></tbody></table><p>需要注意的是<span class="label label-primary">DATETIME</span>、<span class="label label-default">TIMESTAMP</span>这两者存在时区上的区分。TIMESTAMP 能通过以下命令查看和设置时区：</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @@<span class="hljs-keyword">time_zone</span>;<span class="hljs-keyword">set</span> <span class="hljs-keyword">time_zone</span>=<span class="hljs-string">&#x27;+00:00&#x27;</span>;</code></pre><h3 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h3><p>json_extract  抽取</p><pre><code class="hljs stylus">select<span class="hljs-function"><span class="hljs-title">json_extract</span><span class="hljs-params">(data, <span class="hljs-string">&#x27;$.name&#x27;</span>)</span></span>,<span class="hljs-function"><span class="hljs-title">json_extract</span><span class="hljs-params">(data, <span class="hljs-string">&#x27;$.address&#x27;</span>)</span></span></code></pre><p> JSON_OBJECT  将对象转为 json</p><pre><code class="hljs pgsql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> json_user <span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>,json_object(&quot;name&quot;, &quot;enjoy&quot;, &quot;email&quot;, &quot;enjoy.com&quot;, &quot;age&quot;,<span class="hljs-number">35</span>) )</code></pre><p> json_insert 增加json结构 </p><pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-keyword">json</span> = <span class="hljs-string">&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3]&#125;&#x27;</span>;<span class="hljs-keyword">select</span> json_insert(@<span class="hljs-keyword">json</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;$.c&#x27;</span>, <span class="hljs-string">&#x27;[true, false]&#x27;</span>);<span class="hljs-keyword">update</span> json_user <span class="hljs-keyword">set</span> <span class="hljs-keyword">data</span> = json_insert(<span class="hljs-keyword">data</span>, <span class="hljs-string">&quot;$.address_2&quot;</span>, <span class="hljs-string">&quot;xiangxue&quot;</span>) <span class="hljs-keyword">where</span> uid = <span class="hljs-number">1</span>;</code></pre><p>json_merge 合并json结构</p><p>JSON_UNQUOTE  取消引用JSON值，并将结果作为<code>utf8mb4</code>字符串返回</p><pre><code class="hljs less"><span class="hljs-selector-tag">select</span> <span class="hljs-selector-tag">JSON_UNQUOTE</span>(json_extract(<span class="hljs-variable">@json</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>));</code></pre><h2 id="二、MySQL架构"><a href="#二、MySQL架构" class="headerlink" title="二、MySQL架构"></a>二、MySQL架构</h2><p>MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<span class="label label-primary">插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</span>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><p><img src="/img/mysqljiagoutu.png"></p><h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、身份认证、权限验证的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。</p><ul><li><strong>cache&amp;buffer</strong></li></ul><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%query_cache_type%&#x27;</span> <span class="hljs-comment">-- 默认不开启</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%query_cache_size%&#x27;</span> <span class="hljs-comment">--默认值 1M</span></code></pre><p>业务中并不推荐用cache，所以他也是默认关闭的。原因如下：</p><p>①浪费内存</p><p>②innodb有buffer提供类似功能</p><p>③太严格了！需要查询语句完全一致，包括字符集，那为啥不用redis呢？</p><ul><li><strong>Parser解析器</strong></li></ul><p><img src="/img/mysqljiexiqi.png"></p><ul><li><strong>Optimizer优化器</strong></li></ul><pre><code class="hljs csharp"><span class="hljs-keyword">where</span> <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  &gt;&gt;&gt;  不使用<span class="hljs-keyword">where</span><span class="hljs-keyword">where</span> 主键 <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>   &gt;&gt;&gt;  impossible key<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> account t <span class="hljs-keyword">where</span> t.<span class="hljs-function">id <span class="hljs-title">in</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> t2.id <span class="hljs-keyword">from</span> account t2</span>)   子查询   &gt;&gt;&gt;  关联查询</span></code></pre><h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</p><h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。</p><h2 id="三、MySQL存储引擎"><a href="#三、MySQL存储引擎" class="headerlink" title="三、MySQL存储引擎"></a>三、MySQL存储引擎</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 物理文件结构为：</p><span class="label label-primary">.frm</span> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等<span class="label label-danger">.MYD</span> (MYData) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据<span class="label label-danger">.MYI</span>  (MYIndex)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息<div class="note note-warning">            <p>myisam压缩后insert操作失效</p>          </div><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 物理文件结构为：</p><span class="label label-primary">.frm</span> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等<span class="label label-danger">.ibd</span> 文件或 <span class="label label-danger">.ibdata</span> 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。<p>独享表空间存储方式使用.ibd文件，并且每个表一个.ibd文件</p><p>共享表空间存储方式使用.ibdata文件，所有表共同使用一个.ibdata文件（或多个，可自己配置）</p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><strong>索引文件和数据文件是否分开</strong>。（关于两者在索引上的具体实现方式的解析在下面索引知识点详细解读）</p><p>①InnoDB 支持事务，MyISAM 不支持事务</p><p>②InnoDB 支持外键，而 MyISAM 不支持。</p><p>③InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p><p>④InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p><p>⑤InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。MyISAM并发性不好。</p><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><ol><li>以 csv 格式进行数据存储</li><li>所有列都不能为 null 的</li><li>不支持索引（不适合大表，不适合在线处理）</li><li>可以对数据文件直接编辑（保存文本文件内容</li></ol><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>文件系统存储特点，也称 HEAP 存储引擎，所以数据保存在内存中</p><ol><li>支持 HASH 索引(默认)和 BTree 索引</li><li>所有字段都是固定长度 varchar(10) = char(10)</li><li>不支持 Blog 和 Text 等大字段</li><li>Memory 存储引擎只能使用<strong>表级锁</strong></li><li>最大大小由 max_heap_table_size 参数决定</li></ol><ul><li><strong>Memory使用场景</strong></li></ul><ol><li>hash 索引用于查找或者是映射表（邮编和地区的对应表）</li><li>用于保存数据分析中产生的中间表</li><li>用于缓存周期性聚合数据的结果表</li></ol><h3 id="Ferderated"><a href="#Ferderated" class="headerlink" title="Ferderated"></a>Ferderated</h3><p>提供了访问远程 MySQL 服务器上表的方法</p><ol><li>本地不存储数据，数据全部放到远程服务器上</li><li>本地需要保存表结构和远程服务器的连接信息</li></ol><ul><li><strong>Ferderated使用场景</strong></li></ul><p>偶尔的统计分析及手工查询（某些游戏行业）</p><h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><span class="label label-primary">索引是帮助MySQL高效获取数据的数据结构。</span><p>在关系型数据库中，索引存储在硬盘中。</p><p><strong>基本语法：</strong></p><p>创建：</p><ul><li><p>创建索引：<code>CREATE [UNIQUE] INDEX indexName ON mytable(username(length));</code></p><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p></li><li><p>修改表结构(添加索引)：<code>ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)</code></p></li><li><p>删除：<code>DROP INDEX [indexName] ON mytable;</code></p></li><li><p>查看：<code>SHOW INDEX FROM table_name\G</code>             –可以通过添加 \G 来格式化输出信息。</p></li></ul><p>使用ALERT命令</p><ul><li><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</code> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li><li><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list</code> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li><li><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code> 添加普通索引，索引值可出现多次。</li><li><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code>该语句指定了索引为 FULLTEXT ，用于全文索引。</li></ul><p><strong>优劣势分析</strong></p><span class="label label-success">优势</span><ul><li>提高数据检索效率，降低数据库IO成本</li><li>降低数据排序的成本，降低CPU的消耗</li></ul><span class="label label-danger">劣势</span><ul><li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</li></ul><h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><p><strong>索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），<strong>将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置</strong>；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p><p>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</p><p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p><div class="note note-danger">            <p><strong>面试题——索引：</strong> Innodb为啥不用hash索引</p>          </div><div class="note note-success">            <p>①hash索引存储在内存中，数据量较多的情况下很明显不合适</p><p>②范围查找不支持。因为hash索引是一种键值查找方式。而b+tree作为多路查找平衡树，是天然有序的，很适合做范围查询。</p><p>③哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>          </div><h4 id="Btree"><a href="#Btree" class="headerlink" title="Btree"></a>Btree</h4><p>在了解btree前，让我们来复习这样一连串的概念，来证明为什么b树是最适合的数据结构。（一些复杂的图解我将开设一个树相关的博客）</p><span class="label label-info">**二叉查找树**</span><p>随着id递增，会逐渐变成一个单边树，很明显不是一个合适的作为索引的数据结构</p><span class="label label-info">**平衡二叉查找树 AVL**</span><p>AVL树，本质上是带了平衡功能的二叉查找树。</p><p>在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为<strong>高度平衡树</strong>。增加和删除可能需要通过一次或多次<a href="https://baike.baidu.com/item/%E6%A0%91%E6%97%8B%E8%BD%AC">树旋转</a>来重新平衡这个树。</p><p>问题是AVL的大量的自平衡导致IO次数过多，形成IO浪费，很明显也不是一个合适的方案</p><span class="label label-info">**B树**</span> <p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树</p><ul><li><strong>规则</strong></li></ul><span class="label label-info">关键字的个数n满足：ceil(m/2)-1 <= n <= m-1</span><span class="label label-info">非叶节点的子节点数>1，且<=M</span><span class="label label-info">节点位于同一水平线</span><p><img src="/img/btree1.png"></p><ul><li><strong>特点</strong></li></ul><p>B树的优势在于每个节点包含的关键字增多了，充分利用了磁盘块的原理，减少数据查找的次数。</p><span class="label label-primary">磁盘块原理：系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来</span><p>InnoDB 存储引擎使用页（Page）作为存储单位，页是磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></p><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。</p><h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B+tree"></a>B+tree</h4><p>B树每个节点中不仅包含数据的key值，还有data值。data变大 -&gt; 每页能存储的key的数量变小 -&gt; B-Tree的深度较大，增大查询时的磁盘I/O次数</p><span class="label label-danger">最最消耗时间的操作就是磁盘IO：从磁盘读到内存</span><p>因此B+树舍弃了非叶子结点的data数据，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定。</p><ul><li><strong>规则</strong></li></ul><p>（1）B+跟B树不同的是，B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p><p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p><p>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p><p>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p><p><img src="/img/b+tree1.png"></p><div class="note note-danger">            <p><strong>面试题——Btree：</strong>B+tree和Btree的不同点</p>          </div><div class="note note-success">            <p>①B+tree数据只存储在叶子节点上，非叶子节点只保存索引信息</p><p>②叶子节点本身按照数据的升序排序进行链接 （物理存储上无序）</p>          </div><ul><li><strong>特点</strong></li></ul><p>1、B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;符合日常业务场景</p><p>3、B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p><p>4、B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><h4 id="B-Tree的分裂与合并"><a href="#B-Tree的分裂与合并" class="headerlink" title="B+Tree的分裂与合并"></a>B+Tree的分裂与合并</h4><h4 id="B-Tree落地mysql"><a href="#B-Tree落地mysql" class="headerlink" title="B+Tree落地mysql"></a>B+Tree落地mysql</h4><p><strong>Myisam</strong></p><ul><li><strong>物理存储</strong></li></ul><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”<strong>非聚簇索引</strong>“。</p><ul><li><strong>索引流程</strong></li></ul><p>先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p><p><img src="/img/myasim_suoyin.png"></p><p><strong>InnoDB</strong></p><ul><li><strong>物理存储</strong></li></ul><p>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录。<span class="label label-primary">主键索引存放表中所有的数据记录</span><span class="label label-info">辅助索引存放主键，检索的时候通过主键到主键索引中找到对应数据行</span></p><p>InnoDB的数据文件本身就是主键索引文件，这样的索引被称为”“聚簇索引”，一个表只能有一个聚簇索引。</p><ul><li><strong>索引流程</strong></li></ul><p><strong>主键索引</strong></p><p>数据的物理顺序与主键顺序一致； 叶子结点存放所有数据；  非叶子结点存放主键值</p><p>命中主键即取到数据</p><p><img src="/img/innodb_suoyin.jpg"></p><p><strong>二级索引</strong></p><p>叶子结点存放主键值；非叶子结点存放二级索引值</p><p>命中二级索引值 –&gt; 取得主键 –&gt; 命中主键索引对应项 –&gt; 取得数据</p><p>这也就是所谓的“<strong>回表查询</strong>”</p><p><img src="/img/innodb_suoyin2.png"></p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a><strong>从物理存储角度</strong></h4><ul><li>聚集索引（clustered index）</li><li>非聚集索引（non-clustered index），也叫辅助索引（secondary index</li></ul><p><strong>聚簇索引</strong></p><p>聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。</p><p>一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。</p><p>在InnoDB引擎中，<strong>只有主键是聚集索引</strong>，其他的索引都是非聚集索引。</p><div class="note note-danger">            <p><strong>面试题——InnoDB聚簇索引：</strong></p><p>InnoDB 没有主键咋办？</p>          </div><div class="note note-success">            <p><strong>回答：</strong>如果表中没有主键或者一个合适的的唯一索引，InnoDB内部会以一个包含行ID值的合成列生成一个隐藏的聚簇索引。表中的行是按照InnoDB分配的ID排序的。行ID是一个6字节的字段，随着一个新行的插入单调增加。因此，行ID顺序物理上是插入顺序。</p><p>所有用ROW_ID列的表，共享同一个被保存在数据字典中的全局序列数。这就会导致竞争从而引起性能问题。</p>          </div><div class="note note-danger">            <p><strong>面试题——InnoDB聚簇索引</strong>：</p><p>InnoDB为什么推荐使用自增ID而不是UUID作为主键？</p>          </div><div class="note note-success">            <p><strong>回答：</strong></p><p>①UUID是字符串，比整型消耗更多的存储空间</p><p>②整型数据的比较运算比字符串更快速</p><p>③自增的整型索引在磁盘中会连续存储，查找关联性数据时更方便</p><p>④在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p><p>如何去理解这句话呢：</p><p>  InnoDB引擎使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放。因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>​    1、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</p><p>​    这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>​    2、 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>          </div><h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h4><ul><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li><li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li><li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>唯一索引或者非唯一索引</li><li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。 MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</li></ul><h3 id="索引的使用及三星索引"><a href="#索引的使用及三星索引" class="headerlink" title="索引的使用及三星索引"></a>索引的使用及三星索引</h3><h3 id="优化之索引下推"><a href="#优化之索引下推" class="headerlink" title="优化之索引下推"></a>优化之索引下推</h3><p>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。</p><p>• 在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p><p>• 在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p><p>• 索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p><p>主要目的就是<span class="label label-primary">减少IO次数</span></p><p>适用条件</p><p>​     ①需要整表扫描的情况。比如：range, ref, eq_ref, ref_or_null 。适用于InnoDB 引擎和 MyISAM 引擎的查询。（5.6版本不适用分区表查询，5.7版本后可以用于分区表查询）。</p><p>​     ②对于InnDB引擎只适用于二级索引，因为InnDB的聚簇索引会将整行数据读到InnDB的缓冲区，这样一来索引条件下推的主要目的减少IO次数就失去了意义。因为数据已经在内存中了，不再需要去读取了。</p><p>​     ③引用子查询的条件不能下推。</p><p>调用存储过程的条件不能下推，存储引擎无法调用位于MySQL服务器中的存储过程</p><h3 id="优化之MRR-顺序磁盘读"><a href="#优化之MRR-顺序磁盘读" class="headerlink" title="优化之MRR (顺序磁盘读)"></a>优化之MRR (顺序磁盘读)</h3><p>MRR，全称「Multi-Range Read Optimization」。</p><p>简单说：MRR 通过把「随机磁盘读」，转化为「顺序磁盘读」，从而提高了索引查询的性能。</p><p>对于 Myisam，在去磁盘获取完整数据之前，会先按照rowId排好序，再去顺序的读取磁盘。</p><p>对于 Innodb，则会<strong>按照聚簇索引键值排好序</strong>，再顺序的读取聚簇索引。</p><p>顺序读带来了几个好处：</p><p>1、磁盘和磁头不再需要来回做机械运动；</p><p>2、可以充分利用磁盘预读（局部性原理）</p><p>3、在一次查询中，每一页的数据只会从磁盘读取一次</p><p><strong>索引本身就是为了减少磁盘 IO，加快查询，而MRR，则是把索引减少磁盘 IO 的作用，进一步放大。</strong></p><p>MRR在本质上是一种用空间换时间的算法。MySQL 不可能给你无限的内存来进行排序</p><h3 id="优化之缓冲池"><a href="#优化之缓冲池" class="headerlink" title="优化之缓冲池"></a>优化之缓冲池</h3><h4 id="缓冲池-buffer-pool"><a href="#缓冲池-buffer-pool" class="headerlink" title="缓冲池 buffer pool"></a>缓冲池 buffer pool</h4><p>缓冲池(buffer pool)是一种<strong>常见的减少磁盘IO的机制；</strong></p><ul><li><p><strong>算法</strong></p><p>mysql使用了一种改进版的LRU算法(类似队列，实现是链表，后进后出)。原因有二：</p><p>①预读未读   提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据</p><p>②缓冲池污染   批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去</p><p><strong>针对预读未读</strong>，Mysql将LRU分为两个部分：</p><ul><li>新生代(new sublist)</li><li>老生代(old sublist)</li><li>新老生代收尾相连</li><li>新页加入缓冲池时，只加入到老生代头部。数据真正被读取，才会加入到新生代的头部</li></ul><p>下图为新预读page50的例图，50被加入老生代head</p><p><img src="/img/LRU.png"></p></li></ul><p>​        当其被成功读取后，加入新生代</p><p><img src="/img/LRU2.png"></p><p>​        <strong>针对缓冲池污染</strong>，MySQL缓冲池加入了一个“老生代停留时间窗口”的机制：</p><p>​        假设T=老生代停留时间窗口；</p><p>​        插入老生代头部的页，即使立刻被访问，并不会立刻放入新生代头部；</p><p>​        只有<strong>满足</strong>“被访问”并且“在老生代停留时间”大于T，才会被放入新生代头部；</p><h4 id="读缓冲"><a href="#读缓冲" class="headerlink" title="读缓冲"></a>读缓冲</h4><ul><li><strong>概念</strong></li></ul><p>对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。</p><p>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p><p>所以在这里你感觉用唯一性索引会快一些，毕竟少了一个步骤。但是这个不同带来的性能差距微乎其微。</p><p>你知道的，InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。</p><p>因为引擎是按页读写的，所以说，当找到符合条件的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。 </p><p>当然也会有特殊情况，就是符合条件的记录正好处于数据页的最后一个，那往下查找的操作就会拿下一个数据页放进内存，这个时候就会慢了，但是一个整型字段，一个数据页可以放进千的key，所以这个概率很低。</p><pre><code class="hljs gauss"><span class="hljs-built_in">select</span> <span class="hljs-comment">@@</span>innodb_buffer_pool_size <span class="hljs-comment">//查询缓冲池大小</span></code></pre><h4 id="写缓冲"><a href="#写缓冲" class="headerlink" title="写缓冲"></a>写缓冲</h4><ul><li><strong>概念</strong></li></ul><p>这里就有个重要概念叫<span class="label label-primary">Change buffer</span></p><p>在MySQL5.5之前，叫插入缓冲(insert buffer)，只针对insert做了优化；现在对delete和update也有效，叫做写缓冲(change buffer)。</p><p>它是一种应用在<strong>非唯一普通索引页</strong>(non-unique secondary index page)不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更(buffer changes)，等未来数据被读取时，再将数据合并(merge)恢复到缓冲池中的技术。写缓冲的<strong>目的</strong>是<strong>降低写操作的磁盘IO，提升数据库性能。</strong></p><ul><li><strong>过程分析</strong></li></ul><p>第一种情况：目标数据页在内存中。</p><p>（1）直接修改缓冲池中的页，一次内存操作；</p><p>（2）写入redo log，一次磁盘顺序写操作；</p><p>第二种情况是：目标数据页不在内存中</p><p>（1）先把需要为40的索引页，从磁盘加载到缓冲池，一次磁盘随机读操作；</p><p>（2）修改缓冲池中的页，一次内存操作；</p><p>（3）写入redo log，一次磁盘顺序写操作；</p><span class="label label-primary">那么对于第二种情况还有优化空间吗？我们可以节省出这次磁盘IO吗？</span><p>加入写缓冲后：</p><p>（1）在写缓冲中记录这个操作，一次内存操作；</p><p>（2）写入redo log，一次磁盘顺序写操作；</p><p>当下次需要访问这个数据页的时候，将数据页放入内存，然后执行 change buffer 中与这个页有关的操作。</p><p><strong>因此，写缓冲减少了磁盘IO，减少内存占用，提升内存利用率</strong></p><p>另外，需要注意的是，<span class="label label-warning">写缓冲优化仅适用于非唯一普通索引页</span></p><span class="label label-info">唯一索引的更新操作之前都要判断唯一性，所以在判断这步已经把数据页放在了内存里</span><span class="label label-primary">除了数据页被访问，还有哪些操作会触发缓冲刷写(merge)呢？</span><p>（1）有一个后台线程，会认为数据库空闲时</p><p>（2）数据库缓冲池不够用时</p><p>（3）数据库正常关闭时</p><p>（4）redo log写满时</p><pre><code class="hljs gauss"><span class="hljs-built_in">select</span> <span class="hljs-comment">@@</span>innodb_change_buffering <span class="hljs-comment">//查询哪些操作开启了写缓冲</span><span class="hljs-built_in">select</span> <span class="hljs-comment">@@</span>innodb_change_buffer_max_size  <span class="hljs-comment">//查询change buffer占用buffer pool 的比例</span></code></pre><ul><li><strong>应用场景</strong></li></ul><p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p><p>由此看来就是对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>所以反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p><p>在实际使用中，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。对于一些历史记录表可以考虑使用普通索引</p><h2 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul><li>原子性</li></ul><p>一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败</p><ul><li>一致性</li></ul><p>将数据库从一种一致性转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏</p><ul><li>隔离性</li></ul><p>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><ul><li>持久性</li></ul><p>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失</p><h3 id="三类事务问题"><a href="#三类事务问题" class="headerlink" title="三类事务问题"></a>三类事务问题</h3><ul><li><strong>脏读</strong></li></ul><p>A事务中的读操作可能读到另一个事务中未提交修改的数据，如果事务发生回滚就可能造成错误。</p><p><em>dirty read</em></p><p><em>An operation that retrieves unreliable data, data that was updated by another transaction but not yet committed. It is only possible with the isolation level known as read uncommitted.</em></p><p><em>This kind of operation does not adhere to the ACID principle of database design. It is considered very risky, because the data could be rolled back, or updated further before being committed; then, the transaction doing the dirty read would be using data that was never confirmed as accurate.</em></p><p><em>Its opposite is consistent read, where InnoDB ensures that a transaction does not read information updated by another transaction, even if the other transaction commits in the meantime.</em></p><ul><li><strong>不可重复读</strong></li></ul><p>事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。</p><p><em>non-repeatable read</em></p><p><em>The situation when a query retrieves data, and a later query within the same transaction retrieves what should be the same data, but the queries return different results (changed by another transaction committing in the meantime).</em></p><p><em>This kind of operation goes against the ACID principle of database design. Within a transaction, data should be consistent, with predictable and stable relationships.</em></p><p><em>Among different isolation levels, non-repeatable reads are prevented by the serializable read and repeatable read levels, and allowed by the consistent read, and read uncommitted levels.</em></p><ul><li><strong>幻读</strong></li></ul><p>如果一个查询在一个事务中运行两次，与此同时，另一个事务将在插入新行后提交 或更新一行，使其与查询的WHERE子句匹配。这种情况被称为幻像读取，比不可重复读取更难防范，因为锁定第一个查询结果集中的所有行并不能阻止导致幻像出现的更改。</p><p><em>phantom</em></p><p><em>A row that appears in the result set of a query, but not in the result set of an earlier query. For example, if a query is run twice within a transaction, and in the meantime, another transaction commits after inserting a new row or updating a row so that it matches the WHERE clause of the query.</em></p><p><em>This occurrence is known as a phantom read. It is harder to guard against than a non-repeatable read, because locking all the rows from the first query result set does not prevent the changes that cause the phantom to appear.</em></p><p><em>Among different isolation levels, phantom reads are prevented by the serializable read level, and allowed by the repeatable read, consistent read, and read uncommitted levels.</em></p><div class="note note-primary">            <p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。</p><p>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>          </div><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><img src="/img/mysqlgelijibie.png"></p><div class="note note-primary">            <p>但是mysql在RR上通过间隙锁解决了幻读问题</p>          </div><div class="note note-danger">            <p><strong>面试题——事务隔离级别</strong>：那么Mysql通过什么完成了RR事务隔离级别，解决了脏读、不可重复读、幻读这些问题的呢？</p>          </div><div class="note note-success">            <p><strong>回答</strong>：MVCC + LBCC</p>          </div><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><ul><li>MVCC (Multi-Version Concurrency Control)  基于多版本的并发控制协议</li><li>LBCC(Lock-Based Concurrency Control) 基于锁的并发控制</li></ul><p>MVCC是一种概念，其核心理念就是<strong>数据快照</strong>。Innodb实现了这样一个概念，并借此一定程度上解决了脏读，幻读，不可重复读等事务隔离问题</p><p><strong>MVCC 最大特性：读不加锁，读写不冲突</strong></p><p>在MVCC并发控制中，读操作可以分成两类：<strong>快照读 (snapshot read)**与</strong>当前读 (current read)**。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><p>对于MySQL InnoDB来说：</p><ul><li>快照读：简单的select操作，属于快照读，不加锁。快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</li><li>当前读：特殊的读操作(加读锁)，插入/更新/删除操作，属于当前读，需要加锁。</li></ul><p><strong>当前读</strong>：</p><p><img src="/img/MVCC1.png"></p><p>从图中，可以看到，一个Update操作的具体流程：</p><ul><li>（1）当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。</li><li>（2）待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。</li><li>（3）一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</li><li>（4）根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的， 因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操 作；然后在读取下一条加锁，直至读取完毕。</li></ul><p><strong>一致性非锁定读</strong>：</p><p>InnoDB采用一致性非锁定读的机制，不需要等待行上排他锁的释放，而是采取读取快照数据。快照数据是指该行的之前版本的数据，每行记录可能有多个版本。</p><p><strong>InnoDB中MVCC的实现原理</strong></p><p>它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。</p><ul><li><strong>隐式字段</strong></li></ul><span class="label label-primary">DB_TRX_ID</span><p> 6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</p><span class="label label-primary">DB_ROLL_PTR</span><p> 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p><span class="label label-primary">DB_ROW_ID</span><p> 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</p><p>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</p><p><img src="/img/MVCC2.png"></p><ul><li><strong>undolog</strong></li></ul><p>insert undo log<br> 代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p>update undo log<br> 事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p><div class="note note-danger">            <p>更新或删除操作真正把旧数据删除了吗？</p>          </div><div class="note note-success">            <p>为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。</p><p>为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</p>          </div><p>undo log是一个记录历史版本的链式结构。如下图。</p><p><img src="/img/MVCC3.png"></p><p>事务1对该记录的name做出了修改，改为Tom</p><ol><li>在事务1修改该行(记录)数据时，数据库会先对该行加排他锁</li><li>然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本</li><li>拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它</li><li>事务提交后，释放锁</li></ol><p><img src="/img/MVCC4.png"></p><p>事务2修改person表的同一个记录，将age修改为30岁</p><ol><li>在事务2修改该行数据时，数据库也先为该行加锁</li><li>然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</li><li>修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录</li><li>事务提交，释放锁</li></ol><p><img src="/img/MVCC5.png"></p><ul><li><strong>Read View</strong></li></ul><p>Read View就是事务进行快照读操作的时候生产的读视图。在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，<strong>第一次真正修改记录时</strong>都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p><p>Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>Read View遵循一个可见性算法：</p><ol><li>Read View维护全局属性：活跃事务ID列表、最小活跃事务ID、已知最大事务ID</li><li>if 数据最新事务ID &lt; 最小活跃事务ID 或者数据最新事务ID即为当前事务， 则能直接看到最新数据，否则进入下一个判断</li><li>if 数据最新事务ID &gt;= 已知最大事务ID， 证明此数据的最新更新事务在当前事务之后出现，无法看到的最新数据，那么只能查看其历史版本，否则进入下一个判断</li><li>if 数据最新事务ID 在 活跃事务ID列表中，则看不到此最新数据，那么只能查看其历史版本，如果不在，说明是个已经commit的事务，则能看到最新数据</li></ol><div class="note note-danger">            <p>RR 和 RC 快照读的区别</p>          </div><div class="note note-success">            <p>生成 ReadView 的时机不同， RC 在每一次进行普通 SELECT 操作前都会生成一个 ReadView ，而 RR只在第一次进行普通 SELECT 操作前生成一个 ReadView ，之后的查询操作都重复这个 ReadView。</p>          </div><h3 id="事务知识点总结"><a href="#事务知识点总结" class="headerlink" title="事务知识点总结"></a>事务知识点总结</h3><p>①事务隔离级别：RUC RC RR 串行</p><p>②事务的四大特性：ACID</p><p>③MVCC是一种多版本并发控制概念，它将读操作分为快照读和当前读，InnoDB依靠隐式字段、undolog、readview完成了快照读</p><p>④RR 和 RC 生成 ReadView 的时机不同</p><p>⑤事务的隔离性由MVCC和锁实现，而原子性，持久性和一致性主要是通过redo log、undolog和Force Log at Commit机制机制来完成的。</p><p>下图将缓冲、事务完美的展现了出来，值得一看</p><p><img src="/img/shiwu.png"></p><h2 id="六、锁"><a href="#六、锁" class="headerlink" title="六、锁"></a>六、锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><p>根据粒度分： 行锁 表锁 页锁</p><h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h3><ul><li><strong>共享读锁</strong> </li></ul><pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">read</span></code></pre><p>同一会话：写操作报错，<span class="label label-warning">其他表的读写操作也都会报错</span>，使用<span class="label label-primary">别名</span>的读操作也会报错</p><p>新开会话：不堵塞读操作，堵塞写操作，其他表的读写操作都能正常进行</p><ul><li><strong>独占写锁</strong></li></ul><pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">read</span></code></pre><p>同一会话：读写均OK，<span class="label label-warning">其他表的读写操作也都会报错</span></p><p>新开会话：堵塞读写</p><h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><p>InnoDB支持行锁，行锁不是字面意义上的锁住一行数据，<span class="label label-primary">行锁是通过给索引上的索引项加锁来实现的。</span>只有通过索引条件检索数据，InnoDB才使用行级锁。</p><p>同时<span class="label label-warning">两个事务不能锁同一个索引。</span></p><p>而当<span class="label label-danger">索引失效</span>时，行锁就变为了表锁。这里的表锁也不是字面意义的表锁，而是锁住了所有索引项，其效果等同于表锁罢了。</p><div class="note note-secondary">            <p>曾经有一次实验就出现了这样的问题：</p><p>因为where条件里对int的索引项强制类型转换成了string，导致了索引失效，因此行锁升级成了表锁，导致其他数据也无法进行更新。找了好久问题所在。</p>          </div><ul><li><strong>共享锁（S）</strong></li></ul><pre><code class="hljs sql">语法：<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表 <span class="hljs-keyword">where</span> 条件 <span class="hljs-keyword">lock</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">share</span> <span class="hljs-keyword">mode</span></code></pre><p>又名读锁，对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后才能进行。</p><ul><li><strong>排他锁（X）</strong></li></ul><pre><code class="hljs n1ql">语法：for <span class="hljs-keyword">update</span></code></pre><p>insert ，delete ， update在事务中都会<span class="label label-primary">自动默认加上排它锁</span></p><ul><li><strong>意向锁</strong></li></ul><p>InnoDB 支持<strong>多粒度锁</strong>（multiple granularity locking），它允许行级锁与表级锁共存</p><p>为实现表锁和行锁共存，引入了<strong>意向锁</strong></p><p>意向锁是由数据引擎自己维护的。对于同一张表，不同行的IX可以共存。意向锁之间是互相兼容的。</p><p>注意：这里的排他 / 共享锁指的都是表锁！！！意向锁不会与行级的共享 / 排他锁互斥！！</p><p><img src="https://img-blog.csdnimg.cn/20200930151134503.png" alt="img"></p><h4 id="InnoDB-的三种锁算法"><a href="#InnoDB-的三种锁算法" class="headerlink" title="InnoDB 的三种锁算法"></a>InnoDB 的三种锁算法</h4><ul><li><p><strong>记录锁</strong></p><p>用于等值查询，锁住单个索引项。其他事务不能修改和删除加锁项。</p></li></ul><ul><li><strong>间隙锁</strong></li></ul><p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p><p>对索引项之间的“间隙”加锁，锁定记录的范围（前一个间隙 +后一个间隙），不包含索引项本身。其他事务不能在锁范围内插入数据。因此，<strong>间隙锁解决了幻读问题</strong></p><span class="label label-warning">需要强调的是，间隙锁锁的不是索引项，而是索引项之间的间隙</span><span class="label label-warning">需要注意的是，间隙锁锁住的**区间**视数据而定，而非语句筛选条件而定。</span><ul><li><strong>临键锁</strong></li></ul><p><strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。</p><p>每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，<code>InnoDB</code> 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p><h3 id="加锁详细分析"><a href="#加锁详细分析" class="headerlink" title="加锁详细分析"></a>加锁详细分析</h3><p>了解加锁规则</p><ol><li>加锁的基本单位是（next-key lock）,他是前开后闭原则</li><li>查询过程中所有访问的对象会加锁</li><li>索引上的等值查询–给唯一索引加锁的时候，next-key lock升级为行锁</li><li>索引上的等值查询–向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁</li><li>唯一索引上的范围查询会访问到不满足条件的第一个值为止</li></ol><p>以下分析均基于<strong>RR隔离级别</strong></p><ul><li><strong>情况一：id为主键  + select</strong></li></ul><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">10</span>;</code></pre><p>快照读，不加锁</p><ul><li><strong>情况二：①id为主键  + delete/update + 等值查询</strong> </li></ul><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">10</span>;</code></pre><p><img src="/img/jiasuo1.jpg"></p><p>对索引项10加上排它锁</p><p> ②<strong>id为主键  + delete/update +等值查询未命中</strong></p><p>在7和20之间加入间隙锁，防止幻读</p><ul><li><strong>情况三：①id为唯一索引  + delete/update + 等值查询</strong></li></ul><p><img src="/img/jiasuo2.jpg"></p><p>此组合中，id是unique索引，而主键是name列。在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。</p><p>②<strong>id为唯一索引  + delete/update +等值查询未命中</strong></p><p>同样在前后索引项上间隙锁。但是为什么不在主键上也加 GAP 锁呢？</p><ul><li><strong>情况四：b为非唯一索引  + delete/update + 等值查询</strong></li></ul><p>准备以下数据：</p><p><img src="/img/jiasuo4.png"></p><p>其对应的索引结构展示如下</p><p><img src="/img/jiasuo5.png"></p><p>执行以下事务</p><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>；<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> z <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">6</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;</code></pre><span class="label label-info">思考：由于是非唯一索引，那么如果在中途加入很多b=6的数据，不就出现幻读了吗？</span><p>所以，非唯一索引往往需要用到<strong>临键锁/间隙锁来解决幻读问题</strong>。</p><p><img src="/img/b+tree_eg1.png"></p><p>由上图能看到初始状态时的b索引树结构。我们看看如果要再加一个6，树结构会变成怎样</p><p><img src="/img/b+tree_eg2.png"></p><p>很明显，要想防止幻读，避免再次插入6，光锁住6是没有用的，<strong>必须将能插入6的这个范围整个锁住</strong></p><p>因此要给索引 b 加上next-key lock (4, 6]；一直向右遍历直至遇到第一个不满足条件的值8，加入间隙锁(6,8)。自此，锁范围确定。</p><p>同时一个X锁会被加到所有满足b=6的索引项以及其对应的主键索引上，同情况3所示。<span class="label label-warning">而索引项4和8是没有被加X锁的。</span></p><p><img src="/img/jiasuo6.png"></p><div class="note note-info">            <p>为什么4和8明明进行了判断却没有被加X锁？</p><p>对等值匹配的条件有特殊处理，他们规定在InnoDB存储引擎层查找到当前记录的下一条记录时，在对其加锁前就直接判断该记录是否满足等值匹配的条件，如果不满足直接返回（也就是不加锁了），否则的话需要将其加锁后再返回给server层。所以这里也就不需要对下一条二级索引记录进行加锁了。</p>          </div><p>执行事务</p><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_lock <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>);</code></pre><p>新增(b=7,id=7)的索引，新增部分根据索引有序的规则，将会落在锁住的部分区间，所以会被阻塞。</p><p><img src="/img/jiasuo7.png"></p><span class="label label-info">但实际上这里7已经在主键里有了，所以这里其实就是直接报主键冲突了，而不是阻塞。嘿嘿。</span><p>继续执行事务</p><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> test_lock <span class="hljs-keyword">SET</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">6</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">8</span>;</code></pre><p>会将b索引上（b=8,id=8）叶子节点删掉，并增加(b=8,id=6)的叶子节点。可以看到(b=8,id=6)的叶子节点也落入锁住的部分区间，所以会被阻塞住。</p><p><img src="/img/jiasuo8.png"></p><p>同理。</p><span class="label label-success">UPDATE test_lock SET id = 20 WHERE b = 8; 成功</span><span class="label label-success">insert into test_lock values (6, 9); 成功</span><span class="label label-danger">insert into test_lock values (4, 4); 阻塞</span><span class="label label-success">insert into test_lock values (2, 4); 成功</span><span class="label label-danger">UPDATE test_lock SET b = 6 WHERE id = 1; 阻塞</span><p><strong>另外再通过一些有趣的实验，得到了以下结果，我们来研究一下</strong></p><pre><code class="hljs sql">//在事务一基础上<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_lock <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">6</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;//进行以下事务二操作：<span class="hljs-keyword">UPDATE</span> test_lock <span class="hljs-keyword">SET</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">20</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">8</span>;   //成功<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_lock <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">8</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;  //成功<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_lock <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">7</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;  //成功<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_lock <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">6</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;  //阻塞<span class="hljs-keyword">UPDATE</span> test_lock <span class="hljs-keyword">SET</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">5</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">8</span>;   //阻塞<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_lock <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>);  //直接报主键冲突</code></pre><p>我们可以把<span class="label label-danger">UPDATE test_lock SET id = 5 WHERE b = 8; 阻塞</span> 拆分成</p><span class="label label-success">SELECT * FROM test_lock WHERE b = 8 FOR UPDATE; 成功</span><span class="label label-success">delete from test_lock where b = 8; 成功</span><span class="label label-danger">insert into test_lock values (5, 8); 阻塞</span><p>所以说，间隙锁，锁的是范围不是索引项，你对相邻两索引项的当前读和删除操作肯定不会有问题，因为这并不会引起三类事务问题。所以在分析会不会被间隙锁所阻塞的时候。</p><p>而下面两个语句的对比</p><span class="label label-success">insert into test_lock values (7, 7); 不阻塞，报主键冲突</span><span class="label label-danger">insert into test_lock values (5, 8); 阻塞</span><span class="label label-success">insert into test_lock values (3, 6); 不阻塞，报主键冲突</span><span class="label label-danger">insert into test_lock values (4, 8); 阻塞</span><p>很明显，插入语句首先维护的是聚簇索引，当发现主键冲突就会报错。然后在维护二级索引时，才会判断是否落入间隙锁。而(5,8)之所以是阻塞，是因为聚簇索引的5是加上排它锁了，因为事务一在对其进行当前读，自然为了防止事务问题，就得加上排它锁，所以首先触发的是锁冲突，阻塞。</p><ul><li><strong>情况五：id为主键  + delete/update + 范围查询</strong></li></ul><p>id数据：10 11 13 20 40</p><p><strong>①执行以下事务。</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &lt;= <span class="hljs-number">13</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><span class="label label-danger">insert into test_lock2 values(12); 阻塞</span><span class="label label-danger">insert into test_lock2 values(13); 阻塞</span><span class="label label-success">insert into test_lock2 values(19); 成功</span><span class="label label-success">insert into test_lock2 values(21); 成功</span><p>关于第三条id为19的记录，<span class="label label-warning">在mysql5.6版本上似乎是阻塞。</span></p><p>网上的给的解释是在判断20是否满足&lt;=13这个条件时为加上锁，如果不满足，则会解锁。因此事务2进行时(13，20)实际上没有锁的。</p><div class="note note-info">            <p>聚簇索引不需要到server层再进行条件过滤。</p><p>每从聚簇索引中取出一条记录时都要判断一下该记录是否符合范围查询的边界条件，也就是number &lt;= 8这个条件。如果符合的话将其返回给server层继续处理，否则的话需要<strong>释放掉在该记录上加的锁</strong></p>          </div><p><strong>②执行以下事务</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&lt;<span class="hljs-number">13</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住(-,13)的区间</p><p><strong>③执行以下事务</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住(40，+)的区间</p><span class="label label-primary">**聚簇索引的锁区间和范围保持一致**</span><ul><li><strong>情况六：a为唯一索引  + delete/update + 范围查询</strong></li></ul><p>id数据：             10 11 13 20 40</p><p>唯一索引a数据：1   3   5   7   9</p><p><strong>①执行以下事务</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住（-，5]区间。</p><p><strong>②执行以下事务</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;=<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住（-，7]区间。</p><div class="note note-info">            <p>这里就发现和主键索引不同的地方了。二级索引可以利用索引下推直接在引擎层判断，如果一条记录不符合索引条件下推中的条件的话，直接跳到下一条记录（这个过程根本不将其返回到server层），如果这已经是最后一条记录，那么直接向server层报告查询完毕。但是这里头有个问题：先对一条记录加了锁，然后再判断该记录是不是符合索引条件下推的条件，如果不符合直接跳到下一条记录或者直接向server层报告查询完毕，这个过程中并没有把那条被加锁的记录上的锁释放掉呀！！！</p>          </div><ul><li><strong>情况七：a为非唯一索引  + delete/update + 范围查询</strong></li></ul><p><strong>①执行以下事务</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住（-，5]区间。</p><p><strong>②执行以下事务</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;=<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住（-，7)区间。</p><h3 id="锁的等待问题"><a href="#锁的等待问题" class="headerlink" title="锁的等待问题"></a>锁的等待问题</h3><p>通过以下命令查看表的锁情况</p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> information_schema.INNODB_LOCKS;</code></pre><p>通过以下命令查看处于堵塞状态的线程，并通过kill_blocking字段kill掉阻塞源</p><pre><code class="hljs csharp"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> sys.innodb_lock_waits</code></pre><p>以下代码在5.6版本运行</p><pre><code class="hljs mipsasm">SELECTr.trx_id <span class="hljs-keyword">waiting_trx_id,</span><span class="hljs-keyword">r.trx_mysql_thread_id </span><span class="hljs-keyword">waiting_thread,</span><span class="hljs-keyword">r.trx_query </span><span class="hljs-keyword">waiting_query,</span><span class="hljs-keyword">b.trx_id </span><span class="hljs-keyword">blocking_trx_id,</span><span class="hljs-keyword">b.trx_mysql_thread_id </span><span class="hljs-keyword">blocking_thread</span><span class="hljs-keyword">FROM</span><span class="hljs-keyword">information_schema.innodb_lock_waits </span>wINNER <span class="hljs-keyword">JOIN</span><span class="hljs-keyword">information_schema.innodb_trx </span><span class="hljs-keyword">b </span>ON <span class="hljs-keyword">b.trx_id </span>= w.<span class="hljs-keyword">blocking_trx_id</span><span class="hljs-keyword">INNER </span><span class="hljs-keyword">JOIN</span><span class="hljs-keyword">information_schema.innodb_trx </span>r ON r.trx_id = w.requesting_trx_id;</code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="七、业务设计"><a href="#七、业务设计" class="headerlink" title="七、业务设计"></a>七、业务设计</h2><h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><p>第一大范式</p><p>第二大范式</p><p>第三大范式：两个非主键列不能都依赖于主键而又相互有关联</p><p>但是，由于完全遵守三大范式，会造成大量的表必须相关联，因此往往我们会选择一些反范式设计，虽然会造成一些表的冗余，这种反范式设计就是用空间来换取时间。</p><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>开启慢查询记录运行时间超过阈值的sql语句日志。</p><p>可以使用pt_query_digest   Mysqldumpslow来分析慢查询日志</p><h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><h2 id="八、Mysql优化"><a href="#八、Mysql优化" class="headerlink" title="八、Mysql优化"></a>八、Mysql优化</h2><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p><strong>1.执行顺序</strong></p><p>相同ID，由上至下执行</p><p>不同ID，ID越大越先执行</p><p> <strong>2.select_type 列</strong></p><p><img src="/img/explain_select_type.png"></p><div class="note note-info">            <p>SUBQUERY是在where或者select里的子查询</p><p>DERIVED是在from里的子查询</p>          </div><p><strong>3.type列</strong></p><p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p><div class="note note-info">            <p>const使用主键或者唯一索引一次就找到一个</p><p>eq_ref是联表查询里用到了唯一索引</p>          </div><p><strong>4.possible_keys  与 Key</strong></p><p>怎么判断有没有用到索引：   key</p><p>怎么判断有没有充分用到索引： key_len</p><p>key_len 越短越好 既对也不对。 对是因为确实字段采用长度更小的数值类型越好，不对是因为充分使用索引 要比 不充分使用索引 的key_len要长</p><table><thead><tr><th>列类型</th><th>KEY_LEN</th><th>备注</th></tr></thead><tbody><tr><td>id int</td><td>key_len = 4+1</td><td>int为4bytes,允许为NULL,加1byte</td></tr><tr><td>id bigint not null</td><td>key_len=8</td><td>bigint为8bytes</td></tr><tr><td>user char(30) utf8</td><td>key_len=30*3+1</td><td>utf8每个字符为3bytes,允许为NULL,加1byte</td></tr><tr><td>user varchar(30) not null utf8</td><td>key_len=30*3+2</td><td>utf8每个字符为3bytes,变长数据类型,加2bytes</td></tr><tr><td>user varchar(30) utf8</td><td>key_len=30*3+2+1</td><td>utf8每个字符为3bytes,允许为NULL,加1byte,变长数据类型,加2bytes</td></tr><tr><td>detail text(10) utf8</td><td>key_len=30*3+2+1</td><td>TEXT截取部分,被视为动态列类型。</td></tr></tbody></table><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><p>使用 ENUM 而不是 VARCHAR  </p><p>　　ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表 上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。  </p><p>　　如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或 “部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。  </p><h2 id="九、记录一些其他知识点"><a href="#九、记录一些其他知识点" class="headerlink" title="九、记录一些其他知识点"></a>九、记录一些其他知识点</h2><h3 id="简单讲讲oracle和mysql"><a href="#简单讲讲oracle和mysql" class="headerlink" title="简单讲讲oracle和mysql"></a>简单讲讲oracle和mysql</h3><p><strong>①并发性</strong></p><p>Mysql以表级锁为主。InnoDB引擎的表可以用行级锁，其依赖于表的索引。oracle使用行级锁，对资源锁定的粒度要小很多</p><p><strong>②一致性</strong></p><p>oracle支持serializable的隔离级别，可以实现最高级别的读一致性。mysql支持到RC隔离级别</p><p><strong>③事务</strong></p><p>Oracle支持事务，mysql的innodb支持事务</p><p><strong>④持久性</strong></p><p>oracle：保证提交的数据均可恢复，因为oracle把提交的sql操作线写入了在线联机日志文件中，保持到了磁盘上，如果出现数据库或主机异常重启，重启后oracle可以考联机在线日志恢复客户提交的数据。</p><p>mysql：默认提交sql语句，但如果更新过程中出现db或主机重启的问题，也许会丢失数据。</p><p><strong>⑤逻辑备份</strong></p><p> oracle逻辑备份时不锁定数据，且备份的数据是一致的。</p><p>  mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的</p><p><strong>⑥热备份</strong></p><p>oracle有成熟的热备工具rman，热备时，不影响用户使用数据库。即使备份的数据库不一致，也可以在恢复时通过归档日志和联机重做日志进行一致的回复。</p><p>mysql：myisam的引擎，用mysql自带的mysqlhostcopy热备时，需要给表加读锁，影响dml操作。innodb的引擎，它会备份innodb的表和索引，但是不会备份.frm文件。用ibbackup备份时，会有一个日志文件记录备份期间的数据变化，因此可以不用锁表，不影响其他用户使用数据库。但此工具是收费的。innobackup是结合ibbackup使用的一个脚本，他会协助对.frm文件的备份。</p><p><strong>⑦sql语句的扩展和灵活性</strong></p><p>mysql对sql语句有很多非常实用而方便的扩展，比如limit功能，insert可以一次插入多行数据，select某些管理数据可以不加from。</p><p>  oracle在这方面感觉更加稳重传统一些。</p><p><strong>⑧复制</strong></p><p>oracle：既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。</p><p> mysql：复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。</p><p><strong>⑨性能诊断</strong></p><p>  oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等</p><p>  mysql的诊断调优方法较少，主要有慢查询日志。</p><p><strong>⑩权限与安全</strong></p><p>  mysql的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。</p><p>  oracle的权限与安全概念比较传统，中规中矩。</p><p><strong>⑪分区表和分区索引</strong></p><p>  oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。</p><p>  mysql的分区表还不太成熟稳定。</p><h3 id="MySQL各版本更新记录"><a href="#MySQL各版本更新记录" class="headerlink" title="MySQL各版本更新记录"></a>MySQL各版本更新记录</h3><p>5.5   默认存储引擎更改为innodb</p><p>​         写缓冲池从insertbuffer -&gt; changebuffer</p><p>5.6   加入索引下推</p><p>5.7   加入json数据类型</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>关系型数据库与非关系型数据库 <a href="https://blog.csdn.net/oChangWen/article/details/53423301">https://blog.csdn.net/oChangWen/article/details/53423301</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>InnoDB 和MyISAM的区别 <a href="https://blog.csdn.net/qq_35642036/article/details/82820178">https://blog.csdn.net/qq_35642036/article/details/82820178</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>意向锁 <a href="https://juejin.im/post/6844903666332368909">https://juejin.im/post/6844903666332368909</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>索引下推 <a href="https://www.cnblogs.com/Chenjiabing/p/12600926.html">https://www.cnblogs.com/Chenjiabing/p/12600926.html</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>MRR <a href="https://zhuanlan.zhihu.com/p/110154066">https://zhuanlan.zhihu.com/p/110154066</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>不错的整理贴 <a href="https://juejin.im/post/6850037271233331208#heading-50">https://juejin.im/post/6850037271233331208#heading-50</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>加锁流程分析 <a href="https://zhuanlan.zhihu.com/p/144471126">https://zhuanlan.zhihu.com/p/144471126</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>间隙锁 <a href="https://www.jianshu.com/p/42e60848b3a6">https://www.jianshu.com/p/42e60848b3a6</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span>比较全面的加锁流程分析 <a href="https://blog.csdn.net/bjweimengshu/article/details/90056126">https://blog.csdn.net/bjweimengshu/article/details/90056126</a><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:10" class="footnote-text"><span>MySQL唯一索引和普通索引运行原理和使用选择 <a href="https://blog.csdn.net/Srodong/article/details/88838046">https://blog.csdn.net/Srodong/article/details/88838046</a><a href="#fnref:10" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:11" class="footnote-text"><span>缓冲池 <a href="https://www.sohu.com/a/322957463_178889">https://www.sohu.com/a/322957463_178889</a>       <a href="https://www.sohu.com/a/322166567_178889">https://www.sohu.com/a/322166567_178889</a><a href="#fnref:11" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:12" class="footnote-text"><span>MVCC <a href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a>       <a href="https://blog.csdn.net/Miaoshuowen/article/details/104838082">https://blog.csdn.net/Miaoshuowen/article/details/104838082</a><style>  /* 只设置  note字体 */  .note {    font-family: "Microsoft YaHei",Georgia, sans, serif, KaiTi,;    font-size: 14px;  }</style><a href="#fnref:12" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/10/02/hello-world/"/>
    <url>/2020/10/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

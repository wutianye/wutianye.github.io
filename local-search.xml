<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2021/04/01/mysql/"/>
    <url>/2021/04/01/mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL——基础篇"><a href="#MySQL——基础篇" class="headerlink" title="MySQL——基础篇"></a>MySQL——基础篇</h1><h2 id="一、MySQL数据类型"><a href="#一、MySQL数据类型" class="headerlink" title="一、MySQL数据类型"></a>一、MySQL数据类型</h2><h3 id="INT类型"><a href="#INT类型" class="headerlink" title="INT类型"></a>INT类型</h3><table><thead><tr><th><strong>类型</strong></th><th></th><th><strong>字节</strong></th><th><strong>最小值</strong></th><th><strong>最大值</strong></th></tr></thead><tbody><tr><td></td><td></td><td></td><td><strong>（带符号的/无符号的）</strong></td><td><strong>(带符号的/无符号的)</strong></td></tr><tr><td>TINYINT</td><td></td><td>1</td><td>-128    2^7</td><td>127</td></tr><tr><td></td><td></td><td></td><td>0</td><td>255</td></tr><tr><td>SMALLINT</td><td></td><td>2</td><td>-32768    2^15</td><td>32767</td></tr><tr><td></td><td></td><td></td><td>0</td><td>65535</td></tr><tr><td>MEDIUMINT</td><td></td><td>3</td><td>-8388608   2^23</td><td>8388607</td></tr><tr><td></td><td></td><td></td><td>0</td><td>16777215</td></tr><tr><td>INT</td><td></td><td>4</td><td>-2147483648    2^31</td><td>2147483647</td></tr><tr><td></td><td></td><td></td><td>0</td><td>4294967295</td></tr><tr><td>BIGINT</td><td></td><td>8</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr><tr><td></td><td></td><td></td><td>0</td><td>18446744073709551615</td></tr></tbody></table><div class="note note-warning">            <p>unsigned 无符号最小值是0.  在用select a-b类似语句时，若目标字段为无符号，计算值为负则会报错</p>          </div><div class="note note-warning">            <p>int(N)不代表长度上限。而是代表显示宽度。使用zerofill 代表&lt;N时用0填充左边，超过N则原样显示</p>          </div><ul><li><strong>int的常用场景：自增长</strong></li></ul><p>MySQL 每张表只能有1个自增长字段，其可以作为主键，也可以不作为主键。<span class="label label-primary">非主键情况下必须显示添加唯一索引</span></p><span class="label label-success">自增字段：插入null或0结果是自己自增，负数也是可以插进去的。</span><div class="note note-danger">            <p><strong>面试题——自增长：</strong> </p><p>17之后删除15 16 17。再次插入数据，id是几？</p>          </div><div class="note note-success">            <p>回答：</p><p>mysql8.0之前  myisam：18    innodb(重启)：15     innodb(未重启)：18</p><p>mysql8.0之后   myisam：18   innodb：18</p>          </div><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><table><thead><tr><th>类型</th><th>说明</th><th>N的含义</th><th>是否有字符集</th><th>最大长度</th></tr></thead><tbody><tr><td>CHAR(N)</td><td>定长字符</td><td><strong>字符</strong></td><td>是</td><td>255</td></tr><tr><td>VARCHAR(N)</td><td>变长字符</td><td><strong>字符</strong></td><td>是</td><td>16384</td></tr><tr><td>BINARY(N)</td><td>定长二进制字节</td><td>字节</td><td>否</td><td>255</td></tr><tr><td>VARBINARY(N)</td><td>变长二进制字节</td><td>字节</td><td>否</td><td>16384</td></tr><tr><td>TINYBLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>256</td></tr><tr><td>BLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>16K</td></tr><tr><td>MEDIUMBLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>16M</td></tr><tr><td>LONGBLOB(N)</td><td>二进制大对象</td><td>字节</td><td>否</td><td>4G</td></tr><tr><td>TINYTEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>256</td></tr><tr><td>TEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>16K</td></tr><tr><td>MEDIUMTEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>16M</td></tr><tr><td>LONGTEXT(N)</td><td>大对象</td><td>字节</td><td>是</td><td>4G</td></tr></tbody></table><ul><li><strong>字符类型小tip：排序规则</strong></li></ul><p>我们会看到在创建表的时候，字符集有这样两种：<span class="label label-primary">bin</span>、<span class="label label-default">ci</span></p><span class="label label-primary">bin</span>指使用二进制形式，会区分大小写。<div class="note note-danger">            <p>面试题——字符集：select ‘a’ = ‘A’ 的执行结果</p>          </div><div class="note note-success">            <p>回答：</p><p>使用bin时，执行结果为0</p><p>使用ci时，执行结果为1</p>          </div><h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h3><table><thead><tr><th>日期类型</th><th>占用空间</th><th>表示范围</th></tr></thead><tbody><tr><td>DATETIME</td><td>8</td><td>1000-01-01  00:00:00 ~ 9999-12-31 23:59:59</td></tr><tr><td>DATE</td><td>3</td><td>1000-01-01  ~ 9999-12-31</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01  00:00:00UTC ~ 2038-01-19 03:14:07UTC</td></tr><tr><td>YEAR</td><td>1</td><td>YEAR(2):1970-2070,  YEAR(4):1901-2155</td></tr><tr><td>TIME</td><td>3</td><td>-838:59:59  ~ 838:59:59</td></tr></tbody></table><p>需要注意的是<span class="label label-primary">DATETIME</span>、<span class="label label-default">TIMESTAMP</span>这两者存在时区上的区分。TIMESTAMP 能通过以下命令查看和设置时区：</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @@<span class="hljs-keyword">time_zone</span>;<span class="hljs-keyword">set</span> <span class="hljs-keyword">time_zone</span>=<span class="hljs-string">&#x27;+00:00&#x27;</span>;</code></pre><h3 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h3><p>json_extract  抽取</p><pre><code class="hljs stylus">select<span class="hljs-function"><span class="hljs-title">json_extract</span><span class="hljs-params">(data, <span class="hljs-string">&#x27;$.name&#x27;</span>)</span></span>,<span class="hljs-function"><span class="hljs-title">json_extract</span><span class="hljs-params">(data, <span class="hljs-string">&#x27;$.address&#x27;</span>)</span></span></code></pre><p> JSON_OBJECT  将对象转为 json</p><pre><code class="hljs pgsql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> json_user <span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>,json_object(&quot;name&quot;, &quot;enjoy&quot;, &quot;email&quot;, &quot;enjoy.com&quot;, &quot;age&quot;,<span class="hljs-number">35</span>) )</code></pre><p> json_insert 增加json结构 </p><pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-keyword">json</span> = <span class="hljs-string">&#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3]&#125;&#x27;</span>;<span class="hljs-keyword">select</span> json_insert(@<span class="hljs-keyword">json</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;$.c&#x27;</span>, <span class="hljs-string">&#x27;[true, false]&#x27;</span>);<span class="hljs-keyword">update</span> json_user <span class="hljs-keyword">set</span> <span class="hljs-keyword">data</span> = json_insert(<span class="hljs-keyword">data</span>, <span class="hljs-string">&quot;$.address_2&quot;</span>, <span class="hljs-string">&quot;xiangxue&quot;</span>) <span class="hljs-keyword">where</span> uid = <span class="hljs-number">1</span>;</code></pre><p>json_merge 合并json结构</p><p>JSON_UNQUOTE  取消引用JSON值，并将结果作为<code>utf8mb4</code>字符串返回</p><pre><code class="hljs less"><span class="hljs-selector-tag">select</span> <span class="hljs-selector-tag">JSON_UNQUOTE</span>(json_extract(<span class="hljs-variable">@json</span>, <span class="hljs-string">&#x27;$.a&#x27;</span>));</code></pre><h2 id="二、MySQL架构"><a href="#二、MySQL架构" class="headerlink" title="二、MySQL架构"></a>二、MySQL架构</h2><p>MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<span class="label label-primary">插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</span>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><p><img src="/img/mysqljiagoutu.png"></p><h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、身份认证、权限验证的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><p>第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。</p><ul><li><strong>cache&amp;buffer</strong></li></ul><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%query_cache_type%&#x27;</span> <span class="hljs-comment">-- 默认不开启</span><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%query_cache_size%&#x27;</span> <span class="hljs-comment">--默认值 1M</span></code></pre><p>业务中并不推荐用cache，所以他也是默认关闭的。原因如下：</p><p>①浪费内存</p><p>②innodb有buffer提供类似功能</p><p>③太严格了！需要查询语句完全一致，包括字符集，那为啥不用redis呢？</p><ul><li><strong>Parser解析器</strong></li></ul><p><img src="/img/mysqljiexiqi.png"></p><ul><li><strong>Optimizer优化器</strong></li></ul><pre><code class="hljs csharp"><span class="hljs-keyword">where</span> <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  &gt;&gt;&gt;  不使用<span class="hljs-keyword">where</span><span class="hljs-keyword">where</span> 主键 <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>   &gt;&gt;&gt;  impossible key<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> account t <span class="hljs-keyword">where</span> t.<span class="hljs-function">id <span class="hljs-title">in</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> t2.id <span class="hljs-keyword">from</span> account t2</span>)   子查询   &gt;&gt;&gt;  关联查询</span></code></pre><h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</p><h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h3><p>第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。</p><h2 id="三、MySQL存储引擎"><a href="#三、MySQL存储引擎" class="headerlink" title="三、MySQL存储引擎"></a>三、MySQL存储引擎</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 物理文件结构为：</p><span class="label label-primary">.frm</span> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等<span class="label label-danger">.MYD</span> (MYData) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据<span class="label label-danger">.MYI</span>  (MYIndex)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息<div class="note note-warning">            <p>myisam压缩后insert操作失效</p>          </div><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 物理文件结构为：</p><span class="label label-primary">.frm</span> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等<span class="label label-danger">.ibd</span> 文件或 <span class="label label-danger">.ibdata</span> 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。<p>独享表空间存储方式使用.ibd文件，并且每个表一个.ibd文件</p><p>共享表空间存储方式使用.ibdata文件，所有表共同使用一个.ibdata文件（或多个，可自己配置）</p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><strong>索引文件和数据文件是否分开</strong>。（关于两者在索引上的具体实现方式的解析在下面索引知识点详细解读）</p><p>①InnoDB 支持事务，MyISAM 不支持事务</p><p>②InnoDB 支持外键，而 MyISAM 不支持。</p><p>③InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p><p>④InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p><p>⑤InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。MyISAM并发性不好。</p><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><ol><li>以 csv 格式进行数据存储</li><li>所有列都不能为 null 的</li><li>不支持索引（不适合大表，不适合在线处理）</li><li>可以对数据文件直接编辑（保存文本文件内容</li></ol><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>文件系统存储特点，也称 HEAP 存储引擎，所以数据保存在内存中</p><ol><li>支持 HASH 索引(默认)和 BTree 索引</li><li>所有字段都是固定长度 varchar(10) = char(10)</li><li>不支持 Blog 和 Text 等大字段</li><li>Memory 存储引擎只能使用<strong>表级锁</strong></li><li>最大大小由 max_heap_table_size 参数决定</li></ol><ul><li><strong>Memory使用场景</strong></li></ul><ol><li>hash 索引用于查找或者是映射表（邮编和地区的对应表）</li><li>用于保存数据分析中产生的中间表</li><li>用于缓存周期性聚合数据的结果表</li></ol><h3 id="Ferderated"><a href="#Ferderated" class="headerlink" title="Ferderated"></a>Ferderated</h3><p>提供了访问远程 MySQL 服务器上表的方法</p><ol><li>本地不存储数据，数据全部放到远程服务器上</li><li>本地需要保存表结构和远程服务器的连接信息</li></ol><ul><li><strong>Ferderated使用场景</strong></li></ul><p>偶尔的统计分析及手工查询（某些游戏行业）</p><h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><span class="label label-primary">索引是帮助MySQL高效获取数据的数据结构。</span><p>在关系型数据库中，索引存储在硬盘中。</p><p><strong>基本语法：</strong></p><p>创建：</p><ul><li><p>创建索引：<code>CREATE [UNIQUE] INDEX indexName ON mytable(username(length));</code></p><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p></li><li><p>修改表结构(添加索引)：<code>ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)</code></p></li><li><p>删除：<code>DROP INDEX [indexName] ON mytable;</code></p></li><li><p>查看：<code>SHOW INDEX FROM table_name\G</code>             –可以通过添加 \G 来格式化输出信息。</p></li></ul><p>使用ALERT命令</p><ul><li><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</code> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li><li><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list</code> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li><li><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code> 添加普通索引，索引值可出现多次。</li><li><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code>该语句指定了索引为 FULLTEXT ，用于全文索引。</li></ul><p><strong>优劣势分析</strong></p><span class="label label-success">优势</span><ul><li>提高数据检索效率，降低数据库IO成本</li><li>降低数据排序的成本，降低CPU的消耗</li></ul><span class="label label-danger">劣势</span><ul><li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</li></ul><h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><p><strong>索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），<strong>将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置</strong>；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p><p>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</p><p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p><div class="note note-danger">            <p><strong>面试题——索引：</strong> Innodb为啥不用hash索引</p>          </div><div class="note note-success">            <p>①hash索引存储在内存中，数据量较多的情况下很明显不合适</p><p>②范围查找不支持。因为hash索引是一种键值查找方式。而b+tree作为多路查找平衡树，是天然有序的，很适合做范围查询。</p><p>③哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p>          </div><h4 id="Btree"><a href="#Btree" class="headerlink" title="Btree"></a>Btree</h4><p>在了解btree前，让我们来复习这样一连串的概念，来证明为什么b树是最适合的数据结构。（一些复杂的图解我将开设一个树相关的博客）</p><span class="label label-info">**二叉查找树**</span><p>随着id递增，会逐渐变成一个单边树，很明显不是一个合适的作为索引的数据结构</p><span class="label label-info">**平衡二叉查找树 AVL**</span><p>AVL树，本质上是带了平衡功能的二叉查找树。</p><p>在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为<strong>高度平衡树</strong>。增加和删除可能需要通过一次或多次<a href="https://baike.baidu.com/item/%E6%A0%91%E6%97%8B%E8%BD%AC">树旋转</a>来重新平衡这个树。</p><p>问题是AVL的大量的自平衡导致IO次数过多，形成IO浪费，很明显也不是一个合适的方案</p><span class="label label-info">**B树**</span> <p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树</p><ul><li><strong>规则</strong></li></ul><span class="label label-info">关键字的个数n满足：ceil(m/2)-1 <= n <= m-1</span><span class="label label-info">非叶节点的子节点数>1，且<=M</span><span class="label label-info">节点位于同一水平线</span><p><img src="/img/btree1.png"></p><ul><li><strong>特点</strong></li></ul><p>B树的优势在于每个节点包含的关键字增多了，充分利用了磁盘块的原理，减少数据查找的次数。</p><span class="label label-primary">磁盘块原理：系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来</span><p>InnoDB 存储引擎使用页（Page）作为存储单位，页是磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></p><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。</p><h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B+tree"></a>B+tree</h4><p>B树每个节点中不仅包含数据的key值，还有data值。data变大 -&gt; 每页能存储的key的数量变小 -&gt; B-Tree的深度较大，增大查询时的磁盘I/O次数</p><span class="label label-danger">最最消耗时间的操作就是磁盘IO：从磁盘读到内存</span><p>因此B+树舍弃了非叶子结点的data数据，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定。</p><ul><li><strong>规则</strong></li></ul><p>（1）B+跟B树不同的是，B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p><p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p><p>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p><p>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p><p><img src="/img/b+tree1.png"></p><div class="note note-danger">            <p><strong>面试题——Btree：</strong>B+tree和Btree的不同点</p>          </div><div class="note note-success">            <p>①B+tree数据只存储在叶子节点上，非叶子节点只保存索引信息</p><p>②叶子节点本身按照数据的升序排序进行链接 （物理存储上无序）</p>          </div><ul><li><strong>特点</strong></li></ul><p>1、B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;符合日常业务场景</p><p>3、B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p><p>4、B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><h4 id="B-Tree的分裂与合并"><a href="#B-Tree的分裂与合并" class="headerlink" title="B+Tree的分裂与合并"></a>B+Tree的分裂与合并</h4><h4 id="B-Tree落地mysql"><a href="#B-Tree落地mysql" class="headerlink" title="B+Tree落地mysql"></a>B+Tree落地mysql</h4><p><strong>Myisam</strong></p><ul><li><strong>物理存储</strong></li></ul><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”<strong>非聚簇索引</strong>“。</p><ul><li><strong>索引流程</strong></li></ul><p>先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p><p><img src="/img/myasim_suoyin.png"></p><p><strong>InnoDB</strong></p><ul><li><strong>物理存储</strong></li></ul><p>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录。<span class="label label-primary">主键索引存放表中所有的数据记录</span><span class="label label-info">辅助索引存放主键，检索的时候通过主键到主键索引中找到对应数据行</span></p><p>InnoDB的数据文件本身就是主键索引文件，这样的索引被称为”“聚簇索引”，一个表只能有一个聚簇索引。</p><ul><li><strong>索引流程</strong></li></ul><p><strong>主键索引</strong></p><p>数据的物理顺序与主键顺序一致； 叶子结点存放所有数据；  非叶子结点存放主键值</p><p>命中主键即取到数据</p><p><img src="/img/innodb_suoyin.jpg"></p><p><strong>二级索引</strong></p><p>叶子结点存放主键值；非叶子结点存放二级索引值</p><p>命中二级索引值 –&gt; 取得主键 –&gt; 命中主键索引对应项 –&gt; 取得数据</p><p>这也就是所谓的“<strong>回表查询</strong>”</p><p><img src="/img/innodb_suoyin2.png"></p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a><strong>从物理存储角度</strong></h4><ul><li>聚集索引（clustered index）</li><li>非聚集索引（non-clustered index），也叫辅助索引（secondary index</li></ul><p><strong>聚簇索引</strong></p><p>聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。</p><p>一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。</p><p>在InnoDB引擎中，<strong>只有主键是聚集索引</strong>，其他的索引都是非聚集索引。</p><div class="note note-danger">            <p><strong>面试题——InnoDB聚簇索引：</strong></p><p>InnoDB 没有主键咋办？</p>          </div><div class="note note-success">            <p><strong>回答：</strong>如果表中没有主键或者一个合适的的唯一索引，InnoDB内部会以一个包含行ID值的合成列生成一个隐藏的聚簇索引。表中的行是按照InnoDB分配的ID排序的。行ID是一个6字节的字段，随着一个新行的插入单调增加。因此，行ID顺序物理上是插入顺序。</p><p>所有用ROW_ID列的表，共享同一个被保存在数据字典中的全局序列数。这就会导致竞争从而引起性能问题。</p>          </div><div class="note note-danger">            <p><strong>面试题——InnoDB聚簇索引</strong>：</p><p>InnoDB为什么推荐使用自增ID而不是UUID作为主键？</p>          </div><div class="note note-success">            <p><strong>回答：</strong></p><p>①UUID是字符串，比整型消耗更多的存储空间</p><p>②整型数据的比较运算比字符串更快速</p><p>③自增的整型索引在磁盘中会连续存储，查找关联性数据时更方便</p><p>④在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p><p>如何去理解这句话呢：</p><p>  InnoDB引擎使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放。因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>​    1、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</p><p>​    这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>​    2、 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>          </div><h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h4><ul><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li><li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li><li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>唯一索引或者非唯一索引</li><li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。 MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</li></ul><h3 id="索引的使用及三星索引"><a href="#索引的使用及三星索引" class="headerlink" title="索引的使用及三星索引"></a>索引的使用及三星索引</h3><h3 id="优化之索引下推"><a href="#优化之索引下推" class="headerlink" title="优化之索引下推"></a>优化之索引下推</h3><p>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。</p><p>• 在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p><p>• 在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p><p>• 索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p><p>主要目的就是<span class="label label-primary">减少IO次数</span></p><p>适用条件</p><p>​     ①需要整表扫描的情况。比如：range, ref, eq_ref, ref_or_null 。适用于InnoDB 引擎和 MyISAM 引擎的查询。（5.6版本不适用分区表查询，5.7版本后可以用于分区表查询）。</p><p>​     ②对于InnDB引擎只适用于二级索引，因为InnDB的聚簇索引会将整行数据读到InnDB的缓冲区，这样一来索引条件下推的主要目的减少IO次数就失去了意义。因为数据已经在内存中了，不再需要去读取了。</p><p>​     ③引用子查询的条件不能下推。</p><p>调用存储过程的条件不能下推，存储引擎无法调用位于MySQL服务器中的存储过程</p><h3 id="优化之MRR-顺序磁盘读"><a href="#优化之MRR-顺序磁盘读" class="headerlink" title="优化之MRR (顺序磁盘读)"></a>优化之MRR (顺序磁盘读)</h3><p>MRR，全称「Multi-Range Read Optimization」。</p><p>简单说：MRR 通过把「随机磁盘读」，转化为「顺序磁盘读」，从而提高了索引查询的性能。</p><p>对于 Myisam，在去磁盘获取完整数据之前，会先按照rowId排好序，再去顺序的读取磁盘。</p><p>对于 Innodb，则会<strong>按照聚簇索引键值排好序</strong>，再顺序的读取聚簇索引。</p><p>顺序读带来了几个好处：</p><p>1、磁盘和磁头不再需要来回做机械运动；</p><p>2、可以充分利用磁盘预读（局部性原理）</p><p>3、在一次查询中，每一页的数据只会从磁盘读取一次</p><p><strong>索引本身就是为了减少磁盘 IO，加快查询，而MRR，则是把索引减少磁盘 IO 的作用，进一步放大。</strong></p><p>MRR在本质上是一种用空间换时间的算法。MySQL 不可能给你无限的内存来进行排序</p><h3 id="优化之缓冲池"><a href="#优化之缓冲池" class="headerlink" title="优化之缓冲池"></a>优化之缓冲池</h3><h4 id="缓冲池-buffer-pool"><a href="#缓冲池-buffer-pool" class="headerlink" title="缓冲池 buffer pool"></a>缓冲池 buffer pool</h4><p>缓冲池(buffer pool)是一种<strong>常见的减少磁盘IO的机制；</strong></p><ul><li><p><strong>算法</strong></p><p>mysql使用了一种改进版的LRU算法(类似队列，实现是链表，后进后出)。原因有二：</p><p>①预读未读   提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据</p><p>②缓冲池污染   批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去</p><p><strong>针对预读未读</strong>，Mysql将LRU分为两个部分：</p><ul><li>新生代(new sublist)</li><li>老生代(old sublist)</li><li>新老生代收尾相连</li><li>新页加入缓冲池时，只加入到老生代头部。数据真正被读取，才会加入到新生代的头部</li></ul><p>下图为新预读page50的例图，50被加入老生代head</p><p><img src="/img/LRU.png"></p></li></ul><p>​        当其被成功读取后，加入新生代</p><p><img src="/img/LRU2.png"></p><p>​        <strong>针对缓冲池污染</strong>，MySQL缓冲池加入了一个“老生代停留时间窗口”的机制：</p><p>​        假设T=老生代停留时间窗口；</p><p>​        插入老生代头部的页，即使立刻被访问，并不会立刻放入新生代头部；</p><p>​        只有<strong>满足</strong>“被访问”并且“在老生代停留时间”大于T，才会被放入新生代头部；</p><h4 id="读缓冲"><a href="#读缓冲" class="headerlink" title="读缓冲"></a>读缓冲</h4><ul><li><strong>概念</strong></li></ul><p>对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。</p><p>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p><p>所以在这里你感觉用唯一性索引会快一些，毕竟少了一个步骤。但是这个不同带来的性能差距微乎其微。</p><p>你知道的，InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。</p><p>因为引擎是按页读写的，所以说，当找到符合条件的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。 </p><p>当然也会有特殊情况，就是符合条件的记录正好处于数据页的最后一个，那往下查找的操作就会拿下一个数据页放进内存，这个时候就会慢了，但是一个整型字段，一个数据页可以放进千的key，所以这个概率很低。</p><pre><code class="hljs gauss"><span class="hljs-built_in">select</span> <span class="hljs-comment">@@</span>innodb_buffer_pool_size <span class="hljs-comment">//查询缓冲池大小</span></code></pre><h4 id="写缓冲"><a href="#写缓冲" class="headerlink" title="写缓冲"></a>写缓冲</h4><ul><li><strong>概念</strong></li></ul><p>这里就有个重要概念叫<span class="label label-primary">Change buffer</span></p><p>在MySQL5.5之前，叫插入缓冲(insert buffer)，只针对insert做了优化；现在对delete和update也有效，叫做写缓冲(change buffer)。</p><p>它是一种应用在<strong>非唯一普通索引页</strong>(non-unique secondary index page)不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更(buffer changes)，等未来数据被读取时，再将数据合并(merge)恢复到缓冲池中的技术。写缓冲的<strong>目的</strong>是<strong>降低写操作的磁盘IO，提升数据库性能。</strong></p><ul><li><strong>过程分析</strong></li></ul><p>第一种情况：目标数据页在内存中。</p><p>（1）直接修改缓冲池中的页，一次内存操作；</p><p>（2）写入redo log，一次磁盘顺序写操作；</p><p>第二种情况是：目标数据页不在内存中</p><p>（1）先把需要为40的索引页，从磁盘加载到缓冲池，一次磁盘随机读操作；</p><p>（2）修改缓冲池中的页，一次内存操作；</p><p>（3）写入redo log，一次磁盘顺序写操作；</p><span class="label label-primary">那么对于第二种情况还有优化空间吗？我们可以节省出这次磁盘IO吗？</span><p>加入写缓冲后：</p><p>（1）在写缓冲中记录这个操作，一次内存操作；</p><p>（2）写入redo log，一次磁盘顺序写操作；</p><p>当下次需要访问这个数据页的时候，将数据页放入内存，然后执行 change buffer 中与这个页有关的操作。</p><p><strong>因此，写缓冲减少了磁盘IO，减少内存占用，提升内存利用率</strong></p><p>另外，需要注意的是，<span class="label label-warning">写缓冲优化仅适用于非唯一普通索引页</span></p><span class="label label-info">唯一索引的更新操作之前都要判断唯一性，所以在判断这步已经把数据页放在了内存里</span><span class="label label-primary">除了数据页被访问，还有哪些操作会触发缓冲刷写(merge)呢？</span><p>（1）有一个后台线程，会认为数据库空闲时</p><p>（2）数据库缓冲池不够用时</p><p>（3）数据库正常关闭时</p><p>（4）redo log写满时</p><pre><code class="hljs gauss"><span class="hljs-built_in">select</span> <span class="hljs-comment">@@</span>innodb_change_buffering <span class="hljs-comment">//查询哪些操作开启了写缓冲</span><span class="hljs-built_in">select</span> <span class="hljs-comment">@@</span>innodb_change_buffer_max_size  <span class="hljs-comment">//查询change buffer占用buffer pool 的比例</span></code></pre><ul><li><strong>应用场景</strong></li></ul><p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p><p>由此看来就是对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>所以反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p><p>在实际使用中，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。对于一些历史记录表可以考虑使用普通索引</p><h2 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ul><li>原子性</li></ul><p>一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，要么全部失败</p><ul><li>一致性</li></ul><p>将数据库从一种一致性转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中数据的完整性没有被破坏</p><ul><li>隔离性</li></ul><p>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><ul><li>持久性</li></ul><p>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失</p><h3 id="三类事务问题"><a href="#三类事务问题" class="headerlink" title="三类事务问题"></a>三类事务问题</h3><ul><li><strong>脏读</strong></li></ul><p>A事务中的读操作可能读到另一个事务中未提交修改的数据，如果事务发生回滚就可能造成错误。</p><p><em>dirty read</em></p><p><em>An operation that retrieves unreliable data, data that was updated by another transaction but not yet committed. It is only possible with the isolation level known as read uncommitted.</em></p><p><em>This kind of operation does not adhere to the ACID principle of database design. It is considered very risky, because the data could be rolled back, or updated further before being committed; then, the transaction doing the dirty read would be using data that was never confirmed as accurate.</em></p><p><em>Its opposite is consistent read, where InnoDB ensures that a transaction does not read information updated by another transaction, even if the other transaction commits in the meantime.</em></p><ul><li><strong>不可重复读</strong></li></ul><p>事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。</p><p><em>non-repeatable read</em></p><p><em>The situation when a query retrieves data, and a later query within the same transaction retrieves what should be the same data, but the queries return different results (changed by another transaction committing in the meantime).</em></p><p><em>This kind of operation goes against the ACID principle of database design. Within a transaction, data should be consistent, with predictable and stable relationships.</em></p><p><em>Among different isolation levels, non-repeatable reads are prevented by the serializable read and repeatable read levels, and allowed by the consistent read, and read uncommitted levels.</em></p><ul><li><strong>幻读</strong></li></ul><p>如果一个查询在一个事务中运行两次，与此同时，另一个事务将在插入新行后提交 或更新一行，使其与查询的WHERE子句匹配。这种情况被称为幻像读取，比不可重复读取更难防范，因为锁定第一个查询结果集中的所有行并不能阻止导致幻像出现的更改。</p><p><em>phantom</em></p><p><em>A row that appears in the result set of a query, but not in the result set of an earlier query. For example, if a query is run twice within a transaction, and in the meantime, another transaction commits after inserting a new row or updating a row so that it matches the WHERE clause of the query.</em></p><p><em>This occurrence is known as a phantom read. It is harder to guard against than a non-repeatable read, because locking all the rows from the first query result set does not prevent the changes that cause the phantom to appear.</em></p><p><em>Among different isolation levels, phantom reads are prevented by the serializable read level, and allowed by the repeatable read, consistent read, and read uncommitted levels.</em></p><div class="note note-primary">            <p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。</p><p>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>          </div><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><img src="/img/mysqlgelijibie.png"></p><div class="note note-primary">            <p>但是mysql在RR上通过间隙锁解决了幻读问题</p>          </div><div class="note note-danger">            <p><strong>面试题——事务隔离级别</strong>：那么Mysql通过什么完成了RR事务隔离级别，解决了脏读、不可重复读、幻读这些问题的呢？</p>          </div><div class="note note-success">            <p><strong>回答</strong>：MVCC + LBCC</p>          </div><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><ul><li>MVCC (Multi-Version Concurrency Control)  基于多版本的并发控制协议</li><li>LBCC(Lock-Based Concurrency Control) 基于锁的并发控制</li></ul><p>MVCC是一种概念，其核心理念就是<strong>数据快照</strong>。Innodb实现了这样一个概念，并借此一定程度上解决了脏读，幻读，不可重复读等事务隔离问题</p><p><strong>MVCC 最大特性：读不加锁，读写不冲突</strong></p><p>在MVCC并发控制中，读操作可以分成两类：<strong>快照读 (snapshot read)**与</strong>当前读 (current read)**。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><p>对于MySQL InnoDB来说：</p><ul><li>快照读：简单的select操作，属于快照读，不加锁。快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</li><li>当前读：特殊的读操作(加读锁)，插入/更新/删除操作，属于当前读，需要加锁。</li></ul><p><strong>当前读</strong>：</p><p><img src="/img/MVCC1.png"></p><p>从图中，可以看到，一个Update操作的具体流程：</p><ul><li>（1）当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。</li><li>（2）待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。</li><li>（3）一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</li><li>（4）根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的， 因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操 作；然后在读取下一条加锁，直至读取完毕。</li></ul><p><strong>一致性非锁定读</strong>：</p><p>InnoDB采用一致性非锁定读的机制，不需要等待行上排他锁的释放，而是采取读取快照数据。快照数据是指该行的之前版本的数据，每行记录可能有多个版本。</p><p><strong>InnoDB中MVCC的实现原理</strong></p><p>它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。</p><ul><li><strong>隐式字段</strong></li></ul><span class="label label-primary">DB_TRX_ID</span><p> 6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</p><span class="label label-primary">DB_ROLL_PTR</span><p> 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</p><span class="label label-primary">DB_ROW_ID</span><p> 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</p><p>实际还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</p><p><img src="/img/MVCC2.png"></p><ul><li><strong>undolog</strong></li></ul><p>insert undo log<br> 代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p><p>update undo log<br> 事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</p><div class="note note-danger">            <p>更新或删除操作真正把旧数据删除了吗？</p>          </div><div class="note note-success">            <p>为了实现InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。</p><p>为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</p>          </div><p>undo log是一个记录历史版本的链式结构。如下图。</p><p><img src="/img/MVCC3.png"></p><p>事务1对该记录的name做出了修改，改为Tom</p><ol><li>在事务1修改该行(记录)数据时，数据库会先对该行加排他锁</li><li>然后把该行数据拷贝到undo log中，作为旧记录，既在undo log中有当前行的拷贝副本</li><li>拷贝完毕后，修改该行name为Tom，并且修改隐藏字段的事务ID为当前事务1的ID, 我们默认从1开始，之后递增，回滚指针指向拷贝到undo log的副本记录，既表示我的上一个版本就是它</li><li>事务提交后，释放锁</li></ol><p><img src="/img/MVCC4.png"></p><p>事务2修改person表的同一个记录，将age修改为30岁</p><ol><li>在事务2修改该行数据时，数据库也先为该行加锁</li><li>然后把该行数据拷贝到undo log中，作为旧记录，发现该行记录已经有undo log了，那么最新的旧数据作为链表的表头，插在该行记录的undo log最前面</li><li>修改该行age为30岁，并且修改隐藏字段的事务ID为当前事务2的ID, 那就是2，回滚指针指向刚刚拷贝到undo log的副本记录</li><li>事务提交，释放锁</li></ol><p><img src="/img/MVCC5.png"></p><ul><li><strong>Read View</strong></li></ul><p>Read View就是事务进行快照读操作的时候生产的读视图。在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，<strong>第一次真正修改记录时</strong>都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)</p><p>Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p><p>Read View遵循一个可见性算法：</p><ol><li>Read View维护全局属性：活跃事务ID列表、最小活跃事务ID、已知最大事务ID</li><li>if 数据最新事务ID &lt; 最小活跃事务ID 或者数据最新事务ID即为当前事务， 则能直接看到最新数据，否则进入下一个判断</li><li>if 数据最新事务ID &gt;= 已知最大事务ID， 证明此数据的最新更新事务在当前事务之后出现，无法看到的最新数据，那么只能查看其历史版本，否则进入下一个判断</li><li>if 数据最新事务ID 在 活跃事务ID列表中，则看不到此最新数据，那么只能查看其历史版本，如果不在，说明是个已经commit的事务，则能看到最新数据</li></ol><div class="note note-danger">            <p>RR 和 RC 快照读的区别</p>          </div><div class="note note-success">            <p>生成 ReadView 的时机不同， RC 在每一次进行普通 SELECT 操作前都会生成一个 ReadView ，而 RR只在第一次进行普通 SELECT 操作前生成一个 ReadView ，之后的查询操作都重复这个 ReadView。</p>          </div><h3 id="事务知识点总结"><a href="#事务知识点总结" class="headerlink" title="事务知识点总结"></a>事务知识点总结</h3><p>①事务隔离级别：RUC RC RR 串行</p><p>②事务的四大特性：ACID</p><p>③MVCC是一种多版本并发控制概念，它将读操作分为快照读和当前读，InnoDB依靠隐式字段、undolog、readview完成了快照读</p><p>④RR 和 RC 生成 ReadView 的时机不同</p><p>⑤事务的隔离性由MVCC和锁实现，而原子性，持久性和一致性主要是通过redo log、undolog和Force Log at Commit机制机制来完成的。</p><p>下图将缓冲、事务完美的展现了出来，值得一看</p><p><img src="/img/shiwu.png"></p><h2 id="六、锁"><a href="#六、锁" class="headerlink" title="六、锁"></a>六、锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><p>根据粒度分： 行锁 表锁 页锁</p><h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h3><ul><li><strong>共享读锁</strong> </li></ul><pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">read</span></code></pre><p>同一会话：写操作报错，<span class="label label-warning">其他表的读写操作也都会报错</span>，使用<span class="label label-primary">别名</span>的读操作也会报错</p><p>新开会话：不堵塞读操作，堵塞写操作，其他表的读写操作都能正常进行</p><ul><li><strong>独占写锁</strong></li></ul><pre><code class="hljs pgsql"><span class="hljs-keyword">lock</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">read</span></code></pre><p>同一会话：读写均OK，<span class="label label-warning">其他表的读写操作也都会报错</span></p><p>新开会话：堵塞读写</p><h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><p>InnoDB支持行锁，行锁不是字面意义上的锁住一行数据，<span class="label label-primary">行锁是通过给索引上的索引项加锁来实现的。</span>只有通过索引条件检索数据，InnoDB才使用行级锁。</p><p>同时<span class="label label-warning">两个事务不能锁同一个索引。</span></p><p>而当<span class="label label-danger">索引失效</span>时，行锁就变为了表锁。这里的表锁也不是字面意义的表锁，而是锁住了所有索引项，其效果等同于表锁罢了。</p><div class="note note-secondary">            <p>曾经有一次实验就出现了这样的问题：</p><p>因为where条件里对int的索引项强制类型转换成了string，导致了索引失效，因此行锁升级成了表锁，导致其他数据也无法进行更新。找了好久问题所在。</p>          </div><ul><li><strong>共享锁（S）</strong></li></ul><pre><code class="hljs sql">语法：<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表 <span class="hljs-keyword">where</span> 条件 <span class="hljs-keyword">lock</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">share</span> <span class="hljs-keyword">mode</span></code></pre><p>又名读锁，对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后才能进行。</p><ul><li><strong>排他锁（X）</strong></li></ul><pre><code class="hljs n1ql">语法：for <span class="hljs-keyword">update</span></code></pre><p>insert ，delete ， update在事务中都会<span class="label label-primary">自动默认加上排它锁</span></p><ul><li><strong>意向锁</strong></li></ul><p>InnoDB 支持<strong>多粒度锁</strong>（multiple granularity locking），它允许行级锁与表级锁共存</p><p>为实现表锁和行锁共存，引入了<strong>意向锁</strong></p><p>意向锁是由数据引擎自己维护的。对于同一张表，不同行的IX可以共存。意向锁之间是互相兼容的。</p><p>注意：这里的排他 / 共享锁指的都是表锁！！！意向锁不会与行级的共享 / 排他锁互斥！！</p><p><img src="https://img-blog.csdnimg.cn/20200930151134503.png" alt="img"></p><h4 id="InnoDB-的三种锁算法"><a href="#InnoDB-的三种锁算法" class="headerlink" title="InnoDB 的三种锁算法"></a>InnoDB 的三种锁算法</h4><ul><li><p><strong>记录锁</strong></p><p>用于等值查询，锁住单个索引项。其他事务不能修改和删除加锁项。</p></li></ul><ul><li><strong>间隙锁</strong></li></ul><p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p><p>对索引项之间的“间隙”加锁，锁定记录的范围（前一个间隙 +后一个间隙），不包含索引项本身。其他事务不能在锁范围内插入数据。因此，<strong>间隙锁解决了幻读问题</strong></p><span class="label label-warning">需要强调的是，间隙锁锁的不是索引项，而是索引项之间的间隙</span><span class="label label-warning">需要注意的是，间隙锁锁住的**区间**视数据而定，而非语句筛选条件而定。</span><ul><li><strong>临键锁</strong></li></ul><p><strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。</p><p>每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，<code>InnoDB</code> 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p><h3 id="加锁详细分析"><a href="#加锁详细分析" class="headerlink" title="加锁详细分析"></a>加锁详细分析</h3><p>了解加锁规则</p><ol><li>加锁的基本单位是（next-key lock）,他是前开后闭原则</li><li>查询过程中所有访问的对象会加锁</li><li>索引上的等值查询–给唯一索引加锁的时候，next-key lock升级为行锁</li><li>索引上的等值查询–向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁</li><li>唯一索引上的范围查询会访问到不满足条件的第一个值为止</li></ol><p>以下分析均基于<strong>RR隔离级别</strong></p><ul><li><strong>情况一：id为主键  + select</strong></li></ul><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">10</span>;</code></pre><p>快照读，不加锁</p><ul><li><strong>情况二：①id为主键  + delete/update + 等值查询</strong> </li></ul><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">10</span>;</code></pre><p><img src="/img/jiasuo1.jpg"></p><p>对索引项10加上排它锁</p><p> ②<strong>id为主键  + delete/update +等值查询未命中</strong></p><p>在7和20之间加入间隙锁，防止幻读</p><ul><li><strong>情况三：①id为唯一索引  + delete/update + 等值查询</strong></li></ul><p><img src="/img/jiasuo2.jpg"></p><p>此组合中，id是unique索引，而主键是name列。在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。</p><p>②<strong>id为唯一索引  + delete/update +等值查询未命中</strong></p><p>同样在前后索引项上间隙锁。但是为什么不在主键上也加 GAP 锁呢？</p><ul><li><strong>情况四：b为非唯一索引  + delete/update + 等值查询</strong></li></ul><p>准备以下数据：</p><p><img src="/img/jiasuo4.png"></p><p>其对应的索引结构展示如下</p><p><img src="/img/jiasuo5.png"></p><p>执行以下事务</p><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>；<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> z <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">6</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;</code></pre><span class="label label-info">思考：由于是非唯一索引，那么如果在中途加入很多b=6的数据，不就出现幻读了吗？</span><p>所以，非唯一索引往往需要用到<strong>临键锁/间隙锁来解决幻读问题</strong>。</p><p><img src="/img/b+tree_eg1.png"></p><p>由上图能看到初始状态时的b索引树结构。我们看看如果要再加一个6，树结构会变成怎样</p><p><img src="/img/b+tree_eg2.png"></p><p>很明显，要想防止幻读，避免再次插入6，光锁住6是没有用的，<strong>必须将能插入6的这个范围整个锁住</strong></p><p>因此要给索引 b 加上next-key lock (4, 6]；一直向右遍历直至遇到第一个不满足条件的值8，加入间隙锁(6,8)。自此，锁范围确定。</p><p>同时一个X锁会被加到所有满足b=6的索引项以及其对应的主键索引上，同情况3所示。<span class="label label-warning">而索引项4和8是没有被加X锁的。</span></p><p><img src="/img/jiasuo6.png"></p><div class="note note-info">            <p>为什么4和8明明进行了判断却没有被加X锁？</p><p>对等值匹配的条件有特殊处理，他们规定在InnoDB存储引擎层查找到当前记录的下一条记录时，在对其加锁前就直接判断该记录是否满足等值匹配的条件，如果不满足直接返回（也就是不加锁了），否则的话需要将其加锁后再返回给server层。所以这里也就不需要对下一条二级索引记录进行加锁了。</p>          </div><p>执行事务</p><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_lock <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>);</code></pre><p>新增(b=7,id=7)的索引，新增部分根据索引有序的规则，将会落在锁住的部分区间，所以会被阻塞。</p><p><img src="/img/jiasuo7.png"></p><span class="label label-info">但实际上这里7已经在主键里有了，所以这里其实就是直接报主键冲突了，而不是阻塞。嘿嘿。</span><p>继续执行事务</p><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> test_lock <span class="hljs-keyword">SET</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">6</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">8</span>;</code></pre><p>会将b索引上（b=8,id=8）叶子节点删掉，并增加(b=8,id=6)的叶子节点。可以看到(b=8,id=6)的叶子节点也落入锁住的部分区间，所以会被阻塞住。</p><p><img src="/img/jiasuo8.png"></p><p>同理。</p><span class="label label-success">UPDATE test_lock SET id = 20 WHERE b = 8; 成功</span><span class="label label-success">insert into test_lock values (6, 9); 成功</span><span class="label label-danger">insert into test_lock values (4, 4); 阻塞</span><span class="label label-success">insert into test_lock values (2, 4); 成功</span><span class="label label-danger">UPDATE test_lock SET b = 6 WHERE id = 1; 阻塞</span><p><strong>另外再通过一些有趣的实验，得到了以下结果，我们来研究一下</strong></p><pre><code class="hljs sql">//在事务一基础上<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_lock <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">6</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;//进行以下事务二操作：<span class="hljs-keyword">UPDATE</span> test_lock <span class="hljs-keyword">SET</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">20</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">8</span>;   //成功<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_lock <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">8</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;  //成功<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_lock <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">7</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;  //成功<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> test_lock <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">6</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;  //阻塞<span class="hljs-keyword">UPDATE</span> test_lock <span class="hljs-keyword">SET</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">5</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">8</span>;   //阻塞<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test_lock <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>);  //直接报主键冲突</code></pre><p>我们可以把<span class="label label-danger">UPDATE test_lock SET id = 5 WHERE b = 8; 阻塞</span> 拆分成</p><span class="label label-success">SELECT * FROM test_lock WHERE b = 8 FOR UPDATE; 成功</span><span class="label label-success">delete from test_lock where b = 8; 成功</span><span class="label label-danger">insert into test_lock values (5, 8); 阻塞</span><p>所以说，间隙锁，锁的是范围不是索引项，你对相邻两索引项的当前读和删除操作肯定不会有问题，因为这并不会引起三类事务问题。所以在分析会不会被间隙锁所阻塞的时候。</p><p>而下面两个语句的对比</p><span class="label label-success">insert into test_lock values (7, 7); 不阻塞，报主键冲突</span><span class="label label-danger">insert into test_lock values (5, 8); 阻塞</span><span class="label label-success">insert into test_lock values (3, 6); 不阻塞，报主键冲突</span><span class="label label-danger">insert into test_lock values (4, 8); 阻塞</span><p>很明显，插入语句首先维护的是聚簇索引，当发现主键冲突就会报错。然后在维护二级索引时，才会判断是否落入间隙锁。而(5,8)之所以是阻塞，是因为聚簇索引的5是加上排它锁了，因为事务一在对其进行当前读，自然为了防止事务问题，就得加上排它锁，所以首先触发的是锁冲突，阻塞。</p><ul><li><strong>情况五：id为主键  + delete/update + 范围查询</strong></li></ul><p>id数据：10 11 13 20 40</p><p><strong>①执行以下事务。</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &lt;= <span class="hljs-number">13</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><span class="label label-danger">insert into test_lock2 values(12); 阻塞</span><span class="label label-danger">insert into test_lock2 values(13); 阻塞</span><span class="label label-success">insert into test_lock2 values(19); 成功</span><span class="label label-success">insert into test_lock2 values(21); 成功</span><p>关于第三条id为19的记录，<span class="label label-warning">在mysql5.6版本上似乎是阻塞。</span></p><p>网上的给的解释是在判断20是否满足&lt;=13这个条件时为加上锁，如果不满足，则会解锁。因此事务2进行时(13，20)实际上没有锁的。</p><div class="note note-info">            <p>聚簇索引不需要到server层再进行条件过滤。</p><p>每从聚簇索引中取出一条记录时都要判断一下该记录是否符合范围查询的边界条件，也就是number &lt;= 8这个条件。如果符合的话将其返回给server层继续处理，否则的话需要<strong>释放掉在该记录上加的锁</strong></p>          </div><p><strong>②执行以下事务</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>&lt;<span class="hljs-number">13</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住(-,13)的区间</p><p><strong>③执行以下事务</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &gt; <span class="hljs-number">50</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住(40，+)的区间</p><span class="label label-primary">**聚簇索引的锁区间和范围保持一致**</span><ul><li><strong>情况六：a为唯一索引  + delete/update + 范围查询</strong></li></ul><p>id数据：             10 11 13 20 40</p><p>唯一索引a数据：1   3   5   7   9</p><p><strong>①执行以下事务</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住（-，5]区间。</p><p><strong>②执行以下事务</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;=<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住（-，7]区间。</p><div class="note note-info">            <p>这里就发现和主键索引不同的地方了。二级索引可以利用索引下推直接在引擎层判断，如果一条记录不符合索引条件下推中的条件的话，直接跳到下一条记录（这个过程根本不将其返回到server层），如果这已经是最后一条记录，那么直接向server层报告查询完毕。但是这里头有个问题：先对一条记录加了锁，然后再判断该记录是不是符合索引条件下推的条件，如果不符合直接跳到下一条记录或者直接向server层报告查询完毕，这个过程中并没有把那条被加锁的记录上的锁释放掉呀！！！</p>          </div><ul><li><strong>情况七：a为非唯一索引  + delete/update + 范围查询</strong></li></ul><p><strong>①执行以下事务</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住（-，5]区间。</p><p><strong>②执行以下事务</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> test_lock2 <span class="hljs-keyword">where</span> a &lt;=<span class="hljs-number">5</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</code></pre><p>锁住（-，7)区间。</p><h3 id="锁的等待问题"><a href="#锁的等待问题" class="headerlink" title="锁的等待问题"></a>锁的等待问题</h3><p>通过以下命令查看表的锁情况</p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> information_schema.INNODB_LOCKS;</code></pre><p>通过以下命令查看处于堵塞状态的线程，并通过kill_blocking字段kill掉阻塞源</p><pre><code class="hljs csharp"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> sys.innodb_lock_waits</code></pre><p>以下代码在5.6版本运行</p><pre><code class="hljs mipsasm">SELECTr.trx_id <span class="hljs-keyword">waiting_trx_id,</span><span class="hljs-keyword">r.trx_mysql_thread_id </span><span class="hljs-keyword">waiting_thread,</span><span class="hljs-keyword">r.trx_query </span><span class="hljs-keyword">waiting_query,</span><span class="hljs-keyword">b.trx_id </span><span class="hljs-keyword">blocking_trx_id,</span><span class="hljs-keyword">b.trx_mysql_thread_id </span><span class="hljs-keyword">blocking_thread</span><span class="hljs-keyword">FROM</span><span class="hljs-keyword">information_schema.innodb_lock_waits </span>wINNER <span class="hljs-keyword">JOIN</span><span class="hljs-keyword">information_schema.innodb_trx </span><span class="hljs-keyword">b </span>ON <span class="hljs-keyword">b.trx_id </span>= w.<span class="hljs-keyword">blocking_trx_id</span><span class="hljs-keyword">INNER </span><span class="hljs-keyword">JOIN</span><span class="hljs-keyword">information_schema.innodb_trx </span>r ON r.trx_id = w.requesting_trx_id;</code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="七、业务设计"><a href="#七、业务设计" class="headerlink" title="七、业务设计"></a>七、业务设计</h2><h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><p>第一大范式</p><p>第二大范式</p><p>第三大范式：两个非主键列不能都依赖于主键而又相互有关联</p><p>但是，由于完全遵守三大范式，会造成大量的表必须相关联，因此往往我们会选择一些反范式设计，虽然会造成一些表的冗余，这种反范式设计就是用空间来换取时间。</p><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>开启慢查询记录运行时间超过阈值的sql语句日志。</p><p>可以使用pt_query_digest   Mysqldumpslow来分析慢查询日志</p><h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><h2 id="八、Mysql优化"><a href="#八、Mysql优化" class="headerlink" title="八、Mysql优化"></a>八、Mysql优化</h2><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p><strong>1.执行顺序</strong></p><p>相同ID，由上至下执行</p><p>不同ID，ID越大越先执行</p><p> <strong>2.select_type 列</strong></p><p><img src="/img/explain_select_type.png"></p><div class="note note-info">            <p>SUBQUERY是在where或者select里的子查询</p><p>DERIVED是在from里的子查询</p>          </div><p><strong>3.type列</strong></p><p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p><div class="note note-info">            <p>const使用主键或者唯一索引一次就找到一个</p><p>eq_ref是联表查询里用到了唯一索引</p>          </div><p><strong>4.possible_keys  与 Key</strong></p><p>怎么判断有没有用到索引：   key</p><p>怎么判断有没有充分用到索引： key_len</p><p>key_len 越短越好 既对也不对。 对是因为确实字段采用长度更小的数值类型越好，不对是因为充分使用索引 要比 不充分使用索引 的key_len要长</p><table><thead><tr><th>列类型</th><th>KEY_LEN</th><th>备注</th></tr></thead><tbody><tr><td>id int</td><td>key_len = 4+1</td><td>int为4bytes,允许为NULL,加1byte</td></tr><tr><td>id bigint not null</td><td>key_len=8</td><td>bigint为8bytes</td></tr><tr><td>user char(30) utf8</td><td>key_len=30*3+1</td><td>utf8每个字符为3bytes,允许为NULL,加1byte</td></tr><tr><td>user varchar(30) not null utf8</td><td>key_len=30*3+2</td><td>utf8每个字符为3bytes,变长数据类型,加2bytes</td></tr><tr><td>user varchar(30) utf8</td><td>key_len=30*3+2+1</td><td>utf8每个字符为3bytes,允许为NULL,加1byte,变长数据类型,加2bytes</td></tr><tr><td>detail text(10) utf8</td><td>key_len=30*3+2+1</td><td>TEXT截取部分,被视为动态列类型。</td></tr></tbody></table><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><p>使用 ENUM 而不是 VARCHAR  </p><p>　　ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表 上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。  </p><p>　　如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或 “部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。  </p><h2 id="九、记录一些其他知识点"><a href="#九、记录一些其他知识点" class="headerlink" title="九、记录一些其他知识点"></a>九、记录一些其他知识点</h2><h3 id="简单讲讲oracle和mysql"><a href="#简单讲讲oracle和mysql" class="headerlink" title="简单讲讲oracle和mysql"></a>简单讲讲oracle和mysql</h3><p><strong>①并发性</strong></p><p>Mysql以表级锁为主。InnoDB引擎的表可以用行级锁，其依赖于表的索引。oracle使用行级锁，对资源锁定的粒度要小很多</p><p><strong>②一致性</strong></p><p>oracle支持serializable的隔离级别，可以实现最高级别的读一致性。mysql支持到RC隔离级别</p><p><strong>③事务</strong></p><p>Oracle支持事务，mysql的innodb支持事务</p><p><strong>④持久性</strong></p><p>oracle：保证提交的数据均可恢复，因为oracle把提交的sql操作线写入了在线联机日志文件中，保持到了磁盘上，如果出现数据库或主机异常重启，重启后oracle可以考联机在线日志恢复客户提交的数据。</p><p>mysql：默认提交sql语句，但如果更新过程中出现db或主机重启的问题，也许会丢失数据。</p><p><strong>⑤逻辑备份</strong></p><p> oracle逻辑备份时不锁定数据，且备份的数据是一致的。</p><p>  mysql逻辑备份时要锁定数据，才能保证备份的数据是一致的</p><p><strong>⑥热备份</strong></p><p>oracle有成熟的热备工具rman，热备时，不影响用户使用数据库。即使备份的数据库不一致，也可以在恢复时通过归档日志和联机重做日志进行一致的回复。</p><p>mysql：myisam的引擎，用mysql自带的mysqlhostcopy热备时，需要给表加读锁，影响dml操作。innodb的引擎，它会备份innodb的表和索引，但是不会备份.frm文件。用ibbackup备份时，会有一个日志文件记录备份期间的数据变化，因此可以不用锁表，不影响其他用户使用数据库。但此工具是收费的。innobackup是结合ibbackup使用的一个脚本，他会协助对.frm文件的备份。</p><p><strong>⑦sql语句的扩展和灵活性</strong></p><p>mysql对sql语句有很多非常实用而方便的扩展，比如limit功能，insert可以一次插入多行数据，select某些管理数据可以不加from。</p><p>  oracle在这方面感觉更加稳重传统一些。</p><p><strong>⑧复制</strong></p><p>oracle：既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。</p><p> mysql：复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。</p><p><strong>⑨性能诊断</strong></p><p>  oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等</p><p>  mysql的诊断调优方法较少，主要有慢查询日志。</p><p><strong>⑩权限与安全</strong></p><p>  mysql的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。</p><p>  oracle的权限与安全概念比较传统，中规中矩。</p><p><strong>⑪分区表和分区索引</strong></p><p>  oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。</p><p>  mysql的分区表还不太成熟稳定。</p><h3 id="MySQL各版本更新记录"><a href="#MySQL各版本更新记录" class="headerlink" title="MySQL各版本更新记录"></a>MySQL各版本更新记录</h3><p>5.5   默认存储引擎更改为innodb</p><p>​         写缓冲池从insertbuffer -&gt; changebuffer</p><p>5.6   加入索引下推</p><p>5.7   加入json数据类型</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>关系型数据库与非关系型数据库 <a href="https://blog.csdn.net/oChangWen/article/details/53423301">https://blog.csdn.net/oChangWen/article/details/53423301</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>InnoDB 和MyISAM的区别 <a href="https://blog.csdn.net/qq_35642036/article/details/82820178">https://blog.csdn.net/qq_35642036/article/details/82820178</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>意向锁 <a href="https://juejin.im/post/6844903666332368909">https://juejin.im/post/6844903666332368909</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>索引下推 <a href="https://www.cnblogs.com/Chenjiabing/p/12600926.html">https://www.cnblogs.com/Chenjiabing/p/12600926.html</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>MRR <a href="https://zhuanlan.zhihu.com/p/110154066">https://zhuanlan.zhihu.com/p/110154066</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>不错的整理贴 <a href="https://juejin.im/post/6850037271233331208#heading-50">https://juejin.im/post/6850037271233331208#heading-50</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>加锁流程分析 <a href="https://zhuanlan.zhihu.com/p/144471126">https://zhuanlan.zhihu.com/p/144471126</a><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>间隙锁 <a href="https://www.jianshu.com/p/42e60848b3a6">https://www.jianshu.com/p/42e60848b3a6</a><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span>比较全面的加锁流程分析 <a href="https://blog.csdn.net/bjweimengshu/article/details/90056126">https://blog.csdn.net/bjweimengshu/article/details/90056126</a><a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:10" class="footnote-text"><span>MySQL唯一索引和普通索引运行原理和使用选择 <a href="https://blog.csdn.net/Srodong/article/details/88838046">https://blog.csdn.net/Srodong/article/details/88838046</a><a href="#fnref:10" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:11" class="footnote-text"><span>缓冲池 <a href="https://www.sohu.com/a/322957463_178889">https://www.sohu.com/a/322957463_178889</a>       <a href="https://www.sohu.com/a/322166567_178889">https://www.sohu.com/a/322166567_178889</a><a href="#fnref:11" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:12" class="footnote-text"><span>MVCC <a href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a>       <a href="https://blog.csdn.net/Miaoshuowen/article/details/104838082">https://blog.csdn.net/Miaoshuowen/article/details/104838082</a><style>  /* 只设置  note字体 */  .note {    font-family: "Microsoft YaHei",Georgia, sans, serif, KaiTi,;    font-size: 14px;  }</style><a href="#fnref:12" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mybatis</title>
    <link href="/2021/01/01/MyBatis/"/>
    <url>/2021/01/01/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis知识点总结"><a href="#Mybatis知识点总结" class="headerlink" title="Mybatis知识点总结"></a>Mybatis知识点总结</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>MyBatis 是一个可以自定义 SQL、存储过程和高级映射的持久层框架</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>MyBatis 的缓存分为一级缓存和二级缓存。<img src="/img/mybatis1.png"></p><p>一级缓存放在 session 里面,默认就有。失效场景：①两次查询间使用插入    ②不同session    ③where条件不同的查询语句。源码在BaseExecutor中。Map存储。</p><p>二级缓存存放在它的命名空间里，默认是不打开的。开启二级缓存后，会使用 CachingExecutor 装饰 Executor，进入一级缓存的查询流程前，先在CachingExecutor 进行二级缓存的查询。当二级缓存开启后，同一个命名空间(namespace) 所有的操作语句，都影响着一个<strong>共同的 cache</strong>，也就是二级缓存被多个 SqlSession 共享，是一个<strong>全局的变量</strong>。当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。使用二级缓存属性类需要实现 Serializable 序列化 接口(可用来保存对象的状态)，可在它的映射文件中配置cache标签。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--开启二级缓存--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><span class="hljs-comment">&lt;!--使用二级缓存   Mapper接口--&gt;</span> @CacheNamespace<span class="hljs-comment">&lt;!--使用二级缓存   Mapper.xml--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">cache</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span><span class="hljs-comment">&lt;!--单个语句配置二级缓存   Mapper.xml--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;false&quot;</span></span><span class="hljs-tag"></span>&lt;!--单个语句配置二级缓存   Mapper接口--&gt; @Options(useCache = false)<span class="hljs-comment">&lt;!--单个语句配置刷新缓存   Mapper.xml--&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag"></span>&lt;!--配置redis分布式缓存   Mapper.xml--&gt; <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.caches.redis.RedisCache&quot;</span> /&gt;</span></code></pre><div class="note note-danger">            <p>多表操作会影响二级缓存，可能会得到脏数据。 用cache-ref标签 指向另一个命名空间能解决</p>          </div><p>二级缓存是表级缓存，开销大，没有一级缓存直接使用 HashMap 来存储的效率更高，所以<strong>二级缓存并不推荐使用</strong>。</p><h3 id="mybatis插件"><a href="#mybatis插件" class="headerlink" title="mybatis插件"></a>mybatis插件</h3><ul><li><strong>运行原理</strong></li></ul><p>Mybatis 通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能</p><p>MyBatis允许在已映射语句执行过程中的某一点进行拦截调用，默认情况下MyBatis允许使用插件来拦截的四大对象：</p><ol><li>Executor: 执行增删改查操作</li><li>StatementHandler: 处理SQL预编译，设置参数等相关工作</li><li>ParameterHandler: 设置预编译参数用的</li><li>ResultSetHandler: 处理结果集</li></ol><p>每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke()方法</p><ul><li><strong>自己编写</strong></li></ul><p>实现 Mybatis 的 Interceptor 接口并复写 intercept()方法</p><pre><code class="hljs java"><span class="hljs-comment">// ExamplePlugin.java</span><span class="hljs-meta">@Intercepts(&#123;@Signature(</span><span class="hljs-meta">  type= Executor.class,</span><span class="hljs-meta">  method = &quot;update&quot;,</span><span class="hljs-meta">  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExamplePlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;  <span class="hljs-keyword">private</span> Properties properties = <span class="hljs-keyword">new</span> Properties();  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <span class="hljs-comment">// implement pre processing if need</span>    Object returnObject = invocation.proceed();    <span class="hljs-comment">// implement post processing if need</span>    <span class="hljs-keyword">return</span> returnObject;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;    <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span> </span>&#123;    <span class="hljs-keyword">this</span>.properties = properties;  &#125;&#125;</code></pre><h3 id="Mybatis-Excutor"><a href="#Mybatis-Excutor" class="headerlink" title="Mybatis  Excutor"></a>Mybatis  Excutor</h3><p>Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。1）SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。2）ReuseExecutor：执行 update 或 select，以 sql 作为key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map3）BatchExecutor：完成批处理。</p><h3 id="和-的区别是什么"><a href="#和-的区别是什么" class="headerlink" title="#{}和${}的区别是什么"></a>#{}和${}的区别是什么</h3><p>1）#{}是预编译处理，${}是字符串替换。 </p><p>2）Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法 来赋值； </p><p>3）Mybatis 在处理${}时，就是把${}替换成变量的值。</p><p> 4）使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p><h3 id="Mybais和Hibernate"><a href="#Mybais和Hibernate" class="headerlink" title="Mybais和Hibernate"></a>Mybais和Hibernate</h3><table><thead><tr><th>Mybais</th><th>Hibernate</th></tr></thead><tbody><tr><td>半自动 ORM 映射工具， 动态sql</td><td>全自动 ORM 映射工具，据对象关系模型直接获取</td></tr><tr><td>简单易学</td><td>学习门槛高，要设计 O/R 映射，在性能和对象模型之间如何权衡</td></tr><tr><td>灵活度高，非常适合对关系数据模型要求不高的软件开发</td><td>Hibernate 对象/关系映射能力强，数据库无关性好，适合关系模型要求高的软件</td></tr></tbody></table><h3 id="接口绑定"><a href="#接口绑定" class="headerlink" title="接口绑定"></a>接口绑定</h3><ol><li>注解绑定</li><li>xml绑定</li></ol><h3 id="Dao工作原理"><a href="#Dao工作原理" class="headerlink" title="Dao工作原理"></a>Dao工作原理</h3><p> jdk 动态代理原理，运行时会为 dao 生成 proxy，代理对象会拦截接口方法，去执行对应的 sql 返回数据。</p><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>1）Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。<br>2）它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;uid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;cn.ideal.mapper.UserMapper.findById&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span></code></pre><h2 id="有趣的用法"><a href="#有趣的用法" class="headerlink" title="有趣的用法"></a>有趣的用法</h2><h3 id="批量插入，返回主键列表"><a href="#批量插入，返回主键列表" class="headerlink" title="批量插入，返回主键列表"></a>批量插入，返回主键列表</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;batchInsert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.util.List&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> &gt;</span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><style>  /* 只设置  note字体 */  .note {    font-family: "Microsoft YaHei",Georgia, sans, serif, KaiTi,;    font-size: 14px;  }</style><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Mybatis缓存 <a href="https://www.cnblogs.com/cxuanBlog/p/11333021.html">MyBatis 二级缓存全详解 - 程序员cxuan - 博客园 (cnblogs.com)</a><p><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Mybatis缓存 <a href="https://www.cnblogs.com/isdxh/p/13963636.html">Mybatis的二级缓存、使用Redis做二级缓存 - 邓晓晖 - 博客园 (cnblogs.com)</a><br><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Mybatis延迟加载 <a href="https://cloud.tencent.com/developer/article/1587223">https://cloud.tencent.com/developer/article/1587223</a><br><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>Mybatis手写插件 <a href="https://zhuanlan.zhihu.com/p/259908377#:~:text=MyBatis%E4%BD%BF,%E5%AE%89%E5%85%A8%E9%AB%98%E6%95%88%E7%9A%84%E6%8F%92%E4%BB%B6%E3%80%82">https://zhuanlan.zhihu.com/p/259908377#:~:text=MyBatis%E4%BD%BF,%E5%AE%89%E5%85%A8%E9%AB%98%E6%95%88%E7%9A%84%E6%8F%92%E4%BB%B6%E3%80%82</a><br><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>javal</title>
    <link href="/2021/01/01/java%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/01/01/java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="一、Java基本概念"><a href="#一、Java基本概念" class="headerlink" title="一、Java基本概念"></a>一、Java基本概念</h2><h3 id="1-1-Java语言的特点"><a href="#1-1-Java语言的特点" class="headerlink" title="1.1 Java语言的特点"></a>1.1 Java语言的特点</h3><h3 id="1-2-jvm-jdk-jre"><a href="#1-2-jvm-jdk-jre" class="headerlink" title="1.2 jvm jdk jre"></a>1.2 jvm jdk jre</h3><p>Jvm是运行字节码的虚拟机，jvm对于不同系统有特定实现，目的是使用相同字节码能得到相同结果</p><p>字节码 即为.class文件，不面向任何特定的处理器，只面向虚拟机。因此java程序无需重新编译便可在不同系统上运行。</p><h2 id="二、Java基本数据类型"><a href="#二、Java基本数据类型" class="headerlink" title="二、Java基本数据类型"></a>二、Java基本数据类型</h2><h3 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h3><table><thead><tr><th>基本类型</th><th>包装类型</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>int</td><td>Interger</td><td>32</td><td>4</td><td>0</td></tr><tr><td>short</td><td>Short</td><td>16</td><td>2</td><td>0</td></tr><tr><td>long</td><td>Long</td><td>64</td><td>8</td><td>0L</td></tr><tr><td>byte</td><td>Byte</td><td>8</td><td>1</td><td>0</td></tr><tr><td>char</td><td>Character</td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td>float</td><td>Float</td><td>32</td><td>4</td><td>0f</td></tr><tr><td>double</td><td>Double</td><td>64</td><td>8</td><td>0d</td></tr><tr><td>boolean</td><td>Boolean</td><td>1</td><td></td><td>false</td></tr></tbody></table><p>StringBuffer  线程安全          性能偏低</p><p>StringBuilder 线程不安全     性能较高</p><h3 id="2-2-自动拆装箱"><a href="#2-2-自动拆装箱" class="headerlink" title="2.2 自动拆装箱"></a>2.2 自动拆装箱</h3><p>装箱：valueOf</p><p>拆箱：xxValue</p><div class="note note-info">            <p>当 “==”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程</p>          </div><p>Reference:《阿里巴巴Java开发手册》</p><ul><li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li><li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ul><h3 id="2-3-基本数据类型与常量池"><a href="#2-3-基本数据类型与常量池" class="headerlink" title="2.3 基本数据类型与常量池"></a>2.3 基本数据类型与常量池</h3><p>Byte int short long [-128,127]</p><p>char [0,127]</p><p>Boolean true false</p><h2 id="三、Java语法"><a href="#三、Java语法" class="headerlink" title="三、Java语法"></a>三、Java语法</h2><h3 id="3-1-泛型"><a href="#3-1-泛型" class="headerlink" title="3.1 泛型"></a>3.1 泛型</h3><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了<strong>编译时类型安全检测机制</strong>，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p><strong>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</strong></p><p>关于泛型，？和泛型是非常值得讨论的事情。</p><ul><li>如果<strong>参数之间的类型有依赖关系</strong>，或者返<strong>回值是与参数之间有依赖关系</strong>的。那么就使用<strong>泛型方法</strong></li><li>如果<strong>没有依赖关系</strong>的，就使用<strong>通配符</strong>，通配符会<strong>灵活一些.</strong></li></ul><h3 id="3-2-反射"><a href="#3-2-反射" class="headerlink" title="3.2 反射"></a>3.2 反射</h3><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法</p><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</li></ul><p>本质是  获取Class对象。</p><p>为什么我们需要反射</p><p>反射提供了动态编译，最大程度地支持多态，而多态最大的意义在于降低类的耦合性</p><p>情景一：不得已而为之</p><p>有的类是我们在编写程序的时候无法使用new一个对象来实例化对象的。例如：</p><p>调用的是来自网络的二进制.class文件，而没有其.java代码；<br>注解 - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</p><p>情景二：动态加载（可以最大限度的体现Java的灵活性，并降低类的耦合性：多态）</p><p>有的类可以在用到时再动态加载到jvm中，这样可以减少jvm的启动时间，同时更重要的是可以动态的加载需要的对象（多态）。例如：</p><p>动态代理 - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</p><p>情景三：避免将程序写死到代码里</p><p>因为java代码是先通过编译器将.java文件编译成.class的二进制字节码文件，因此如果我们使用new Person()来实例化对象person会出现的问题就是如果我们希望更换person的实例对象，就要在源代码种更改然后重新编译再运行，但是如果我们将person的实例对象类名等信息编写在配置文件中，利用反射的Class.forName(className)方法来实例化java对象（因为实例化java对象都是根据全限定名查找到jvm内存中的class对象，并根据class对象中的累信息实例化得到java对象，因此xml文件中只要包含了权限定类名就可以通过反射实例化java对象），那么我们就可以更改配置文件，无需重新编译。例如：</p><p>开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p><h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><ol><li>定义一个接口及其实现类；</li><li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li></ol><h3 id="3-2-和equals"><a href="#3-2-和equals" class="headerlink" title="3.2 ==和equals"></a>3.2 ==和equals</h3><p><strong>基本数据类型==比较的是值，引用数据类型==比较的是内存地址</strong></p><p><strong><code>equals()</code></strong> : 它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。<code>equals()</code>方法存在于<code>Object</code>类中</p><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li>情况 1：类没有覆盖 <code>equals()</code>方法。则通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li>情况 2：类覆盖了 <code>equals()</code>方法。一般，我们都覆盖 <code>equals()</code>方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li></ul><h3 id="3-4-hashcode和equals"><a href="#3-4-hashcode和equals" class="headerlink" title="3.4 hashcode和equals"></a>3.4 hashcode和equals</h3><p><strong>1)概述</strong></p><p>hashcode和equals都存在于object类中</p><p>hashCode() 在散列表中才有用，在其它情况下没用</p><p>要用到散列表的情况下：</p><ul><li>两个对象相等，哈希值一定相等。</li><li>哈希值相等，两个对象不一定相等  即哈希冲突</li></ul><div class="note note-danger">            <p>要注意的是，对于”不会创建类对应的散列表”的情况来说，hashcode和equals没有任何关联，因为根本用不到hashcode</p>          </div><p><strong>2)为什么要有 hashCode？</strong></p><p>先计算对象的 hashcode 值来判断，相同则再使用equals比较，大大减少了 equals 的次数，相应就大大提高了执行速度</p><p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p><h3 id="3-5-java只有值传递"><a href="#3-5-java只有值传递" class="headerlink" title="3.5 java只有值传递"></a>3.5 java只有值传递</h3><p>无论是基本数据类型还是引用数据类型，传递后，使用的都是拷贝。</p><p>总结一下 Java 中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h3 id="3-6-深拷贝和浅拷贝"><a href="#3-6-深拷贝和浅拷贝" class="headerlink" title="3.6 深拷贝和浅拷贝"></a>3.6 深拷贝和浅拷贝</h3><ol><li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ol><h3 id="3-7-成员变量和局部变量"><a href="#3-7-成员变量和局部变量" class="headerlink" title="3.7 成员变量和局部变量"></a>3.7 成员变量和局部变量</h3><p><strong>Java有几种类型的变量：</strong></p><p>Jdk手册中所说：只有三种类型的变量：</p><ul><li>定义在类中的成员变量 — 被称为属性</li><li>定义在方法（包含构造方法）或者块代码中的变量 — 被称为局部变量</li><li>定义在方法定义中的变量 — 被称为参数</li></ul><p>其中，成员变量 = 类变量 + 实例变量。</p><p>总结区别：</p><ol><li>从语法形式上看:成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ol><h3 id="3-8-内部类"><a href="#3-8-内部类" class="headerlink" title="3.8 内部类"></a>3.8 内部类</h3><p><strong>成员内部类</strong></p><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象</p><p>成员内部类可以无条件地访问外部类的成员</p><p>外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问</p><p><strong>局部内部类</strong></p><p>局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的</p><p>它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内</p><p><strong>匿名内部类</strong></p><p>为了免去给内部类命名，或者只想使用一次，就可以选择使用匿名内部类。</p><p><strong>静态内部类</strong></p><p>1.要创建嵌套类的对象，并不需要其外围类的对象；</p><p>2.不能从嵌套类的对象中访问非静态的外围类对象（不能够从静态内部类的对象中访问外部类的非静态成员）；</p><p><strong>内部类有什么作用？</strong></p><p>1.内部类可以很好的实现隐藏 。一般的非内部类，是不允许有 private 与protected权限的，但内部类可以 </p><p>2．内部类拥有外围类的所有元素的访问权限 (private修饰也能访问) </p><p>3.可是实现多重继承 (让多个内部类分别继承多个其他类，使外部类可以同时获取多个其他类的属性) </p><p>4.可以避免修改接口而实现同一个类中两种同名方法的调用。(外部类继承，让内部类实现接口)</p><div class="note note-info">            <p><strong>为什么成员内部类可以无条件访问外部类的成员？</strong></p><p>编译器会默认为成员内部类添加了一个指向外部类对象的引用。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对 Outter this&amp;0 引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>          </div><div class="note note-primary">            <p><strong>为什么局部内部类和匿名内部类只能访问局部final变量？</strong></p><p>外层方法结束后，变量生命周期结束，但内部类生命周期可能尚未结束。</p><p>为了能继续使用这个变量，java使用复制来解决。如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。</p><p>但是，既然是拷贝，也就意味着改变局部变量值会造成拷贝和原变量数据不一致的情况。</p><p>为了避免这种情况，规定局部变量必须声明为final，否则无法访问。</p>          </div><h2 id="四、Java面向对象"><a href="#四、Java面向对象" class="headerlink" title="四、Java面向对象"></a>四、Java面向对象</h2><h3 id="4-1-面向对象和面向过程"><a href="#4-1-面向对象和面向过程" class="headerlink" title="4.1 面向对象和面向过程"></a>4.1 面向对象和面向过程</h3><p>面向过程：性能比面向对象好。因为类的调用需要实例化，开销较大。</p><p>面向对象：易维护、易复用、易拓展。因为面向对象封装 继承 多态的特性使得可以设计出低耦合的系统。</p><p>那么面向过程性能一定比面向对象高吗？它不是根本原因，面向过程也要计算分配内存。Java性能不优秀的原因不是因为他是面向对象语言，是因为java是半编译语言，最终执行代码不是能直接执行的二进制机器代码</p><h3 id="4-2-面向对象三大特性"><a href="#4-2-面向对象三大特性" class="headerlink" title="4.2 面向对象三大特性"></a>4.2 面向对象三大特性</h3><p><strong>封装</strong></p><p><strong>继承</strong></p><p>继承的优点是代码重用。 但其本意仍然是抽象。<br>继承 最好的使用场景是继承抽象类</p><p><strong>多态</strong></p><p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p><h3 id="4-3-抽象类和接口"><a href="#4-3-抽象类和接口" class="headerlink" title="4.3 抽象类和接口"></a>4.3 抽象类和接口</h3><p>语法上讲。接口只能有static final变量。接口方法默认是public abstract，且不能有实现（java8</p><p>开始可以有默认实现）抽象类方法可以是public protected这些但不能是private。</p><p>概念上讲，抽象类是对类的抽象，是一种模板设计。接口是一种完全抽象，是对行为的抽象。</p><p>在jdk8中。 Static和default方法可以有方法体。default方法属于实例,static方法属于类(接口)如果一个实现类 继承了两个接口(这两个接口没有继承关系,有同名的默认方法),那么必须在实现类,显示声明,否则编译器不知道调用哪个而报错</p><h2 id="五、异常"><a href="#五、异常" class="headerlink" title="五、异常"></a>五、异常</h2><p><img src="/img/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code></p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常</p><h2 id="六、Java集合"><a href="#六、Java集合" class="headerlink" title="六、Java集合"></a>六、Java集合</h2><h3 id="6-1-集合概述"><a href="#6-1-集合概述" class="headerlink" title="6.1 集合概述"></a>6.1 集合概述</h3><p><img src="/img/java%E9%9B%86%E5%90%88.png"></p><p><strong>List</strong> </p><ul><li>Arraylist ： Object[] 数组 </li><li>Vector ： Object[] 数组 </li><li>LinkedList ： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><p><strong>Set</strong> </p><ul><li>HashSet （⽆序，唯⼀）: 基于 HashMap 实现的，底层采⽤ HashMap 来保存元素 </li><li>LinkedHashSet ： LinkedHashSet 是 HashSet 的⼦类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现⼀样，不过还是有⼀点点区别的 </li><li>TreeSet （有序，唯⼀）： 红⿊树(⾃平衡的排序⼆叉树)</li></ul><h3 id="6-2-List"><a href="#6-2-List" class="headerlink" title="6.2 List"></a>6.2 List</h3><p><strong>Arraylist 与 LinkedList 区别?</strong></p><ol><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h3 id="6-3-Set"><a href="#6-3-Set" class="headerlink" title="6.3 Set"></a>6.3 Set</h3><p><strong>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</strong></p><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p><p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，能够按照添加的顺序遍历；</p><p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p><h3 id="6-4-线程安全的集合类"><a href="#6-4-线程安全的集合类" class="headerlink" title="6.4 线程安全的集合类"></a>6.4 线程安全的集合类</h3><ol><li><p>使用Collections工具类下的Collections.synchronizedList(new ArrayList<E>());</p></li><li><p>Concurrent包中的</p></li></ol><p>ConcurrentHashMap</p><p>CopyOnWriteArrayList</p><p>ConcurrentLinkedQueue</p><h3 id="6-5-ArrayList-的扩容机制"><a href="#6-5-ArrayList-的扩容机制" class="headerlink" title="6.5 ArrayList 的扩容机制"></a>6.5 ArrayList 的扩容机制</h3><p><strong>初始化</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Constructs an empty list with the specified initial capacity.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  initialCapacity  the initial capacity of the list</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span><span class="hljs-comment"> *         is negative</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+                                           initialCapacity);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Constructs an empty list with an initial capacity of ten.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Constructs a list containing the elements of the specified</span><span class="hljs-comment"> * collection, in the order they are returned by the collection&#x27;s</span><span class="hljs-comment"> * iterator.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> c the collection whose elements are to be placed into this list</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;    elementData = c.toArray();    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)            elementData = Arrays.copyOf(elementData, size, Object[].class);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// replace with empty array.</span>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><p>三种初始化方式：</p><p>ArrayList()：  大小为10的数组。并不是一开始就是10，而是第一次add赋予的10</p><p>ArrayList(int initialCapacity)：根据initialCapacity初始化object数组</p><p>ArrayList(Collection&lt;? extends E&gt; c)：集合-&gt;数组-&gt;集合</p><p><strong>扩容</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">// size是当前集合拥有的元素个数</span>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>    elementData[size++] = e;     <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// 当前 elementData是否为空数组(即初始化容量为0或者调用了无参构造函数后的结果)，如果是，则使用DEFAULT_CAPACITY和minCapacity较大的那一个</span>    <span class="hljs-comment">// DEFAULT_CAPACITY 默认为10， 而minCapacity为size + 1</span>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);     &#125;    <span class="hljs-keyword">return</span> minCapacity;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    modCount++;     <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)        grow(minCapacity);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;    <span class="hljs-comment">// int newCapacity = oldCapacity + oldCapacity / 2；即容量扩大为原来的1.5倍</span>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)        newCapacity = minCapacity;    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();        <span class="hljs-comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span>        <span class="hljs-comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span>        <span class="hljs-comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span>        <span class="hljs-comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?            Integer.MAX_VALUE :            MAX_ARRAY_SIZE;    &#125;</code></pre><div class="note note-info">            <p>当进行add操作，进入<code>ensureCapacityInternal()</code>，minCapacity值为size + 1</p><p>若使用无参构造函数初始化ArraryList后，由于为空数组，赋minCapacity为DEFAULT_CAPACITY和minCapacity较大的那一个，因此minCapacity会被赋为默认值10进入<code>ensureExplicitCapacity()</code>，</p><p>若minCapacity大于此时的数组长度，会进入grow方法，开始正式扩容。若数组长度扩大为1.5倍后仍未达到minCapacity的要求，则选用minCapacity作为扩容后长度。</p><p>若扩容后超出最大值，进入hugeCapacity方法。若minCapacity大，将Integer.MAX_VALUE作为新数组的大小，若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小。</p>          </div><p>当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code>方法 ，所以 minCapacity 此时为10。此时，minCapacity - elementData.length &gt; 0 成立，所以会进入 <code>grow()</code>(minCapacity) 方法。</p><p>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。</p><p>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</p><p>直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</p><p><strong>ArrayList</strong> <strong>每次扩容之后容量都会变为原来的</strong> <strong>1.5</strong> <strong>倍左右</strong></p><h3 id="6-6-正确的数组转集合"><a href="#6-6-正确的数组转集合" class="headerlink" title="6.6 正确的数组转集合"></a>6.6 正确的数组转集合</h3><p><strong>1. 最简便的方法(推荐)</strong></p><pre><code class="hljs java">List list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>))Copy to clipboardErrorCopied</code></pre><p><strong>2. 使用 Java8 的Stream(推荐)</strong></p><pre><code class="hljs java">Integer [] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;List myList = Arrays.stream(myArray).collect(Collectors.toList());<span class="hljs-comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span><span class="hljs-keyword">int</span> [] myArray2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</code></pre><p><strong>3. 使用 Apache Commons Collections</strong></p><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();CollectionUtils.addAll(list, str);</code></pre><h3 id="6-7-Map"><a href="#6-7-Map" class="headerlink" title="6.7 Map"></a>6.7 Map</h3><p><strong>HashMap 和 Hashtable 的区别</strong> </p><ol><li>线程是否安全： HashMap 是⾮线程安全的，HashTable 是线程安全的,因为 HashTable 内部的 ⽅法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap 吧！）；</li><li>效率： 因为线程安全的问题，HashMap 要⽐ HashTable 效率⾼⼀点。另外，HashTable 基本被 淘汰，不要在代码中使⽤它； </li><li>对 Null key 和 Null value 的⽀持： HashMap 可以存储 null 的 key 和 value，但 null 作 为键只能有⼀个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会 抛出 NullPointerException。 </li><li>初始容量⼤⼩和每次扩充容量⼤⼩的不同 ： ① 创建时如果不指定容量初始值，Hashtable 默 认的初始⼤⼩为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化⼤⼩为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使⽤你给定的⼤⼩，⽽ HashMap 会将其扩充为 2 的幂次⽅⼤⼩（HashMap 中的 tableSizeFor() ⽅法保证，下⾯给出了源代码）。也就是说 HashMap 总是使⽤ 2 的幂作为 哈希表的⼤⼩,后⾯会介绍到为什么是 2 的幂次⽅。</li><li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于 阈值（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择 先进⾏数组扩容，⽽不是转换为红⿊树）时，将链表转化为红⿊树，以减少搜索时间。 Hashtable 没有这样的机制。</li></ol><p><strong>HashMap底层原理解析</strong></p><span class="label label-primary">JDK1.8之前</span><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，通过hash值判断当前元素存放的位置 ，如果当前位置存在元素的话，就判断该元素与要存⼊的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建⼀个链表数组，数组中每⼀格就是⼀个链 表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><span class="label label-primary">JDK1.8</span><p>JDK1.8 之后在解决哈希冲突时有了较⼤的变化，当链表⻓度⼤于阈值（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不 是转换为红⿊树）时，将链表转化为红⿊树，以减少搜索时间。</p><p><strong>HashMap 的长度为什么是 2 的幂次⽅</strong></p><p>①hash%length  等价于  hash&amp;(length-1)的前提是 length 是 2 的 n 次⽅，这样<strong>使用二进制操作也能提高运算效率</strong></p><p>②2 的幂次⽅-1 换算成二进制全是1，这样计算与运算的时候，对比下来<strong>碰撞几率更小，并且不会造成空间的浪费</strong>，毕竟0&amp;0 0&amp;1都是0，而1&amp;1为1 1&amp;0为0</p><p><strong>HashMap 有哪⼏种常⻅的遍历⽅式?</strong></p><ol><li><p>使用迭代器（Iterator）EntrySet 的方式进行遍历</p><pre><code class="hljs java">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;      Map.Entry&lt;Integer, String&gt; entry = iterator.next();      System.out.print(entry.getKey());      System.out.print(entry.getValue());    &#125;</code></pre></li></ol><ol start="2"><li><p>使用迭代器（Iterator）KeySet 的方式进行遍历 </p><pre><code class="hljs java">Iterator&lt;Integer&gt; iterator = map.keySet().iterator();   <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;     Integer key = iterator.next();     System.out.print(key);     System.out.print(map.get(key));   &#125;</code></pre></li></ol><ol start="3"><li><p>使用 For Each EntrySet 的方式进行遍历；</p><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;   System.out.print(entry.getKey());   System.out.print(entry.getValue());&#125;</code></pre></li></ol><ol start="4"><li><p>使用 For Each KeySet 的方式进行遍历；</p><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;      System.out.print(key);      System.out.print(map.get(key));    &#125;</code></pre></li></ol><ol start="5"><li><p>使用 Lambda 表达式的方式进行遍历；</p><p>map.forEach((key, value) -&gt; {</p></li><li><p>使用 Streams API 单线程的方式进行遍历；</p><p>map.entrySet().stream().forEach((entry) -&gt; {</p></li><li><p>使用 Streams API 多线程的方式进行遍历。</p><p>map.entrySet().parallelStream().forEach((entry) -&gt; {</p></li></ol><p><strong>从安全性来讲，我们应该使用迭代器提供的 <code>iterator.remove()</code> 方法来进行删除，这种方式是安全的在遍历中删除集合的方式，或者使用 Stream 中的 <code>filter</code> 过滤掉要删除的数据再进行循环，也是安全的操作方式</strong>。</p><p><strong>ConcurrentHashMap 和 Hashtable 的区别</strong></p><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><p><code>Hashtable</code> 使用 <code>synchronized</code> 来保证线程安全，是全表锁</p><p><code>ConcurrentHashMap</code> <strong>JDK1.7</strong> 使用分段锁，是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>。JDK1.8 的 <code>ConcurrentHashMap</code> 是 <strong>Node 数组 + 链表 / 红黑树</strong>。只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发</p><h3 id="6-8-阿里巴巴手册的小贴士"><a href="#6-8-阿里巴巴手册的小贴士" class="headerlink" title="6.8 阿里巴巴手册的小贴士"></a>6.8 阿里巴巴手册的小贴士</h3><p>【强制】不要在foreach循环进行元素的增删操作，请使用迭代器方式</p><p>【强制】使用Arrays.asList, 使用集合的各类方法会报错，因为asList返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，后台数据仍是数组。</p><h2 id="七、Java多线程"><a href="#七、Java多线程" class="headerlink" title="七、Java多线程"></a>七、Java多线程</h2><h3 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 概念</h3><p><strong>线程与进程</strong></p><p>同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p><p><strong>并发与并行</strong></p><ul><li><p>并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</p></li><li><p>并行： 单位时间内，多个任务同时执行。</p><p><strong>上下文切换</strong></p></li></ul><p>一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。</p><p>当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><h3 id="7-2-线程状态"><a href="#7-2-线程状态" class="headerlink" title="7.2 线程状态"></a>7.2 线程状态</h3><p>线程共包括以下 5 种状态:</p><p><strong>1.</strong> <strong>新建状态</strong>(New)：线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</p><p><strong>2.</strong> <strong>就绪状态</strong>(Runnable)：也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</p><p><strong>3.</strong> <strong>运行状态</strong>(Running)：线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</p><p><strong>4.</strong> <strong>阻塞状态</strong>(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p><ol><li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li><li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li><li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li></ol><p><strong>5.waiting</strong></p><p><strong>6.TIME_WAITING</strong></p><p><strong>7.终止</strong></p><h3 id="7-3-线程操作"><a href="#7-3-线程操作" class="headerlink" title="7.3 线程操作"></a>7.3 线程操作</h3><p><strong>①</strong> <strong>sleep(long millis):</strong> <strong>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）</strong></p><p>sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并没有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。</p><p>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。</p><p><strong>②</strong> **join():**指等待线程终止</p><p>主线程等待子线程的终止</p><p><strong>③</strong> **yield():**暂停当前正在执行的线程对象，并执行其他线程。</p><p>yield()应该做的是让当前运行线程回到可运行状态（就绪状态），以允许具有相同优先级的其他线程获得运行机会</p><p><strong>④</strong> **interrupt():**不要以为它是中断某个线程！它只是给线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！</p><div class="note note-danger">            <p><strong>面试题——sleep()和yield()的区别：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><p>①线程执行 sleep() 方法后进入超时等待状态；线程执行 yield() 方法转入就绪状态</p><p>②sleep 方法使当前运行中的线程睡一段时间，这段时间的长短是由程序设定的，yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则，继续运行原来的线程。执行yield()的线程有可能在进入到可执行状态后马上又被执行。所以yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程。</p><p>③sleep 允许较低优先级的线程获得运行机会，但 yield() 只会给相同优先级或者更高优先级的线程让出CPU</p><p>④sleep()方法声明抛出InterruptedException异常，而yield()方法没有声明抛出任何异常</p>          </div><div class="note note-danger">            <p><strong>面试题——sleep()和wait()的区别：</strong> </p>          </div> <div class="note note-success">            <p> 从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。</p><p>​    Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。</p>          </div><div class="note note-danger">            <p><strong>面试题——我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</strong></p>          </div> <div class="note note-success">            <p>调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</p>          </div><h3 id="7-4-死锁"><a href="#7-4-死锁" class="headerlink" title="7.4 死锁"></a>7.4 死锁</h3><p>死锁必须具备以下四个条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>如何避免死锁</p><p>破坏循环等待，及时释放资源。</p><h3 id="7-5-Synchronized"><a href="#7-5-Synchronized" class="headerlink" title="7.5 Synchronized"></a>7.5 Synchronized</h3><p><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><h4 id="三种应用方式"><a href="#三种应用方式" class="headerlink" title="三种应用方式"></a>三种应用方式</h4><ul><li>修饰实例方法</li></ul><p>锁住的是实例对象。</p><p>当一个线程正在访问一个对象的 synchronized 实例方法，其他线程无法访问此实例方法，无法获取锁，无法访问其他synchronized，可以访问其他非synchronized方法</p><ul><li>修饰静态方法</li></ul><p>锁住的是Class对象</p><p>线程A访问static synchronized方法与线程B访问synchronized非static方法，是不互斥的</p><ul><li>修饰代码块：</li></ul><p>需要自己提供锁对象，锁对象包括对象本身（this）、对象的Class和其他对象</p><div class="note note-danger">            <p><strong>面试题——构造方法可以使用synchronized关键字吗？</strong></p>          </div> <div class="note note-success">            <p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>          </div><h4 id="代码块底层原理"><a href="#代码块底层原理" class="headerlink" title="代码块底层原理"></a>代码块底层原理</h4><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充</p><p>对象头中的指针指向monitor，每个对象都存在着一个 monitor 与之关联，在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下</p><pre><code class="hljs c++">ObjectMonitor() &#123;    _header       = <span class="hljs-literal">NULL</span>;    _count        = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录个数</span>    _waiters      = <span class="hljs-number">0</span>,    _recursions   = <span class="hljs-number">0</span>;    _object       = <span class="hljs-literal">NULL</span>;    _owner        = <span class="hljs-literal">NULL</span>;    _WaitSet      = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//处于wait状态的线程，会被加入到_WaitSet</span>    _WaitSetLock  = <span class="hljs-number">0</span> ;    _Responsible  = <span class="hljs-literal">NULL</span> ;    _succ         = <span class="hljs-literal">NULL</span> ;    _cxq          = <span class="hljs-literal">NULL</span> ;    FreeNext      = <span class="hljs-literal">NULL</span> ;    _EntryList    = <span class="hljs-literal">NULL</span> ; <span class="hljs-comment">//处于等待锁block状态的线程，会被加入到该列表</span>    _SpinFreq     = <span class="hljs-number">0</span> ;    _SpinClock    = <span class="hljs-number">0</span> ;    OwnerIsThread = <span class="hljs-number">0</span> ;  &#125;</code></pre><p>ObjectMonitor中有两个队列，WaitSet 和 EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</p><p><img src="/img/synchronized_monitor.png"></p><p>由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因。另外，**<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。**</p><p>进一步分析：</p><pre><code class="hljs c"><span class="hljs-number">3</span>: monitorenter  <span class="hljs-comment">//进入同步方法 </span><span class="hljs-number">15</span>: monitorexit   <span class="hljs-comment">//退出同步方法</span><span class="hljs-number">16</span>: <span class="hljs-keyword">goto</span>          <span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">//退出同步方法</span></code></pre><p>当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p><div class="note note-info">            <p><strong>synchronized修饰代码块原理总结</strong>：字节码层面上，一个线程执行monitorenter指令时，当前线程将试图获取对象对应的 monitor 的持有权。每个Java对象的对象头中都存储了一个指向monitor对象的指针。线程获取锁的过程是进入monitor对象的 _EntryList 集合，成功获取到monitor 的线程进入 _Owner 区域，owner变量被设置为此线程，同时计数器count加1。线程执行完毕，monitorexit指令被执行，释放锁的过程是owner变量恢复为null，count减1。</p>          </div><h4 id="修饰方法底层原理"><a href="#修饰方法底层原理" class="headerlink" title="修饰方法底层原理"></a>修饰方法底层原理</h4><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。下面我们看看字节码层面如何实现：</p><pre><code class="hljs c"> <span class="hljs-comment">//==================syncTask方法======================</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">syncTask</span><span class="hljs-params">()</span></span>;    descriptor: ()V    <span class="hljs-comment">//方法标识ACC_PUBLIC代表public修饰，ACC_SYNCHRONIZED指明该方法为同步方法</span>    flags: ACC_PUBLIC, ACC_SYNCHRONIZED    Code:      <span class="hljs-built_in">stack</span>=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: dup         <span class="hljs-number">2</span>: getfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field i:I</span>         <span class="hljs-number">5</span>: iconst_1         <span class="hljs-number">6</span>: iadd         <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field i:I</span>        <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">12</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">13</span>: <span class="hljs-number">10</span>&#125;</code></pre><p>从字节码中可以看出，synchronized修饰的方法并没有monitorenter指令和monitorexit指令，取得代之的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><div class="note note-info">            <p><strong>synchronized修饰方法原理总结</strong>：<code>synchronized</code>方法在<code>method_info</code>结构有<code>AAC_synchronized</code>标记，线程在执行的时候获取对应的锁，从而实现同步方法</p>          </div><h4 id="java对synchronized的优化"><a href="#java对synchronized的优化" class="headerlink" title="java对synchronized的优化"></a>java对synchronized的优化</h4><p>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。</p><p>锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级</p><span class="label label-primary">偏向锁</span><p>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且<strong>总是由同一线程多次获得</strong>，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，<strong>当这个线程再次请求锁时，无需再做任何同步操作</strong>，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><span class="label label-primary">轻量级锁</span><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“<strong>对绝大部分的锁，在整个同步周期内都不存在竞争</strong>”，注意这是经验数据。需要了解的是，<strong>轻量级锁所适应的场景是线程交替执行同步块的场合</strong>，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><span class="label label-primary">自旋锁</span><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，<strong>线程持有锁的时间都不会太长</strong>，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，**因此虚拟机会让当前想要获取锁的线程做几个空循环(**这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p><span class="label label-primary">锁消除</span><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，<strong>去除不可能存在共享资源竞争的锁</strong>，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间</p><p><strong>synchronized 的一些关键点</strong></p><p><strong>可重入性</strong></p><p>当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功。比如说，一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的。</p><p><strong>线程中断与synchronized</strong></p><p>对于synchronized来说，如果一个线程在等待锁，那么结果只有两种，要么它获得这把锁继续执行，要么它就保存等待，即使调用中断线程的方法，也不会生效</p><p><strong>等待唤醒机制与synchronized</strong></p><p>所谓等待唤醒机制本篇主要指的是notify/notifyAll和wait方法，在使用这3个方法时，必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常，这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，在前面的分析中，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。</p><h4 id="synchronized和Lock"><a href="#synchronized和Lock" class="headerlink" title="synchronized和Lock"></a>synchronized和Lock</h4><p><code>synchronized</code>是Java中的关键字，是Java的内置实现。<code>Lock</code>是Java中的接口。<code>synchronized</code> 是依赖于 JVM 实现的</p><p><code>synchronized</code>不能去尝试获得锁，没有获得锁就会被阻塞； <code>Lock</code>可以去尝试获得锁，如果未获得可以尝试处理其他逻辑。</p><p><code>synchronized</code>是不可以中断的，<code>Lock</code>可中断。</p><p>**ReentrantLock 比 synchronized的异同 **</p><p>二者都是可重入锁</p><p><code>ReentrantLock</code>基于接口实现  <code>synchronized</code>基于jvm</p><p><strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong>：</p><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p><p><strong>CAS</strong></p><p>CAS(compare and swap),中文为：比较并交换，是并发控制操作的基础。<br> CAS有三个值：内存值、原始值、修改值，如果原始值不等于内存值，返回false；如果等于则修改，返回true，并将内存值修改为修改值。<br> CAS是<strong>乐观锁</strong>用到的主要机制，乐观锁是不用加锁去执行操作，如果产生冲突则失败重试，直到成功为止，也叫做“自旋”。</p><h3 id="7-6-双重检测锁"><a href="#7-6-双重检测锁" class="headerlink" title="7.6 双重检测锁"></a>7.6 双重检测锁</h3><pre><code class="hljs java"><span class="hljs-comment">// 双重检测锁代码</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentFactory</span> </span>&#123;    <span class="hljs-keyword">private</span> Student student;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(student == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;                <span class="hljs-keyword">if</span>(student == <span class="hljs-keyword">null</span>)&#123;                    <span class="hljs-comment">// 以下语句实现由三步构成</span>                    <span class="hljs-comment">// （1）申请堆空间</span>                    <span class="hljs-comment">// （2）使用对象的初始化数据初始化堆空间</span>                    <span class="hljs-comment">// （3）student引用指向堆空间</span>                    student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">24</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> stuent;    &#125;&#125;</code></pre><p>为何会出现线程安全呢？</p><p>①共享数据，这里是个单例bean</p><p>②“三步构成”顺序不一定固定，即不具备原子性，这是因为JVM 具有指令重排的特性</p><p>因此会出现在申请完空间后直接引用指向，从而在瞬时的第二次进入方法时判断为非空，返回了一个（null， 0）的student对象。</p><pre><code class="hljs java"><span class="hljs-comment">// 第一种解决方案</span><span class="hljs-comment">// 同步方法，使之成为一个串行逻辑，相当垃圾啊</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 第二种解决方案</span><span class="hljs-comment">// 成员变量声明为validate  volatile 可以禁止 JVM 的指令重排</span><span class="hljs-keyword">private</span> validate Student student;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 第三种解决方案</span><span class="hljs-comment">// Integer Long Boolean的成员变量可以使用Atomic类</span><span class="hljs-keyword">private</span> AtomicLong value；</code></pre><h3 id="7-7-Violatile"><a href="#7-7-Violatile" class="headerlink" title="7.7 Violatile"></a>7.7 Violatile</h3><p><strong>Violatile的两大特点：</strong></p><ul><li>防止指令重排</li><li>保证数据的可见性</li></ul><p><strong>volatile保证可见性底层原理</strong></p><ol><li>写操作，发送Lock前缀的指令，引起处理器缓存写回内存；</li><li><strong>通过CPU 总线嗅探机制</strong>通知其他线程该变量副本已经失效，需要重新从主内存中读取。</li></ol><p><strong>volatile防止指令重排底层原理</strong></p><p>内存屏障指令</p><ul><li>在每个 volatile 读操作的后面插入 LoadLoad 屏障和 LoadStore 屏障。</li><li>在每个 volatile 写操作的前后分别插入一个 StoreStore 屏障和一个 StoreLoad 屏障。</li></ul><p> <strong>synchronized 关键字和 volatile 关键字的区别</strong></p><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><code>volatile</code> 关键字是线程同步的<strong>轻量级实现</strong>，所以<code>volatile </code>性能肯定比<code>synchronized</code>关键字要好。但是<code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块。</li><li><code>volatile</code> 关键字<strong>能保证数据的可见性，但不能保证数据的原子性</strong>。volatile 可以使纯赋值操作是原子的。<code>synchronized</code> 关键字两者都能保证。</li><li><code>volatile</code>关键字主要用于解决变量在多个线程之间的<strong>可见性</strong>，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的<strong>同步性</strong>。</li></ul><h3 id="7-8-JMM与happens-before"><a href="#7-8-JMM与happens-before" class="headerlink" title="7.8  JMM与happens-before"></a>7.8  JMM与happens-before</h3><p><strong>并发编程的三个重要特性</strong></p><ol><li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong> ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><p><strong>JMM介绍</strong></p><p>JMM（Java Memory Model）：Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层不同计算机的区别。也就是说，JMM 是 JVM 中定义的一种并发编程的底层模型机制。</p><p>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。</p><p><strong>happens-before</strong></p><p>JMM使用happens-before的概念来阐述多线程之间的内存可见性。</p><blockquote><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</p></blockquote><ul><li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li><li>start() 规则：Thread.start() 的调用会 happens-before 于启动线程里面的动作。</li><li>join() 规则：Thread 中的所有动作都 happens-before 于其他线程从 Thread.join() 中成功返回。</li></ul><h3 id="7-9-ThreadLocal"><a href="#7-9-ThreadLocal" class="headerlink" title="7.9 ThreadLocal"></a>7.9 ThreadLocal</h3><p><strong>概念：存储每个线程的私有数据</strong></p><p><strong>原理：</strong></p><p>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。 <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><strong>内存泄露问题</strong></p><p> key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry</p><h3 id="7-10-线程池"><a href="#7-10-线程池" class="headerlink" title="7.10 线程池"></a>7.10 线程池</h3><p><strong>创建线程的方式</strong></p><ol><li>继承Thread</li><li>实现runnable接口</li><li>实现callable接口   FutureTask</li><li>使用线程池</li></ol><p><code>Runnable</code> 接口不会返回结果或抛出检查异常，但是<code>Callable</code> 接口可以。</p><p><strong>线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><p><strong>线程池分类</strong></p><p>FixedThreadPool 线程数量固定的核心线程池  能快速响应</p><p>CachedThreadPool 无线程数量限制，任务会被立即执行  适合执行大量不耗时任务</p><p>ScheduledThreadPool  核心固定 非核心一旦空置会被回收  执行周期性任务</p><p>SingleThreadExecutor  一个核心线程</p><div class="note note-danger">            <p>FixedThreadPool和SingleThreadExecutor  使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列，可能会导致OOM</p><p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 Integer.MAX.VALUE，可能会导致OOM</p>          </div><p><strong>如何创建线程池</strong></p><p>构造方法  ThreadPoolExecutor</p><p>工具类 Executors </p><h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单</p><p><strong>Executor框架使用流程</strong></p><ol><li>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</li><li>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li><li>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li><li>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</li></ol><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><strong>ThreadPoolExecutor 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><strong>拒绝策略</strong></p><p>线程池中，有三个重要的参数，决定拒绝策略：corePoolSize - 核心线程数，也即最小的线程数 workQueue - 阻塞队列  maximumPoolSize - 最大线程数。</p><p>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到 maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</p><p>总结起来，也就是一句话，<strong>当提交的任务数大于（workQueue.size() + maximumPoolSize ），就会触发线程池的拒绝策略</strong>。</p><p><img src="/img/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png"></p><p>jdk默认提供了四种拒绝策略：</p><p>CallerRunsPolicy - 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</p><p>AbortPolicy - 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</p><p>DiscardPolicy - 直接丢弃，其他啥都没有</p><p>DiscardOldestPolicy - 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</p><h3 id="7-11-阻塞队列"><a href="#7-11-阻塞队列" class="headerlink" title="7.11 阻塞队列"></a>7.11 阻塞队列</h3><p>不需要再单独考虑同步和线程间通信的问题</p><span class="label label-primary">ArrayBlockingQueue</span>：基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列。<span class="label label-primary">LinkedBlockingQueue</span>：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE。<span class="label label-primary">PriorityBlockingQueue</span>：以上2种队列都是先进先出队列，而PriorityBlockingQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列。<span class="label label-primary">DelayQueue</span>：基于PriorityQueue，一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<p><strong>只要符合生产者-消费者模型的都可以使用阻塞队列</strong></p><h3 id="7-12-AQS"><a href="#7-12-AQS" class="headerlink" title="7.12 AQS"></a>7.12 AQS</h3><h4 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h4><p>AQS 是一个用来构建锁和同步器的框架</p><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p><strong>CLH</strong></p><p>定义了一个volatile修饰的共享变量state来表示同步状态。使用一个FIFO队列存储排队的线程资源。 使用 CAS 对该同步状态进行原子操作实现对其值的修改</p><p><strong>AQS 定义两种资源共享方式</strong></p><ul><li><p>Exclusive        <code>ReentrantLock</code></p><p>（独占）：只有一个线程能执行。又可分为公平锁和非公平锁：</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><p><strong>Share</strong>（共享）：多个线程可同时执行</p></li></ul><h4 id="AQS组件"><a href="#AQS组件" class="headerlink" title="AQS组件"></a>AQS组件</h4><p><strong>CountDownLatch</strong></p><p>这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</p><p>执行方countDownLatch.countDown();    等待方awit</p><p><strong>适用场景：</strong></p><ol><li>某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ：<code>new CountDownLatch(n)</code>，每当一个任务线程执行完毕，就将计数器减 1 <code>countdownlatch.countDown()</code>，当计数器的值变为 0 时，在<code>CountDownLatch上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li><li>实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 ：<code>new CountDownLatch(1)</code>，多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。</li></ol><p><strong>CyclicBarrier</strong> 回环栅栏</p><p>CyclicBarrier一般的使用场景是控制一组线程同时开始执行，就像跑步比赛一样，当所有运动员准备就绪才可以开始跑。</p><p><strong>Sephmore 信号量</strong></p><h3 id="7-13-Automic"><a href="#7-13-Automic" class="headerlink" title="7.13 Automic"></a>7.13 Automic</h3><p><strong>基本类型</strong></p><p>使用原子的方式更新基本类型</p><ul><li><code>AtomicInteger</code>：整形原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code>：布尔型原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li><code>AtomicIntegerArray</code>：整形数组原子类</li><li><code>AtomicLongArray</code>：长整形数组原子类</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类</li></ul><p><strong>引用类型</strong></p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li><code>AtomicIntegerFieldUpdater</code>：原子更新整形字段的更新器</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li></ul><h2 id="八、java8特性"><a href="#八、java8特性" class="headerlink" title="八、java8特性"></a>八、java8特性</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[^1]java多线程 <a href="https://juejin.im/post/6844903941830869006#heading-24">https://juejin.im/post/6844903941830869006#heading-24</a></p><p>[^2]java多线程 <a href="https://blog.csdn.net/haozhugogo/article/details/55050681">https://blog.csdn.net/haozhugogo/article/details/55050681</a></p><p>[^3]java并发之synchronized <a href="https://blog.csdn.net/javazejian/article/details/72828483">https://blog.csdn.net/javazejian/article/details/72828483</a></p><p>[^4]javaGuide guide哥的官网 <a href="https://snailclimb.gitee.io/javaguide/#/">https://snailclimb.gitee.io/javaguide/#/</a></p><p>[^5]j泛型 <a href="https://segmentfault.com/a/1190000014120746">https://segmentfault.com/a/1190000014120746</a></p><p>[^6]hashcode与equals <a href="https://www.cnblogs.com/skywang12345/p/3324958.html">https://www.cnblogs.com/skywang12345/p/3324958.html</a></p><p>[^7]内部类 <a href="https://www.runoob.com/w3cnote/java-inner-class-intro.html">https://www.runoob.com/w3cnote/java-inner-class-intro.html</a></p><p>[^8]讲的还不错的hashmap长度为何为2的幂次方 <a href="https://blog.csdn.net/gududedabai/article/details/85784161?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=1328679.26088.16162471776581913&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs">https://blog.csdn.net/gududedabai/article/details/85784161?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs&amp;dist_request_id=1328679.26088.16162471776581913&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.baidujs</a></p><p>[^9] 看起来还不错的hashmap解析，但是我还没看 <a href="https://www.cnblogs.com/skywang12345/p/3310835.html">https://www.cnblogs.com/skywang12345/p/3310835.html</a></p><p>[^10] 很好的图文分析：hashmap遍历 <a href="https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow">https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow</a></p><p>[^11]volatile <a href="https://zhuanlan.zhihu.com/p/138819184">https://zhuanlan.zhihu.com/p/138819184</a></p><p>[^12]拒绝策略 <a href="https://www.cnblogs.com/eric-fang/p/11584142.html">https://www.cnblogs.com/eric-fang/p/11584142.html</a></p><p>[^13]阻塞队列 <a href="https://www.cnblogs.com/dolphin0520/p/3932906.html">https://www.cnblogs.com/dolphin0520/p/3932906.html</a></p><p>[^14]反射 <a href="https://blog.csdn.net/tongdanping/article/details/103252352">https://blog.csdn.net/tongdanping/article/details/103252352</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>springboot</title>
    <link href="/2020/11/01/SpringBoot/"/>
    <url>/2020/11/01/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-学习笔记"><a href="#SpringBoot-学习笔记" class="headerlink" title="SpringBoot 学习笔记"></a>SpringBoot 学习笔记</h1><h2 id="一、Spring"><a href="#一、Spring" class="headerlink" title="一、Spring"></a>一、Spring</h2><h3 id="1-1-Spring概述"><a href="#1-1-Spring概述" class="headerlink" title="1.1 Spring概述"></a>1.1 Spring概述</h3><p>Spring框架是一个轻量级的企业级开发的一站式解决方案。是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。spring框架指spring framework，它集合了20多个模块协助程序员进行高效率的开发。</p><p>Spring使用简单的POJO来进行企业级开发。每一个被spring管理的java对象都称之为Bean，Spring使用IOC容器来初始化对象，解决对象间的依赖管理和对象的使用。</p><p><strong>Spring四大原则</strong></p><p>①使用POJO进行轻量级和最小侵入式开发</p><p>②通过依赖注入和基于接口编程实现松耦合</p><p>③通过AOP和默认习惯进行声明式编程</p><p>④使用AOP和模板减少模式化代码</p><h3 id="1-2-Spring模块结构"><a href="#1-2-Spring模块结构" class="headerlink" title="1.2 Spring模块结构"></a>1.2 Spring模块结构</h3><p><strong>Spring模块结构</strong></p><p>Spring 总共大约有 20 个模块，这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中</p><p><img src="/img/spring_kuangjia.png"></p><p>常用核心模块介绍：</p><p><strong>1、核心容器(Core)</strong></p><p>这是Spring框架最基础的部分，它提供了依赖注入（Dependency Injection）特征来实现容器对Bean的管理。这里最基本的概念是BeanFactory，它是任何Spring应用的核心。BeanFactory是工厂模式的一个实现，它使用IoC将应用配置和依赖说明从实际的应用代码中分离出来。</p><p><strong>2、AOP模块</strong></p><p>AOP即面向切面编程技术，Spring在它的AOP模块中提供了对面向切面编程的丰富支持。确保了Spring和其他AOP框架的共通性。这个模块将元数据编程引入Spring</p><p>AOP允许通过分离应用的业务逻辑与系统级服务（例如安全和事务管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或   支持。</p><p><strong>3、对象/关系映射集成模块ORM</strong></p><p>Spring通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring支持集成主流的ORM框架，如Hiberate,JDO和iBATISSQLMaps。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p><p><strong>4、JDBC抽象和DAO模块</strong></p><p>提供了一个JDBC的抽象层，简化了JDBC，保证了数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP模块给Spring应用中的对象提供事务管理服务</p><p><strong>5、Spring的Web模块</strong></p><p>Web上下文模块建立于applicaiton context之上，提供了一个适合于Web应用的上下文。另外，这个模块还提供了一些面向服务支持。例如：实现文件上传的multipart请求，它也提供了Spring和其它Web框架的集成，比如Struts、WebWork。</p><p><strong>6、应用上下文（Context）模块</strong></p><p>核心模块的BeanFactory使Spring成为一个容器，而上下文模块使它成为一个框架。Web上下文模块建立于应用上下文模块之上，提供了一个适合于Web应用的上下文。该模块还提供了一些面向服务支持这个模块扩展了BeanFactory的概念，增加了对国际化（I18N）消息、事件传播以及验证的支持。</p><p>另外，这个模块还提供了许多企业服务，例如电子邮件、JNDI访问、EJB集成、远程以及时序调度（scheduling）服务。也包括对模版框架例如Velocity和FreeMarker集成的支持。</p><p><strong>7、Spring的MVC框架</strong></p><p>Spring为构建Web应用提供了一个功能全面的MVC框架。虽然Spring可以很容易地与其它MVC框架集成，例如Struts2，但Spring的MVC框架使用IoC对控制逻辑和业务对象提供了完全的分离。</p><p><strong>8、Spring Aspects</strong> ：</p><p>该模块为与AspectJ的集成提供支持。</p><p><strong>9、Spring Test</strong> : </p><p>提供了对 JUnit 和 TestNG 测试的支持。</p><h3 id="1-3-IOC"><a href="#1-3-IOC" class="headerlink" title="1.3 IOC"></a>1.3 IOC</h3><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，用来减低代码耦合度。其思想是反转资源获取的方向。Spring IOC通过依赖注入来实现，所谓依赖注入指的是容器负责创建对象和维护对象间的依赖关系。</p><p>SpringIOC通过依赖注入，来创建对象和维护对象间的依赖关系并管理这些对象的整个生命周期。</p><span class="label label-success">IOC的优点是</span><p>①实现了松耦合</p><p>②使应用易于测试</p><p>③实现资源的可配置和易管理</p><h4 id="Spring-IOC容器"><a href="#Spring-IOC容器" class="headerlink" title="Spring IOC容器"></a>Spring IOC容器</h4><p>Spring 提供了以下两种不同类型的容器。</p><table><thead><tr><th>序号</th><th>容器 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td>BeanFactory 容器它是最简单的容器，给 DI 提供了基本的支持，它用 org.springframework.beans.factory.BeanFactory 接口来定义。</td></tr><tr><td>2</td><td>Spring ApplicationContext 容器是对BeanFactory的拓展，该容器添加了更多的企业特定的功能，例如从一个属性文件中解析文本信息的能力，发布应用程序事件给感兴趣的事件监听器的能力。该容器是由 org.springframework.context.ApplicationContext 接口定义。其主要有四种实现：<span class="label label-info">ClassPathXmlApplicationContext</span>、  <span class="label label-info">FileSystemXmlApplicationContext</span>、<span class="label label-info">XmlWebApplicationContext</span>、<span class="label label-info">AnnotationConfigApplicationContext（基于Java配置） | **面试题——FileSystemResource和ClassPathResource有何区别？：** 回答： 在FileSystemResource中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource文件放在ClassPath下。如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件（xml文件）中读取配置文件。 #### Bean的概述 bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。 Spring提供使用xml、注解、java配置实现bean的创建和注入，这些配置被称为配置元数据，所谓元数据即描述数据的数据。元数据本身不具备任何可执行能力，只能通过外界代码来对这些元数据进行解析后进行有意义的操作。 {% label success </span></td></tr></tbody></table><h4 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h4><p>@Scope：</p><ol><li>singleton   全容器共享一个实例 </li><li>prototype  每次调用新建</li><li>request      每一个http请求新建一个</li><li>session      每一个httpsession新建一个 </li><li>globalsession   每一个globalhttpsession新建一个 </li></ol><h4 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h4><p>beanfactory 负责管理bean的生命周期</p><p>Bean的生命周期可以表达为：Bean的定义——Bean的初始化——Bean的使用——Bean的销毁</p><ul><li>①通过构造器或工厂方法创建Bean实例</li><li>②为Bean的属性设置值和对其他Bean的引用</li><li>③BeanNameAware的setBeanName方法。</li><li>④BeanFactoryAware的setBeanFactory方法</li><li>⑤将Bean实例传递给Bean前置处理器的postProcessBeforeInitialization方法</li><li>⑥如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>⑦调用Bean的初始化方法(init-method)</li><li>⑧将Bean实例传递给Bean后置处理器的postProcessAfterInitialization方法</li><li>⑨Bean可以使用了</li><li>⑩当容器关闭时,调用Bean的销毁方法(destroy-method)</li></ul><p><img src="/img/bean_life.jpg"></p><p>java配置方式：initMethod和destroyMethod</p><p>xml配置：init-method和destroy-method</p><p> JSR-250 ：@PostConstruct 和 @PreDestroy 注解</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><table><thead><tr><th>序号</th><th>依赖注入类型 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td>Constructor-based dependency injection当容器调用带有多个参数的构造函数类时，实现基于构造函数的 DI，每个代表在其他类中的一个依赖关系。</td></tr><tr><td>2</td><td>Setter-based dependency injection基于 setter 方法的 DI 是通过在调用无参数的构造函数或无参数的静态工厂方法实例化 bean 之后容器调用 beans 的 setter 方法来实现的。</td></tr></tbody></table><p><strong>构造器注入总结：</strong></p><pre><code class="hljs java"><span class="hljs-comment">// Spring4.3+之后，constructor注入支持非显示注入方式。</span><span class="hljs-comment">// @Autowired</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DI</span><span class="hljs-params">(DependencyA dependencyA, DependencyB dependencyB, DependencyC dependencyC)</span> </span>&#123;    <span class="hljs-keyword">this</span>.dependencyA = dependencyA;    <span class="hljs-keyword">this</span>.dependencyB = dependencyB;    <span class="hljs-keyword">this</span>.dependencyC = dependencyC;&#125;</code></pre><span class="label label-success">优点</span><p>①能够保证注入的组件不可变，并且确保需要的依赖不为空</p><p>②构造器注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态</p><p>③依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更符合高内聚的原则</p><span class="label label-warning">缺点</span><p>①对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿。根据单一职责原则，此时应该考虑重构。</p><p>②可能会出现循环依赖问题</p><p><strong>setter注入总结：</strong></p><pre><code class="hljs java"><span class="hljs-comment">// setter注入</span><span class="hljs-meta">@Autowired</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDependencyA</span><span class="hljs-params">(DependencyA dependencyA)</span> </span>&#123;    <span class="hljs-keyword">this</span>.dependencyA = dependencyA;&#125;<span class="hljs-meta">@Autowired</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDependencyB</span><span class="hljs-params">(DependencyB dependencyB)</span> </span>&#123;    <span class="hljs-keyword">this</span>.dependencyB = dependencyB;&#125;</code></pre><span class="label label-success">优点</span><p>①setter的方式能让类在之后重新配置或者重新注入。</p><p>②允许为空，可以解决循环依赖问题</p><span class="label label-warning">缺点</span><p>①对于仅使用setter注入的依赖对象需要进行非空检查</p><span class="label label-primary">**最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖**</span><p><strong>字段注入总结：</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 字段注入</span><span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> DependencyA dependencyA; <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> DependencyB dependencyB;</code></pre><span class="label label-success">优点</span><p>①简洁、快捷</p><span class="label label-warning">缺点</span><p>①不易察觉违反单一职责原则</p><p>②有可能出现循环依赖问题，而且启动不会报错，只有在使用时才会报错。<br>③无法注入final<br>字段注入方式无法注入final字段，只有构造器注入才能注入final字段<br>④隐藏了依赖关系<br>外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖。使用依赖注入容器意味着类不再对依赖对象负责，获取依赖对象的职责从类中抽离出来，IoC容器会帮你装配。当类不再为依赖对象负责，它应该更明确的使用公有的接口方法或构造器，使用这种方式能很清晰的了解类需要什么，也能明确它是可选的(setter注入)还是强制的(构造器注入)。<br>⑤依赖注入容器紧耦合<br>依赖注入框架的核心思想之一就是受容器管理的类不应该去依赖容器所使用的依赖对象。换句话说，这个类应该是一个简单的POJO(Plain Ordinary Java Object)能够被单独实例化并且你也能为它提供它所需的依赖。只有这样，你才能在单元测试中实例化这个类而不必去启动依赖注入容器，实现测试分离(启动容器更多是集成测试)。然而，当使用变量直接注入时，没有一种方式能直接地实例化这个类并且满足其所有的依赖。这意味着需要手动new出来依赖对象或者只能在IoC Container范围使用。</p><h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p>自动装配是为了将依赖注入“自动化”的一个简化配置的操作</p><p>自动装配就是不使用<constructor-arg><code>和</code><property>注解进行依赖注入</p> <span class="label label-info">bean的自动装配模式：</span><ol><li>no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。</li><li>byName：根据bean名称设置依赖关系。<span class="label label-info">Resource注解使用byName</span></li><li>byType：根据bean类型设置依赖关系。<span class="label label-info">Autowired注解使用bytype</span></li><li>constructor：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。</li><li>autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。</li></ol><h3 id="1-4-Spring配置"><a href="#1-4-Spring配置" class="headerlink" title="1.4 Spring配置"></a>1.4 Spring配置</h3><p>将Spring配置到应用开发中有以下三种方式：1.基于XML的配置      2.基于注解的配置      3.基于Java的配置</p><p><strong>注解配置</strong></p><span class="label label-primary">声明Bean的注解：</span><p>@Component</p><p>@Service   service层</p><p>@Repository   dao层</p><p>@Controller    controller层</p><div class="note note-danger">            <p><strong>面试题——@Component和@Bean的区别：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><ol><li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ol>          </div><span class="label label-info">使用Bean的注解：</span><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@Required</td><td>注解应用于 bean 属性的 setter 方法。</td></tr><tr><td>@Autowired</td><td>@Autowired是spring自带的注解。可以应用到变量、setter方法、构造函数上。默认采用byType装配模式，可以配合@Qualifier按名称匹配。</td></tr><tr><td>@Resource</td><td>@Resource是JSR250规范的实现。可以写在字段上,或setter方法上。默认采用byName装配模式</td></tr><tr><td>@Inject</td><td>@Inject是JSR330中的规范。可以应用到变量、setter方法、构造函数上。默认采用byType装配模式。可以配合@Named按名称匹配。可以通过配置type属性使用byType装配模式</td></tr></tbody></table><p>@Autowired写在构造方法和写在变量上有何不同： </p><p>构造方法上即使用Constructor-based依赖注入</p><p>但是由于java变量的初始化顺序为静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法–&gt;@Autowired。因此在构造方法中调用@Autowired声明的变量会报错，因为执行构造方法时尚未执行@Autowired。</p><pre><code class="hljs java"><span class="hljs-number">1</span> <span class="hljs-meta">@Autowired</span><span class="hljs-number">2</span> <span class="hljs-keyword">private</span> User user;<span class="hljs-number">3</span> <span class="hljs-keyword">private</span> String school;<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserAccountServiceImpl</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-number">6</span>     <span class="hljs-keyword">this</span>.school = user.getSchool();  <span class="hljs-comment">//报错，尚未执行@Autowired</span><span class="hljs-number">7</span> &#125;</code></pre><pre><code class="hljs java"><span class="hljs-number">1</span> <span class="hljs-keyword">private</span> User user;<span class="hljs-number">2</span> <span class="hljs-keyword">private</span> String school;<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-meta">@Autowired</span><span class="hljs-number">5</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserAccountServiceImpl</span><span class="hljs-params">(User user)</span></span>&#123;<span class="hljs-number">6</span>     <span class="hljs-keyword">this</span>.user = user;<span class="hljs-number">7</span>     <span class="hljs-keyword">this</span>.school = user.getSchool();  <span class="hljs-comment">//正确</span><span class="hljs-number">8</span> &#125;</code></pre><p><strong>JAVA 配置</strong></p><p>@Configuration 声明为配置类</p><p>@Bean  注解在方法上，声明当前方法的返回值是一个Bean</p><span class="label label-info">在spring容器中，只要容器存在某个bean，就能在另一个bean的声明方法的参数中写入</span><div class="note note-danger">            <p><strong>面试题——什么是JAVA Config：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><p>SpringJavaConfig是Spring社区的产品，提供了配置SpringIoC容器的纯Java方法。优点是可以充分利用面向对象功能，减少xml配置，同时保证了类型安全和重构友好。</p>          </div><h3 id="1-5-AOP"><a href="#1-5-AOP" class="headerlink" title="1.5 AOP"></a>1.5 AOP</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p>OOP只有继承和实现，不仅使耦合度增强，继承也只能为单继承，AOP弥补了OOP的不足，使得一组类共享相同的行为</p><p>Spring支持AspectJ的注解式切面编程</p><pre><code class="hljs java"><span class="hljs-comment">// 编写拦截规则的注解——自定义注解</span><span class="hljs-meta">@Target(ElementType.METHOD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Action &#123;  <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>  <span class="hljs-comment">//定义切面</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">logAspect</span> </span>&#123;    <span class="hljs-meta">@Pointcut(&quot;&quot;)</span>   <span class="hljs-comment">// 定义切点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">annotationPointCut</span><span class="hljs-params">()</span></span>&#123;&#125;        <span class="hljs-meta">@After(&quot;annotationPointCut()&quot;)</span>   <span class="hljs-comment">// 定义建言</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">(JoinPoint point)</span></span>&#123;            &#125;    &#125;</code></pre><h3 id="1-6-Spring高级话题"><a href="#1-6-Spring高级话题" class="headerlink" title="1.6 Spring高级话题"></a>1.6 Spring高级话题</h3><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件（ApplicationEvent）为bean之间的消息通信提供了支持</p><p>Spring的事件遵循如下流程：</p><ol><li>定义事件</li><li>定义事件监听器</li><li>使用容器发布事件</li></ol><p>Spring提供了以下5种标准的事件：</p><ol><li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext接口中的refresh()方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 自定义event</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span></span>&#123;&#125;<span class="hljs-comment">//事件监听器。当此事件被发布后，会自动触发</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationEventListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ApplicationEvent</span>&gt; </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent applicationEvent)</span></span>&#123;  &#125;&#125;<span class="hljs-comment">//事件发布器</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoPublisher</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publish</span><span class="hljs-params">(String msg)</span></span>&#123;        applicationContext.publishEvent(<span class="hljs-keyword">new</span> DemoEvent(<span class="hljs-keyword">this</span>, msg));    &#125;&#125;</code></pre><h4 id="异步-Async"><a href="#异步-Async" class="headerlink" title="异步 @Async"></a>异步 @Async</h4><h4 id="计划任务-Scheduled"><a href="#计划任务-Scheduled" class="headerlink" title="计划任务 @Scheduled"></a>计划任务 @Scheduled</h4><h4 id="条件注解-Conditional"><a href="#条件注解-Conditional" class="headerlink" title="条件注解 @Conditional"></a>条件注解 @Conditional</h4><h4 id="Spring涉及的那些设计模式"><a href="#Spring涉及的那些设计模式" class="headerlink" title="Spring涉及的那些设计模式"></a>Spring涉及的那些设计模式</h4><ul><li>代理模式—在AOP和remoting中被用的比较多。</li><li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li><li>模板方法—用来解决代码重复的问题。比如.RestTemplate,JmsTemplate,JpaTemplate。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li><li>工厂模式—BeanFactory用来创建对象的实例</li></ul><h2 id="二、SpringMVC"><a href="#二、SpringMVC" class="headerlink" title="二、SpringMVC"></a>二、SpringMVC</h2><h3 id="2-1-SpringMVC概述"><a href="#2-1-SpringMVC概述" class="headerlink" title="2.1 SpringMVC概述"></a>2.1 SpringMVC概述</h3><p>model + view + controller</p><div class="note note-danger">            <p><strong>面试题——SpringMVC和三层架构的关系：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><p>三层架构指 展现层 应用层  数据访问层</p><p>MVC只存在展现层</p>          </div><div class="note note-danger">            <p><strong>面试题——Spring  SpringMVC Springboot的关系：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><p>SpringMVC是Spring的一个模块</p><p>SpringBoot建立在Spring框架之上，设计目的是为了简化spring的搭建和开发过程。</p>          </div><h3 id="2-2基本配置"><a href="#2-2基本配置" class="headerlink" title="2.2基本配置"></a>2.2基本配置</h3><p><strong>WebMvcConfigurerAdapter</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 静态资源配置</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 拦截器配置</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;    &#125;</code></pre><p><strong>ControllerAdvice</strong></p><p>将对于控制器的全局配置放在同一个位置</p><p>@ExceptionHandler  全局异常配置</p><p>@ModelAttribute   绑定键值对到model</p><p>@InitBinder  自动绑定前台参数到model</p><p><strong>Spring过滤器和拦截器的区别</strong></p><p>规范不同：过滤器是servlet规范中定义的；拦截器是spring容器内的 </p><p>使用范围不同：过滤器只能用于web程序；拦截器既可以用于web程序，也可以用于application程序中</p><p>使用的资源不同：拦截器是spring的组件，能使用spring容器中的所有资源，service对象等都能通过ioc注入其中。过滤器则不能</p><p>起效范围不同：过滤器只在servlet前后起效。拦截器能深入到方法、异常前后，具有更大的弹性</p><h2 id="三、SpringBoot"><a href="#三、SpringBoot" class="headerlink" title="三、SpringBoot"></a>三、SpringBoot</h2><h3 id="3-1-SpringBoot基础"><a href="#3-1-SpringBoot基础" class="headerlink" title="3.1 SpringBoot基础"></a>3.1 SpringBoot基础</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>springboot建立在spring框架之上，简化了搭建和开发过程。使用“习惯优于配置”的理念让项目快速运行，使用springboot很容易创建一个独立运行、准生产级别的基于spring框架的项目。</p><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p>独立运行的Spring项目</p><p>内嵌的servlet容器</p><p>starter简化maven配置</p><p>java配置和注解配置组合</p><p>应用监控</p><p>自动配置bean </p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>快速构建项目</p><p>更少、更简易的配置</p><p>对主流开发框架的无配置集成</p><p>内嵌servlet容器，项目可独立运行</p><p>提供运行时的应用监控</p><h4 id="Spring-Boot-Stater"><a href="#Spring-Boot-Stater" class="headerlink" title="Spring Boot Stater"></a>Spring Boot Stater</h4><p>启动器是一套方便的依赖描述符，它可以放在自己的程序中。你可以一站式的获取你所需要的 Spring 和相关技术，而不需要依赖描述符的通过示例代码搜索和复制黏贴的负载。</p><h4 id="springboot自动装配原理"><a href="#springboot自动装配原理" class="headerlink" title="springboot自动装配原理"></a>springboot自动装配原理</h4><p>也可以理解为<strong>springboot运行原理</strong></p><p><strong>@SpringBootApplication注解是最核心注解</strong></p><p><code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li><li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。</li></ul><p><strong><code>@EnableAutoConfiguration</code> 是实现自动装配的重要注解</strong></p><p>自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类</p><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DeferredImportSelector</span>, <span class="hljs-title">BeanClassLoaderAware</span>, <span class="hljs-title">ResourceLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">EnvironmentAware</span>, <span class="hljs-title">Ordered</span> </span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DeferredImportSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImportSelector</span> </span>&#123;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImportSelector</span> </span>&#123;       String[] selectImports(AnnotationMetadata var1);&#125;</code></pre><p>AutoConfigurationImportSelector 类实现了 ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] NO_IMPORTS = <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]; <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;         <span class="hljs-comment">// &lt;1&gt;.判断自动装配开关是否打开*        </span>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;                <span class="hljs-keyword">return</span> NO_IMPORTS;          &#125;   <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//&lt;2&gt;.获取所有需要装配的bean*            </span>    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-keyword">this</span>.beanClassLoader);       AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry        = <span class="hljs-keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);                <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());          &#125;    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="hljs-keyword">new</span> AutoConfigurationEntry();<span class="hljs-function">AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;    <span class="hljs-comment">//&lt;1&gt;.  是否开启自动装配</span>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;        <span class="hljs-keyword">return</span> EMPTY_ENTRY;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//&lt;2&gt;.用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName。</span>        AnnotationAttributes attributes = <span class="hljs-keyword">this</span>.getAttributes(annotationMetadata);        <span class="hljs-comment">//&lt;3&gt;.获取需要自动装配的所有配置类，读取META-INF/spring.factories</span>        List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);        <span class="hljs-comment">//&lt;4&gt;.这一步经历了一遍筛选，@ConditionalOnXXX 中的所有条件都满足，该类才会生效</span>        configurations = <span class="hljs-keyword">this</span>.removeDuplicates(configurations);        Set&lt;String&gt; exclusions = <span class="hljs-keyword">this</span>.getExclusions(annotationMetadata, attributes);        <span class="hljs-keyword">this</span>.checkExcludedClasses(configurations, exclusions);        configurations.removeAll(exclusions);        configurations = <span class="hljs-keyword">this</span>.filter(configurations, autoConfigurationMetadata);        <span class="hljs-keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);    &#125;&#125;</code></pre><div class="note note-success">            <p>@EnableAutoConfiguration注解是实现自动装配的重要注解。<code>AutoConfigurationImportSelector</code>类实现了自动装配的核心功能。其实现了 ImportSelector接口，获取了所有符合条件的类并将其加载到 IoC 容器中。其读取META-INF/spring.factories中的自动配置类，并筛除不满足各自@Conditional元注解的配置类</p>          </div><h3 id="3-2-SpringBoot配置"><a href="#3-2-SpringBoot配置" class="headerlink" title="3.2 SpringBoot配置"></a>3.2 SpringBoot配置</h3><h4 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h4><p>在yml可以使用**@project.groupId@** 这样的格式来获取pom文件中的信息</p><p>yml配置同样存在缺陷，官网上指明其不能支持@PropertySource，只能使用properties格式，即以下代码。此代码完成了从配置文件到entity的映射</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@PropertySource(&quot;classpath:xxx.properties&quot;)</span><span class="hljs-meta">@ConfigurationProperties(&quot;Student&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;&#125;</code></pre><h4 id="类型安全的配置"><a href="#类型安全的配置" class="headerlink" title="类型安全的配置"></a>类型安全的配置</h4><p>@ConfigurationProperties 将properties属性和一个bean相关联</p><h4 id="多环境配置Profile"><a href="#多环境配置Profile" class="headerlink" title="多环境配置Profile"></a>多环境配置Profile</h4><p>profile为在不同环境下使用不同的配置提供了支持</p><p>@profile(“dev”) 手动控制配置文件。</p><p>当你用两个不同profile配置实现类实现同一个接口时，容器也会根据当前环境调用不同impl</p><p>同时也可以在java -jar中指定spring.profiles.active参数控制当前服务使用哪一种环境</p><div class="note note-danger">            <p><strong>面试题——如何重新加载程序，而无需重启服务器：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><p>通过DEV工具实现。DEVTools模块将文件更改自动部署到服务器并自动重启，免去了手动重启的必要。在生产环境中被禁用。</p>          </div><h3 id="3-3-SpringBoot应用"><a href="#3-3-SpringBoot应用" class="headerlink" title="3.3 SpringBoot应用"></a>3.3 SpringBoot应用</h3><h4 id="自定义异常页面"><a href="#自定义异常页面" class="headerlink" title="自定义异常页面"></a>自定义异常页面</h4><p>resource目录新建<span class="label label-danger">public/error</span>，创建404.html 500.html</p><div class="note note-danger">            <p><strong>面试题——如何使用SpringBoot实现异常处理？</strong> </p>          </div><div class="note note-success">            <p>Spring提供了一种使用ControllerAdvice处理异常的非常有用的方法。我们通过实现一个ControllerAdvice类，来处理控制器类抛出的所有异常</p>          </div><h4 id="监视器-actuator"><a href="#监视器-actuator" class="headerlink" title="监视器 actuator"></a>监视器 actuator</h4><p>actuator可帮助您访问生产环境中正在运行的应用程序的当前状态。</p><p>actuator模块公开了一组可直接访问的接口来监视状态。可在yml中进行如下简单配置</p><pre><code class="hljs yaml"><span class="hljs-string">management：</span>  <span class="hljs-string">server：</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">9999</span>    <span class="hljs-attr">servlet:</span>      <span class="hljs-attr">context-path:</span> <span class="hljs-string">/www</span>  <span class="hljs-attr">endpoints:</span>    <span class="hljs-attr">web:</span>      <span class="hljs-attr">base-path:</span> <span class="hljs-string">/base</span>      <span class="hljs-attr">exposure:</span>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span>   <span class="hljs-comment">#开启所有监控终端</span>        <span class="hljs-attr">exclude:</span> [<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-string">&quot;health&quot;</span>]  <span class="hljs-comment">#指定要关闭的端口</span></code></pre><div class="note note-danger">            <p><strong>面试题——如何关闭监视器：</strong> </p>          </div><div class="note note-success">            <p>回答：</p><p>默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们。安全性是使用标准的HttpServletRequest.isUserInRole方法实施的。我们可以使用management.security.enabled=false来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性</p>          </div><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>使用spring-boot-starter-security依赖项。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。</p><h4 id="使用Redis"><a href="#使用Redis" class="headerlink" title="使用Redis"></a>使用Redis</h4><p>高并发情况下的问题</p><span class="label label-primary">**缓存雪崩**</span><ul><li>现象：某些缓存在同一时间集体到期失效，便会有可能引发缓存雪崩。</li><li>解决：提前规划好所有缓存的到期时间避免集体失效、 定时刷新缓存、 设置缓存刷新标记</li></ul><span class="label label-primary">**缓存穿透**</span><ul><li>现象：越过redis直接访问数据库。从DB查询结果为null时有可能会发生。</li><li>解决：为null的结果赋予一个默认值、布隆过滤器</li></ul><span class="label label-primary">**缓存击倒**</span><ul><li>现象：海量请求短时间内查询一个热点Key，直接服务器宕机</li><li>解决：请求端的负载均衡，数据端的分表算法</li></ul><span class="label label-primary">**热点缓存**</span><ul><li>现象：大量请求查询一个热点Key，此key过期的瞬间来不及更新，导致大量请求直接访问数据库</li><li>解决：双重检测锁</li></ul><pre><code class="hljs java"><span class="hljs-comment">// 双重检测锁伪代码</span>BoundValueOperations&lt;Object,Object&gt; ops = redisTemplate.boundValueOps(<span class="hljs-string">&quot;count&quot;</span>);Object count = ops.get();<span class="hljs-keyword">if</span>(count == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// 让2,3,4卡在这，等待一号存入redis，然后就不用再查数据库，直接命中redis了</span>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;        <span class="hljs-keyword">if</span>(count == <span class="hljs-keyword">null</span>) &#123;          <span class="hljs-comment">//查询DB</span>          count = dao.getValue();          <span class="hljs-comment">//存入redis</span>          ops.set(count, <span class="hljs-number">10</span>, TimeUnit.SECONDS);        &#125;    &#125;&#125; <span class="hljs-keyword">return</span> count;</code></pre><p>一看到双重检测锁，还是要想到线程安全性的。建议回看java专题多线程知识。</p><p>但是这里不会出现线程安全，首先count是一个成员变量</p><h3 id="3-4-springboot-WEB开发"><a href="#3-4-springboot-WEB开发" class="headerlink" title="3.4 springboot WEB开发"></a>3.4 springboot WEB开发</h3><h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4><h3 id="3-5-springboot-数据访问"><a href="#3-5-springboot-数据访问" class="headerlink" title="3.5 springboot 数据访问"></a>3.5 springboot 数据访问</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><ul><li>编程式事务管理</li><li>声明式事务管理</li></ul><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p><ul><li>**<code>PlatformTransactionManager</code>**： （平台）事务管理器，Spring 事务策略的核心。</li></ul><p>Spring 并不直接管理事务，而是提供了多种事务管理器。通过这个接口，Spring 为各个平台如 JDBC(<code>DataSourceTransactionManager</code>)、Hibernate(<code>HibernateTransactionManager</code>)、JPA(<code>JpaTransactionManager</code>)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><ul><li>**<code>TransactionDefinition</code>**： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li></ul><p><img src="/img/transactionDefinition.png"></p><ul><li>**<code>TransactionStatus</code>**： 事务运行状态。</li></ul><p><code>TransactionStatus</code>接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。</p><p><code>PlatformTransactionManager.getTransaction(…)</code>方法返回一个 <code>TransactionStatus</code> 对象。</p><p><strong>事务属性详解</strong></p><p>传播行为</p><p>隔离级别</p><p>超时属性</p><p>只读属性</p><p>回滚规则</p><p><strong><code>@Transactional</code> 事务注解原理</strong></p><p><code>@Transactional</code> 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。</p><p>如果一个类或者一个类中的 public 方法上被标注<code>@Transactional</code> 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被<code>@Transactional</code> 注解的 public 方法的时候，实际调用的是，<code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p><p><strong>@Transactional失效场景</strong></p><p>①非public方法</p><p>② rollbackFor 设置错误</p><p>③同一个类中方法调用，导致@Transactional失效</p><p>其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</p><p>④异常被你的 catch“吃了”导致@Transactional失效</p><p>⑤@Transactional 注解属性 propagation 设置错误</p><h2 id="四、SpringBatch"><a href="#四、SpringBatch" class="headerlink" title="四、SpringBatch"></a>四、SpringBatch</h2><p>SpringBatch是处理大量数据的批处理框架</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><style>  /* 只设置  note字体 */  .note {    font-family: "Microsoft YaHei",Georgia, sans, serif, KaiTi,;    font-size: 14px;  }</style><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Spring结构 <a href="https://blog.csdn.net/ThinkWon/article/details/102810819">https://blog.csdn.net/ThinkWon/article/details/102810819</a><p><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Spring基础教程 <a href="https://www.w3cschool.cn/wkspring/1h9m1h9m.html">https://www.w3cschool.cn/wkspring/1h9m1h9m.html</a><br><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>@Resource @Inject @Autowired <a href="https://www.cnblogs.com/pjfmeng/p/7551340.html">https://www.cnblogs.com/pjfmeng/p/7551340.html</a><br><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>依赖注入 <a href="https://blog.csdn.net/programmer_at/article/details/82389221">https://blog.csdn.net/programmer_at/article/details/82389221</a><br><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>很简洁的依赖注入 <a href="https://www.rainng.com/field-injection-is-not-recommend/">https://www.rainng.com/field-injection-is-not-recommend/</a><br><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>Redis <a href="https://blog.csdn.net/hanchao5272/article/details/99706189">https://blog.csdn.net/hanchao5272/article/details/99706189</a><br><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>javaguide spring综合 <a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93">https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93</a><br><a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>过滤器和拦截器 <a href="https://blog.csdn.net/heweimingming/article/details/79993591">https://blog.csdn.net/heweimingming/article/details/79993591</a><br><a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/10/02/hello-world/"/>
    <url>/2020/10/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
